---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T16:58:55.913Z
title: レンダリング
description: Next.jsのレンダリング環境、戦略、ランタイムの違いについて学びます。
---

レンダリングとは、記述したコードをユーザーインターフェースに変換するプロセスです。ReactとNext.jsを使用すると、サーバーサイドとクライアントサイドでコードの一部をレンダリングできるハイブリッドWebアプリケーションを作成できます。このセクションでは、これらのレンダリング環境、戦略、ランタイムの違いを理解するのに役立ちます。

## 基礎知識

まず、以下の3つの基本的なWeb概念に慣れておくと良いでしょう:

- アプリケーションコードが実行される[環境](#レンダリング環境): サーバーとクライアント
- ユーザーがアプリケーションを訪問または操作したときに開始される[リクエスト-レスポンスライフサイクル](#リクエスト-レスポンスライフサイクル)
- サーバーコードとクライアントコードを分離する[ネットワーク境界](#ネットワーク境界)

### レンダリング環境

Webアプリケーションがレンダリングされる環境には、クライアントとサーバーの2つがあります。

<Image
  alt="クライアントとサーバーの環境"
  srcLight="/docs/light/client-and-server-environments.png"
  srcDark="/docs/dark/client-and-server-environments.png"
  width="1600"
  height="672"
/>

- **クライアント**とは、ユーザーのデバイス上のブラウザを指し、アプリケーションコードを要求するリクエストをサーバーに送信します。その後、サーバーからのレスポンスをユーザーインターフェースに変換します。
- **サーバー**とは、アプリケーションコードを保存し、クライアントからのリクエストを受信して適切なレスポンスを返すデータセンター内のコンピュータを指します。

従来、開発者はサーバーとクライアント用のコードを記述する際に異なる言語（JavaScript、PHPなど）やフレームワークを使用する必要がありました。Reactを使用すると、開発者は**同じ言語（JavaScript）**と**同じフレームワーク（Next.jsなど）**を使用できます。この柔軟性により、コンテキストを切り替えることなく両方の環境用のコードをシームレスに記述できます。

ただし、各環境には独自の機能と制約があります。そのため、サーバーとクライアント用に記述するコードが常に同じとは限りません。データ取得やユーザー状態の管理など、特定の操作は一方の環境に適している場合があります。

これらの違いを理解することは、ReactとNext.jsを効果的に使用するための鍵です。詳細な違いとユースケースについては[サーバーコンポーネント](/docs/app/building-your-application/rendering/server-components)と[クライアントコンポーネント](/docs/app/building-your-application/rendering/client-components)のページで説明します。まずは基礎を固めていきましょう。

### リクエスト-レスポンスライフサイクル

大まかに言えば、すべてのWebサイトは同じ**リクエスト-レスポンスライフサイクル**に従います:

1. **ユーザー操作:** ユーザーがWebアプリケーションと対話します。リンクのクリック、フォームの送信、ブラウザのアドレスバーへの直接URL入力などが含まれます。
2. **HTTPリクエスト:** クライアントは[HTTP](https://developer.mozilla.org/docs/Web/HTTP)リクエストをサーバーに送信し、要求されているリソース、使用されているメソッド（`GET`、`POST`など）、必要に応じて追加データを含みます。
3. **サーバー処理:** サーバーはリクエストを処理し、適切なリソースで応答します。このプロセスにはルーティング、データ取得などいくつかのステップが含まれる場合があります。
4. **HTTPレスポンス:** リクエストの処理後、サーバーはHTTPレスポンスをクライアントに返します。このレスポンスにはステータスコード（リクエストが成功したかどうかを示す）と要求されたリソース（HTML、CSS、JavaScript、静的アセットなど）が含まれます。
5. **クライアント処理:** クライアントはリソースを解析してユーザーインターフェースをレンダリングします。
6. **ユーザー操作:** ユーザーインターフェースがレンダリングされると、ユーザーはそれと対話でき、プロセス全体が再び開始されます。

ハイブリッドWebアプリケーションを構築する際の主要な部分は、ライフサイクル内で作業をどのように分割し、ネットワーク境界をどこに配置するかを決定することです。

### ネットワーク境界

Web開発において、**ネットワーク境界**は異なる環境を分離する概念的な線です。例えば、クライアントとサーバー、またはサーバーとデータストアなどです。

{/* 図: ネットワーク境界 */}

Reactでは、最も理にかなっている場所にクライアント-サーバーのネットワーク境界を配置することを選択できます。

内部的には、作業は**クライアントモジュールグラフ**と**サーバーモジュールグラフ**の2つの部分に分割されます。サーバーモジュールグラフにはサーバーでレンダリングされるすべてのコンポーネントが含まれ、クライアントモジュールグラフにはクライアントでレンダリングされるすべてのコンポーネントが含まれます。

{/* 図: クライアントとサーバーのモジュールグラフ */}

モジュールグラフは、アプリケーション内のファイルが互いにどのように依存しているかを視覚的に表現したものと考えると良いでしょう。

{/* 例えば、`Page.jsx`というファイルがサーバー上で`Button.jsx`というファイルをインポートしている場合、モジュールグラフは次のようになります: - 図 - */}

Reactの`"use client"`規約を使用して境界を定義できます。また、`"use server"`規約もあり、これはReactにサーバー上で計算作業を行うように指示します。

## ハイブリッドアプリケーションの構築

これらの環境で作業する際、アプリケーション内のコードの流れを**一方向**と考えると役立ちます。言い換えると、レスポンス中にアプリケーションコードは一方向に流れます: サーバーからクライアントへ。

{/* 図: レスポンスの流れ */}

クライアントからサーバーにアクセスする必要がある場合は、同じリクエストを再利用するのではなく、サーバーに**新しい**リクエストを送信します。これにより、コンポーネントをどこでレンダリングし、ネットワーク境界をどこに配置するかを理解しやすくなります。

実際には、このモデルにより、開発者はアプリケーションをインタラクティブにする前に、まずサーバーで実行したいことを考えるようになります。

この概念は、[クライアントコンポーネントとサーバーコンポーネントを同じコンポーネントツリー内で組み合わせる方法](/docs/app/building-your-application/rendering/composition-patterns)を見るとより明確になります。