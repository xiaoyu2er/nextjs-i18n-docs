---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:16:20.754Z
title: Next.js での認証実装方法
nav_title: 認証
description: Next.js アプリケーションで認証を実装する方法を学びます。
---

認証を理解することは、アプリケーションのデータを保護するために重要です。このページでは、React と Next.js の機能を使用して認証を実装する方法を説明します。

開始前に、プロセスを3つの概念に分解すると理解しやすくなります：

1. **[認証 (Authentication)](#authentication)**：ユーザーが自分自身であることを確認します。ユーザー名とパスワードなど、ユーザーが持っている情報で身元を証明する必要があります。
2. **[セッション管理 (Session Management)](#session-management)**：リクエスト間でユーザーの認証状態を追跡します。
3. **[認可 (Authorization)](#authorization)**：ユーザーがアクセスできるルートやデータを決定します。

この図は、React と Next.js の機能を使用した認証フローを示しています：

<Image
  alt="React と Next.js の機能を使用した認証フローの図"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

このページの例では、教育目的で基本的なユーザー名とパスワード認証について説明します。カスタム認証ソリューションを実装することも可能ですが、セキュリティを強化し簡素化するために、認証ライブラリの使用を推奨します。これらは認証、セッション管理、認可のための組み込みソリューションに加え、ソーシャルログイン、多要素認証、ロールベースのアクセス制御などの追加機能を提供します。利用可能なライブラリのリストは[認証ライブラリ (Auth Libraries)](#auth-libraries)セクションで確認できます。

## 認証 (Authentication)

<AppOnly>

### サインアップとログイン機能

ユーザーの認証情報を取得し、フォームフィールドを検証して認証プロバイダーのAPIまたはデータベースを呼び出すために、[`<form>`](https://react.dev/reference/react-dom/components/form)要素とReactの[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)、`useActionState`を使用できます。

Server Actionsは常にサーバー上で実行されるため、認証ロジックを処理する安全な環境を提供します。

サインアップ/ログイン機能を実装する手順は次のとおりです：

#### 1. ユーザー認証情報の取得

ユーザー認証情報を取得するには、送信時にServer Actionを呼び出すフォームを作成します。例えば、ユーザーの名前、メールアドレス、パスワードを受け入れるサインアップフォーム：

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">名前</label>
        <input id="name" name="name" placeholder="名前" />
      </div>
      <div>
        <label htmlFor="email">メールアドレス</label>
        <input id="email" name="email" type="email" placeholder="メールアドレス" />
      </div>
      <div>
        <label htmlFor="password">パスワード</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">サインアップ</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">名前</label>
        <input id="name" name="name" placeholder="名前" />
      </div>
      <div>
        <label htmlFor="email">メールアドレス</label>
        <input id="email" name="email" type="email" placeholder="メールアドレス" />
      </div>
      <div>
        <label htmlFor="password">パスワード</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">サインアップ</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. サーバー上でのフォームフィールドの検証

Server Actionを使用して、サーバー上でフォームフィールドを検証します。認証プロバイダーがフォーム検証を提供していない場合は、[Zod](https://zod.dev/)や[Yup](https://github.com/jquense/yup)などのスキーマ検証ライブラリを使用できます。

Zodを例にすると、適切なエラーメッセージを含むフォームスキーマを定義できます：

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '名前は2文字以上で入力してください。' })
    .trim(),
  email: z.string().email({ message: '有効なメールアドレスを入力してください。' }).trim(),
  password: z
    .string()
    .min(8, { message: '8文字以上で入力してください' })
    .regex(/[a-zA-Z]/, { message: '少なくとも1文字のアルファベットを含めてください。' })
    .regex(/[0-9]/, { message: '少なくとも1文字の数字を含めてください。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '少なくとも1文字の特殊文字を含めてください。',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '名前は2文字以上で入力してください。' })
    .trim(),
  email: z.string().email({ message: '有効なメールアドレスを入力してください。' }).trim(),
  password: z
    .string()
    .min(8, { message: '8文字以上で入力してください' })
    .regex(/[a-zA-Z]/, { message: '少なくとも1文字のアルファベットを含めてください。' })
    .regex(/[0-9]/, { message: '少なくとも1文字の数字を含めてください。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '少なくとも1文字の特殊文字を含めてください。',
    })
    .trim(),
})
```

認証プロバイダーのAPIまたはデータベースへの不要な呼び出しを防ぐため、フォームフィールドが定義されたスキーマと一致しない場合、Server Actionで早期に`return`できます。

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // フォームフィールドの検証
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // 無効なフォームフィールドがある場合、早期に返す
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // ユーザー作成のためにプロバイダーまたはDBを呼び出す...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // フォームフィールドの検証
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // 無効なフォームフィールドがある場合、早期に返す
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // ユーザー作成のためにプロバイダーまたはDBを呼び出す...
}
```

`<SignupForm />`に戻り、Reactの`useActionState`フックを使用して、フォーム送信中に検証エラーを表示できます：

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">名前</label>
        <input id="name" name="name" placeholder="名前" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">メールアドレス</label>
        <input id="email" name="email" placeholder="メールアドレス" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">パスワード</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>パスワードは次の要件を満たす必要があります：</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        サインアップ
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">名前</label>
        <input id="name" name="name" placeholder="名前" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">メールアドレス</label>
        <input id="email" name="email" placeholder="メールアドレス" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">パスワード</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>パスワードは次の要件を満たす必要があります：</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        サインアップ
      </button>
    </form>
  )
}
```

> **知っておくと良いこと：**
>
> - React 19では、`useFormStatus`が返すオブジェクトにdata、method、actionなどの追加キーが含まれます。React 19を使用していない場合、`pending`キーのみが利用可能です。
> - データを変更する前に、ユーザーがその操作を実行する権限があることを常に確認する必要があります。[認証と認可 (Authentication and Authorization)](#authorization)を参照してください。

#### 3. ユーザー作成または認証情報の確認

フォームフィールドの検証後、認証プロバイダーのAPIやデータベースを呼び出して新しいユーザーアカウントを作成するか、既存ユーザーの認証情報を確認できます。

前の例からの続き:

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. フォームフィールドの検証
  // ...

  // 2. データベース挿入用データの準備
  const { name, email, password } = validatedFields.data
  // 例: パスワードをハッシュ化して保存
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. ユーザーをデータベースに挿入または認証ライブラリのAPIを呼び出し
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'アカウント作成中にエラーが発生しました。',
    }
  }

  // TODO:
  // 4. ユーザーセッションの作成
  // 5. ユーザーのリダイレクト
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. フォームフィールドの検証
  // ...

  // 2. データベース挿入用データの準備
  const { name, email, password } = validatedFields.data
  // 例: パスワードをハッシュ化して保存
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. ユーザーをデータベースに挿入またはライブラリAPIを呼び出し
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'アカウント作成中にエラーが発生しました。',
    }
  }

  // TODO:
  // 4. ユーザーセッションの作成
  // 5. ユーザーのリダイレクト
}
```

ユーザーアカウントの作成または認証情報の確認に成功したら、ユーザーの認証状態を管理するためにセッションを作成できます。セッション管理戦略に応じて、セッションはクッキーやデータベース、または両方に保存されます。[セッション管理](#session-management)セクションに進んで詳細を確認してください。

> **ヒント:**
>
> - 上記の例は教育的な目的で認証ステップを分解しているため冗長です。安全な独自ソリューションの実装がすぐに複雑になる可能性があることを示しています。プロセスを簡素化するために[認証ライブラリ](#auth-libraries)の使用を検討してください。
> - ユーザーエクスペリエンスを向上させるために、登録フローの早い段階で重複するメールアドレスやユーザー名を確認することをお勧めします。例えば、ユーザーがユーザー名を入力中または入力フィールドからフォーカスが外れた時点で確認できます。これにより不要なフォーム送信を防ぎ、ユーザーに即時フィードバックを提供できます。[use-debounce](https://www.npmjs.com/package/use-debounce)などのライブラリを使用してこれらの確認の頻度を管理できます。

</AppOnly>

<PagesOnly>

サインアップおよび/またはログインフォームを実装する手順は次のとおりです:

1. ユーザーがフォームを通じて認証情報を送信します。
2. フォームがAPIルートによって処理されるリクエストを送信します。
3. 検証が成功すると、ユーザーの認証が成功したことが示されます。
4. 検証が失敗した場合、エラーメッセージが表示されます。

ユーザーが認証情報を入力できるログインフォームを考えてみましょう:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラー処理
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">ログイン</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // エラー処理
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">ログイン</button>
    </form>
  )
}
```

上記のフォームには、ユーザーのメールアドレスとパスワードを取得するための2つの入力フィールドがあります。送信時に、APIルート(`/api/auth/login`)にPOSTリクエストを送信する関数がトリガーされます。

次に、APIルートで認証プロバイダーのAPIを呼び出して認証を処理できます:

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無効な認証情報です。' })
    } else {
      res.status(500).json({ error: '問題が発生しました。' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無効な認証情報です。' })
    } else {
      res.status(500).json({ error: '問題が発生しました。' })
    }
  }
}
```

</PagesOnly>

## セッション管理

セッション管理により、ユーザーの認証状態がリクエスト間で維持されます。セッションまたはトークンの作成、保存、更新、削除が含まれます。

セッションには2つのタイプがあります:

1. [**ステートレス**](#stateless-sessions): セッションデータ（またはトークン）がブラウザのクッキーに保存されます。クッキーは各リクエストとともに送信され、サーバーでセッションを検証できます。この方法はシンプルですが、正しく実装されていない場合は安全性が低くなる可能性があります。
2. [**データベース**](#database-sessions): セッションデータがデータベースに保存され、ユーザーのブラウザには暗号化されたセッションIDのみが送信されます。この方法はより安全ですが、複雑でサーバーリソースを多く使用する可能性があります。

> **知っておくと良いこと:** どちらの方法、または両方を使用できますが、[iron-session](https://github.com/vvo/iron-session)や[Jose](https://github.com/panva/jose)などのセッション管理ライブラリの使用をお勧めします。

### ステートレスセッション

<AppOnly>

ステートレスセッションを作成および管理するには、いくつかの手順に従う必要があります:

1. セッションの署名に使用する秘密鍵を生成し、[環境変数](/docs/app/guides/environment-variables)として保存します。
2. セッション管理ライブラリを使用してセッションデータを暗号化/復号化するロジックを作成します。
3. Next.jsの[`cookies`](/docs/app/api-reference/functions/cookies) APIを使用してクッキーを管理します。

上記に加えて、ユーザーがアプリケーションに戻ったときにセッションを[更新（またはリフレッシュ）](#updating-or-refreshing-sessions)する機能と、ユーザーがログアウトしたときにセッションを[削除](#deleting-the-session)する機能を追加することを検討してください。

> **知っておくと良いこと:** [認証ライブラリ](#auth-libraries)にセッション管理が含まれているか確認してください。

#### 1. 秘密鍵の生成

セッションに署名するための秘密鍵を生成する方法はいくつかあります。例えば、ターミナルで`openssl`コマンドを使用できます:

```bash filename="terminal"
openssl rand -base64 32
```

このコマンドは、[環境変数ファイル](/docs/app/guides/environment-variables)に保存できる32文字のランダムな文字列を生成します:

```bash filename=".env"
SESSION_SECRET=your_secret_key
```

次に、この鍵をセッション管理ロジックで参照できます:

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. セッションの暗号化と復号化

次に、好みの[セッション管理ライブラリ](#session-management-libraries)を使用してセッションを暗号化および復号化できます。前の例の続きとして、[Jose](https://www.npmjs.com/package/jose)（[Edge Runtime](/docs/app/api-reference/edge)と互換性あり）とReactの[`server-only`](https://www.npmjs.com/package/server-only)パッケージを使用して、セッション管理ロジックがサーバーでのみ実行されるようにします。

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('セッションの検証に失敗しました')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('セッションの検証に失敗しました')
  }
}
```

> **ヒント**:
>
> - ペイロードには、ユーザーのID、ロールなど、後続のリクエストで使用される**最小限の**一意のユーザーデータを含める必要があります。電話番号、メールアドレス、クレジットカード情報などの個人を特定できる情報や、パスワードなどの機密データを含めるべきではありません。

#### 3. クッキーの設定（推奨オプション）

セッションをクッキーに保存するには、Next.jsの[`cookies`](/docs/app/api-reference/functions/cookies) APIを使用します。クッキーはサーバーで設定し、推奨オプションを含める必要があります:

- **HttpOnly**: クライアントサイドのJavaScriptがクッキーにアクセスするのを防ぎます。
- **Secure**: クッキーを送信するためにhttpsを使用します。
- **SameSite**: クロスサイトリクエストでクッキーを送信できるかどうかを指定します。
- **Max-AgeまたはExpires**: 一定期間後にクッキーを削除します。
- **Path**: クッキーのURLパスを定義します。

これらのオプションの詳細については、[MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Cookies)を参照してください。

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

サーバーアクションに戻り、`createSession()`関数を呼び出し、[`redirect()`](/docs/app/guides/redirecting) APIを使用してユーザーを適切なページにリダイレクトできます:

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // 前のステップ:
  // 1. フォームフィールドの検証
  // 2. データベース挿入用データの準備
  // 3. ユーザーをデータベースに挿入またはライブラリAPIを呼び出し

  // 現在のステップ:
  // 4. ユーザーセッションの作成
  await createSession(user.id)
  // 5. ユーザーのリダイレクト
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // 前のステップ:
  // 1. フォームフィールドの検証
  // 2. データベース挿入用データの準備
  // 3. ユーザーをデータベースに挿入またはライブラリAPIを呼び出し

  // 現在のステップ:
  // 4. ユーザーセッションの作成
  await createSession(user.id)
  // 5. ユーザーのリダイレクト
  redirect('/profile')
}
```

> **ヒント**:
>
> - **クッキーはサーバーで設定する必要があります**。クライアントサイドでの改ざんを防ぐためです。
> - 🎥 視聴: Next.jsでのステートレスセッションと認証について詳しく学ぶ → [YouTube (11分)](https://www.youtube.com/watch?v=DJvM2lSPn6w)。

#### セッションの更新（またはリフレッシュ）

セッションの有効期限を延長することもできます。これは、ユーザーがアプリケーションに再度アクセスした後もログイン状態を維持するのに役立ちます。例えば:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **ヒント:** 認証ライブラリがリフレッシュトークンをサポートしているか確認してください。リフレッシュトークンを使用してユーザーのセッションを延長できます。

#### セッションの削除

セッションを削除するには、クッキーを削除します:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

その後、`deleteSession()` 関数をアプリケーション内で再利用できます。例えばログアウト時に:

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### クッキーの設定と削除

[API Routes](/docs/pages/building-your-application/routing/api-routes) を使用して、サーバー上でセッションをクッキーとして設定できます:

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 1週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 1週間
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

### データベースセッション

データベースセッションを作成・管理するには、以下の手順に従います:

1. セッションとデータを保存するデータベーステーブルを作成（または認証ライブラリが処理するか確認）
2. セッションの挿入、更新、削除機能を実装
3. セッションIDを暗号化してユーザーのブラウザに保存し、データベースとクッキーを同期（[ミドルウェア](#ミドルウェアを使用した楽観的チェック-オプション)での楽観的な認証チェックに推奨）

<AppOnly>

例:

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的認証チェックのためクッキーにセッションを保存
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. データベースにセッションを作成
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // セッションIDを返す
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. セッションIDを暗号化
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 楽観的認証チェックのためクッキーにセッションを保存
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **ヒント**:
>
> - 高速アクセスのため、セッションの存続期間中サーバーキャッシュを追加できます。また、セッションデータをプライマリデータベースに保持し、データリクエストを結合してクエリ数を減らせます
> - ユーザーの最終ログイン時間の追跡、アクティブデバイス数の管理、全デバイスからのログアウト機能など、高度なユースケースでデータベースセッションを使用できます

セッション管理を実装した後、ユーザーがアプリケーション内でアクセス・実行できる内容を制御する認可ロジックを追加する必要があります。[認可](#認可)セクションに進んで詳細を確認してください

</AppOnly>

<PagesOnly>

**サーバー上でのセッション作成**:

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

## 認可

ユーザーが認証されセッションが作成されたら、アプリケーション内でユーザーがアクセス・実行できる内容を制御する認可を実装できます。

認可チェックには主に2つのタイプがあります:

1. **楽観的チェック**: クッキーに保存されたセッションデータを使用して、ユーザーがルートにアクセスしたりアクションを実行したりする権限があるかを確認。UI要素の表示/非表示や、権限やロールに基づくユーザーリダイレクトなど、迅速な操作に有用
2. **セキュアチェック**: データベースに保存されたセッションデータを使用して、ユーザーがルートにアクセスしたりアクションを実行したりする権限があるかを確認。機密データやアクションへのアクセスが必要な操作で使用

どちらの場合も以下を推奨します:

- 認可ロジックを一元化する[データアクセスレイヤー](#データアクセスレイヤー-dal-の作成)の作成
- 必要なデータのみを返す[データ転送オブジェクト（DTO）](#データ転送オブジェクト-dto-の使用)の使用
- オプションで[ミドルウェア](#ミドルウェアを使用した楽観的チェック-オプション)を使用した楽観的チェック

### ミドルウェアを使用した楽観的チェック (オプション)

[ミドルウェア](/docs/app/building-your-application/routing/middleware)を使用して、権限に基づきユーザーをリダイレクトする場合があります:

- 楽観的チェックを実行するため。ミドルウェアはすべてのルートで実行されるため、リダイレクトロジックを一元化し、未承認ユーザーを事前にフィルタリングする良い方法
- ユーザー間でデータを共有する静的ルート（有料コンテンツなど）を保護するため

ただし、ミドルウェアは[プリフェッチ](/docs/app/getting-started/linking-and-navigating#prefetching)されたルートを含むすべてのルートで実行されるため、パフォーマンス問題を防ぐため、クッキーからのセッション読み取り（楽観的チェック）のみを行い、データベースチェックは避けることが重要です。

例:

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護ルートと公開ルートを指定
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. 現在のルートが保護対象か公開対象かを確認
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. クッキーからセッションを復号
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. ユーザーが認証されていない場合、/loginにリダイレクト
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. ユーザーが認証されている場合、/dashboardにリダイレクト
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアが実行されないルート
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 保護ルートと公開ルートを指定
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. 現在のルートが保護対象か公開対象かを確認
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. クッキーからセッションを復号
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. ユーザーが認証されていない場合、/loginにリダイレクト
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. ユーザーが認証されている場合、/dashboardにリダイレクト
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// ミドルウェアが実行されないルート
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

ミドルウェアは初期チェックに有用ですが、データ保護の唯一の防御線とすべきではありません。セキュリティチェックの大部分はデータソースにできるだけ近い場所で実行する必要があります。[データアクセスレイヤー](#データアクセスレイヤー-dal-の作成)を参照してください。

> **ヒント**:
>
> - ミドルウェアでは `req.cookies.get('session').value` を使用してクッキーを読み取れます
> - ミドルウェアは[Edge Runtime](/docs/app/api-reference/edge)を使用するため、認証ライブラリとセッション管理ライブラリが互換性があるか確認
> - ミドルウェアの `matcher` プロパティを使用して、ミドルウェアが実行されるルートを指定できます。ただし認証の場合、すべてのルートでミドルウェアを実行することを推奨

<AppOnly>

### データアクセスレイヤー (DAL) の作成

データリクエストと認可ロジックを一元化するため、DALの作成を推奨します。

DALには、ユーザーがアプリケーションとやり取りする際にセッションを検証する関数を含める必要があります。少なくとも、セッションが有効かどうかを確認し、リダイレクトまたはさらなるリクエストに必要なユーザー情報を返す必要があります。

例えば、DAL用に別ファイルを作成し、`verifySession()` 関数を含めます。次にReactの[cache](https://react.dev/reference/react/cache) APIを使用して、Reactレンダーパス中に関数の戻り値をメモ化します:

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

その後、データリクエスト、Server Actions、Route Handlersで `verifySession()` 関数を呼び出せます:

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // ユーザーオブジェクト全体ではなく、必要な列のみ明示的に返す
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // ユーザーオブジェクト全体ではなく、必要な列のみ明示的に返す
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

> **ヒント**:
>
> - DALはリクエスト時にフェッチされるデータを保護するために使用できます。ただし、ユーザー間でデータを共有する静的ルートの場合、データはビルド時にフェッチされ、リクエスト時にはフェッチされません。静的ルートを保護するには[ミドルウェア](#ミドルウェアを使用した楽観的チェック-オプション)を使用
> - セキュアチェックの場合、セッションIDをデータベースと比較してセッションが有効か確認できます。Reactの[cache](https://react.dev/reference/react/cache)関数を使用して、レンダーパス中のデータベースへの不要な重複リクエストを回避
> - 関連するデータリクエストを、任意のメソッドの前に `verifySession()` を実行するJavaScriptクラスに統合することも可能

### データ転送オブジェクト (DTO) の使用

データを取得する際は、アプリケーションで使用する必要があるデータのみを返し、オブジェクト全体を返さないことを推奨します。例えば、ユーザーデータを取得する場合、パスワードや電話番号などが含まれる可能性のあるユーザーオブジェクト全体ではなく、ユーザーIDと名前のみを返すことが考えられます。

ただし、返されるデータ構造を制御できない場合や、クライアントにオブジェクト全体が渡されるのを防ぎたいチームで作業している場合は、クライアントに公開しても安全なフィールドを指定するなどの戦略を使用できます。

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // ここで特定のカラムを返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // またはクエリ固有のデータのみを返す
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // ここで特定のカラムを返す
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // またはクエリ固有のデータのみを返す
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

データアクセス層 (DAL) でデータリクエストと認可ロジックを一元化し、DTOを使用することで、すべてのデータリクエストが安全で一貫性のあるものになり、アプリケーションのスケールに伴うメンテナンス、監査、デバッグが容易になります。

> **知っておくと良いこと**:
>
> - DTOを定義する方法はいくつかあります。`toJSON()` を使用する方法、上記の例のような個別の関数を使用する方法、JSクラスを使用する方法などです。これらはReactやNext.jsの機能ではなくJavaScriptのパターンであるため、アプリケーションに最適なパターンを見つけるために調査を行うことをお勧めします。
> - セキュリティのベストプラクティスについては、[Next.jsのセキュリティ記事](/blog/security-nextjs-server-components-actions)で詳しく学ぶことができます。

### サーバーコンポーネント

[サーバーコンポーネント](/docs/app/getting-started/server-and-client-components)での認証チェックは、ロールベースのアクセス制御に有用です。例えば、ユーザーのロールに基づいてコンポーネントを条件付きでレンダリングする場合:

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // セッションオブジェクトに 'role' が含まれていると仮定

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // セッションオブジェクトに 'role' が含まれていると仮定

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

この例では、DALから `verifySession()` 関数を使用して 'admin'、'user'、および未認証のロールをチェックしています。このパターンにより、各ユーザーは自分のロールに適したコンポーネントのみと対話することが保証されます。

### レイアウトと認証チェック

[部分的なレンダリング](/docs/app/getting-started/linking-and-navigating#client-side-transitions)のため、[レイアウト](/docs/app/api-reference/file-conventions/layout)でチェックを行う場合は注意が必要です。これらはナビゲーション時に再レンダリングされないため、ルート変更のたびにユーザーセッションがチェックされません。

代わりに、データソースに近い場所や、条件付きでレンダリングされるコンポーネントでチェックを行うべきです。

例えば、ユーザーデータを取得し、ナビゲーションにユーザー画像を表示する共有レイアウトを考えます。レイアウトで認証チェックを行うのではなく、レイアウトでユーザーデータ (`getUser()`) を取得し、DALで認証チェックを行うべきです。

これにより、アプリケーション内で `getUser()` が呼び出される場所であればどこでも認証チェックが実行され、開発者がデータへのアクセス権限をチェックするのを忘れるのを防ぎます。

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザーIDを取得し、データを取得
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // セッションからユーザーIDを取得し、データを取得
})
```

> **知っておくと良いこと:**
>
> - SPAでは、ユーザーが認証されていない場合にレイアウトや最上位のコンポーネントで `return null` とするパターンが一般的です。このパターンは**推奨されません**。Next.jsアプリケーションには複数のエントリポイントがあるため、ネストされたルートセグメントやサーバーアクションへのアクセスを防ぐことができないからです。

### サーバーアクション

[サーバーアクション](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)は、公開APIエンドポイントと同じセキュリティ考慮事項で扱い、ユーザーが変更を実行する権限があるかどうかを確認してください。

以下の例では、アクションを続行する前にユーザーのロールをチェックしています:

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // ユーザーがアクションを実行する権限がない場合は早期リターン
  if (userRole !== 'admin') {
    return null
  }

  // 認可されたユーザーのためにアクションを続行
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // ユーザーがアクションを実行する権限がない場合は早期リターン
  if (userRole !== 'admin') {
    return null
  }

  // 認可されたユーザーのためにアクションを続行
}
```

### ルートハンドラー

[ルートハンドラー](/docs/app/building-your-application/routing/route-handlers)は、公開APIエンドポイントと同じセキュリティ考慮事項で扱い、ユーザーがルートハンドラーにアクセスする権限があるかどうかを確認してください。

例えば:

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証とロール確認
  const session = await verifySession()

  // ユーザーが認証されているか確認
  if (!session) {
    // ユーザーが認証されていない
    return new Response(null, { status: 401 })
  }

  // ユーザーが 'admin' ロールを持っているか確認
  if (session.user.role !== 'admin') {
    // ユーザーは認証されているが適切な権限がない
    return new Response(null, { status: 403 })
  }

  // 認可されたユーザーのために続行
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // ユーザー認証とロール確認
  const session = await verifySession()

  // ユーザーが認証されているか確認
  if (!session) {
    // ユーザーが認証されていない
    return new Response(null, { status: 401 })
  }

  // ユーザーが 'admin' ロールを持っているか確認
  if (session.user.role !== 'admin') {
    // ユーザーは認証されているが適切な権限がない
    return new Response(null, { status: 403 })
  }

  // 認可されたユーザーのために続行
}
```

上記の例は、2段階のセキュリティチェックを持つルートハンドラーを示しています。最初にアクティブなセッションをチェックし、次にログインしているユーザーが 'admin' かどうかを確認します。

## コンテキストプロバイダー

認証にコンテキストプロバイダーを使用するのは、[インターリービング](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components)のため機能します。ただし、Reactの `context` はサーバーコンポーネントではサポートされていないため、クライアントコンポーネントにのみ適用可能です。

これは機能しますが、子のサーバーコンポーネントは最初にサーバーでレンダリングされるため、コンテキストプロバイダーのセッションデータにアクセスできません:

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

クライアントコンポーネントでセッションデータが必要な場合（例えばクライアントサイドのデータ取得のために）、Reactの [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) APIを使用して、機密性の高いセッションデータがクライアントに公開されないようにします。

</AppOnly>

<PagesOnly>

### データアクセス層 (DAL) の作成

#### APIルートの保護

Next.jsのAPIルートは、サーバーサイドのロジックとデータ管理を処理するために不可欠です。これらのルートを保護し、認証されたユーザーのみが特定の機能にアクセスできるようにすることが重要です。これには通常、ユーザーの認証ステータスとロールベースの権限の確認が含まれます。

以下はAPIルートを保護する例です:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // ユーザーが認証されているか確認
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // ユーザーが 'admin' ロールを持っているか確認
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // 認可されたユーザーのためにルートを続行
  // ... APIルートの実装
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // ユーザーが認証されているか確認
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // ユーザーが 'admin' ロールを持っているか確認
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // 認可されたユーザーのためにルートを続行
  // ... APIルートの実装
}
```

この例は、認証と認可の2段階のセキュリティチェックを持つAPIルートを示しています。最初にアクティブなセッションをチェックし、次にログインしているユーザーが 'admin' かどうかを確認します。このアプローチにより、認証され認可されたユーザーのみが安全にアクセスでき、リクエスト処理の堅牢なセキュリティが維持されます。

</PagesOnly>

## リソース

Next.jsでの認証について学んだので、安全な認証とセッション管理を実装するために役立つNext.js互換のライブラリとリソースを紹介します:

### 認証ライブラリ

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### セッション管理ライブラリ

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## さらに学ぶ

認証とセキュリティについてさらに学ぶには、以下のリソースを確認してください:

- [Next.jsでのセキュリティの考え方](/blog/security-nextjs-server-components-actions)
- [XSS攻撃の理解](https://vercel.com/guides/understanding-xss-attacks)
- [CSRF攻撃の理解](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
