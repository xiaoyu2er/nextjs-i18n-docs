---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:06:52.413Z
title: TypeScript
description: Next.js offre une exp√©rience de d√©veloppement ax√©e sur TypeScript pour construire votre application React.
---

{/* Le contenu de ce document est partag√© entre le routeur App et Pages. Vous pouvez utiliser le composant `<PagesOnly>Contenu</PagesOnly>` pour ajouter du contenu sp√©cifique au routeur Pages. Tout contenu partag√© ne doit pas √™tre encapsul√© dans un composant. */}

Next.js int√®gre nativement TypeScript, installant automatiquement les packages n√©cessaires et configurant les param√®tres appropri√©s lorsque vous cr√©ez un nouveau projet avec `create-next-app`.

Pour ajouter TypeScript √† un projet existant, renommez un fichier en `.ts` / `.tsx`. Ex√©cutez `next dev` et `next build` pour installer automatiquement les d√©pendances requises et ajouter un fichier `tsconfig.json` avec les options de configuration recommand√©es.

> **Bon √† savoir** : Si vous avez d√©j√† un fichier `jsconfig.json`, copiez l'option `paths` du compilateur depuis l'ancien `jsconfig.json` vers le nouveau fichier `tsconfig.json`, puis supprimez l'ancien `jsconfig.json`.

<AppOnly>

## Plugin IDE

Next.js inclut un plugin TypeScript personnalis√© et un v√©rificateur de types, que VSCode et d'autres √©diteurs de code peuvent utiliser pour une v√©rification de types avanc√©e et de l'auto-compl√©tion.

Vous pouvez activer le plugin dans VS Code en :

1. Ouvrant la palette de commandes (`Ctrl/‚åò` + `Shift` + `P`)
2. Recherchant "TypeScript: Select TypeScript Version"
3. S√©lectionnant "Use Workspace Version"

<Image
  alt="Palette de commandes TypeScript"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

Maintenant, lors de l'√©dition des fichiers, le plugin personnalis√© sera activ√©. Lors de l'ex√©cution de `next build`, le v√©rificateur de types personnalis√© sera utilis√©.

Le plugin TypeScript peut aider avec :

- Un avertissement si des valeurs invalides pour les [options de configuration des segments](/docs/app/api-reference/file-conventions/route-segment-config) sont pass√©es.
- L'affichage des options disponibles et de la documentation contextuelle.
- La v√©rification que la directive `'use client'` est utilis√©e correctement.
- La v√©rification que les hooks clients (comme `useState`) ne sont utilis√©s que dans les composants clients.

> **üé• Regarder** : D√©couvrez le plugin TypeScript int√©gr√© ‚Üí [YouTube (3 minutes)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## S√©curit√© de type de bout en bout

Le routeur App de Next.js offre **une s√©curit√© de type am√©lior√©e**. Cela inclut :

1. **Aucune s√©rialisation des donn√©es entre la fonction de r√©cup√©ration et la page** : Vous pouvez utiliser `fetch` directement dans les composants, layouts et pages c√¥t√© serveur. Ces donn√©es _n'ont pas_ besoin d'√™tre s√©rialis√©es (converties en cha√Æne) pour √™tre pass√©es c√¥t√© client et consomm√©es dans React. Au lieu de cela, puisque `app` utilise par d√©faut des composants serveur, nous pouvons utiliser des valeurs comme `Date`, `Map`, `Set`, et plus encore sans √©tapes suppl√©mentaires. Auparavant, vous deviez typer manuellement la fronti√®re entre le serveur et le client avec des types sp√©cifiques √† Next.js.
2. **Flux de donn√©es simplifi√© entre les composants** : Avec la suppression de `_app` au profit des layouts racine, il est maintenant plus facile de visualiser le flux de donn√©es entre les composants et les pages. Auparavant, les donn√©es circulant entre les `pages` individuelles et `_app` √©taient difficiles √† typer et pouvaient introduire des bugs d√©routants. Avec la [r√©cup√©ration de donn√©es colocalis√©e](/docs/app/getting-started/fetching-data) dans le routeur App, ce n'est plus un probl√®me.

[La r√©cup√©ration de donn√©es dans Next.js](/docs/app/getting-started/fetching-data) offre d√©sormais une s√©curit√© de type aussi proche que possible du bout en bout sans √™tre prescriptif quant √† votre choix de base de donn√©es ou de fournisseur de contenu.

Nous pouvons typer les donn√©es de r√©ponse comme vous vous y attendriez avec TypeScript normal. Par exemple :

```tsx filename="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // La valeur de retour n'est *pas* s√©rialis√©e
  // Vous pouvez retourner Date, Map, Set, etc.
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

Pour une s√©curit√© de type _compl√®te_ de bout en bout, cela n√©cessite √©galement que votre base de donn√©es ou fournisseur de contenu prenne en charge TypeScript. Cela peut √™tre via l'utilisation d'un [ORM](https://fr.wikipedia.org/wiki/Mapping_objet-relationnel) ou d'un constructeur de requ√™tes type-safe.

</AppOnly>

## Exemples

### V√©rification de type de `next.config.ts`

Vous pouvez utiliser TypeScript et importer des types dans votre configuration Next.js en utilisant `next.config.ts`.

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* options de configuration ici */
}

export default nextConfig
```

> **Bon √† savoir** : La r√©solution des modules dans `next.config.ts` est actuellement limit√©e √† `CommonJS`. Cela peut causer des incompatibilit√©s avec les packages ESM uniquement charg√©s dans `next.config.ts`.

Lors de l'utilisation du fichier `next.config.js`, vous pouvez ajouter une v√©rification de type dans votre IDE en utilisant JSDoc comme ci-dessous :

```js filename="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* options de configuration ici */
}

module.exports = nextConfig
```

<AppOnly>

### Liens statiquement typ√©s

Next.js peut typer statiquement les liens pour pr√©venir les fautes de frappe et autres erreurs lors de l'utilisation de `next/link`, am√©liorant la s√©curit√© de type lors de la navigation entre les pages.

Pour activer cette fonctionnalit√©, `experimental.typedRoutes` doit √™tre activ√© et le projet doit utiliser TypeScript.

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.js g√©n√©rera une d√©finition de lien dans `.next/types` qui contient des informations sur toutes les routes existantes dans votre application, que TypeScript peut ensuite utiliser pour fournir des retours dans votre √©diteur sur les liens invalides.

Actuellement, le support exp√©rimental inclut tout litt√©ral de cha√Æne, y compris les segments dynamiques. Pour les cha√Ænes non litt√©rales, vous devez actuellement caster manuellement le `href` avec `as Route` :

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// Aucune erreur TypeScript si href est une route valide
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// Erreurs TypeScript si href n'est pas une route valide
<Link href="/aboot" />
```

Pour accepter `href` dans un composant personnalis√© encapsulant `next/link`, utilisez un g√©n√©rique :

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>Ma Carte</div>
    </Link>
  )
}
```

> **Comment √ßa marche ?**
>
> Lors de l'ex√©cution de `next dev` ou `next build`, Next.js g√©n√®re un fichier `.d.ts` cach√© dans `.next` qui contient des informations sur toutes les routes existantes dans votre application (toutes les routes valides comme type `href` de `Link`). Ce fichier `.d.ts` est inclus dans `tsconfig.json` et le compilateur TypeScript v√©rifiera ce `.d.ts` et fournira des retours dans votre √©diteur sur les liens invalides.

### Avec les composants serveur asynchrones

Pour utiliser un composant serveur `async` avec TypeScript, assurez-vous d'utiliser TypeScript `5.1.3` ou sup√©rieur et `@types/react` `18.2.8` ou sup√©rieur.

Si vous utilisez une version plus ancienne de TypeScript, vous pourriez voir une erreur de type `'Promise<Element>' is not a valid JSX element`. Mettre √† jour vers la derni√®re version de TypeScript et `@types/react` devrait r√©soudre ce probl√®me.

</AppOnly>

<PagesOnly>

### G√©n√©ration statique et rendu c√¥t√© serveur

Pour [`getStaticProps`](/docs/pages/api-reference/functions/get-static-props), [`getStaticPaths`](/docs/pages/api-reference/functions/get-static-paths), et [`getServerSideProps`](/docs/pages/api-reference/functions/get-server-side-props), vous pouvez utiliser respectivement les types `GetStaticProps`, `GetStaticPaths`, et `GetServerSideProps` :

```tsx filename="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Bon √† savoir :** `satisfies` a √©t√© ajout√© √† TypeScript dans la [version 4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html). Nous recommandons de mettre √† jour vers la derni√®re version de TypeScript.

### Avec les routes API

Voici un exemple d'utilisation des types int√©gr√©s pour les routes API :

```ts filename="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

Vous pouvez √©galement typer les donn√©es de r√©ponse :

```ts filename="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

### Avec un `App` personnalis√©

Si vous avez une [application `App` personnalis√©e](/docs/pages/building-your-application/routing/custom-app), vous pouvez utiliser le type int√©gr√© `AppProps` et renommer le fichier en `./pages/_app.tsx` comme suit :

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

### V√©rification de type incr√©mentielle

Depuis la version `v10.2.1`, Next.js prend en charge la [v√©rification de type incr√©mentielle](https://www.typescriptlang.org/tsconfig#incremental) lorsqu'elle est activ√©e dans votre `tsconfig.json`, ce qui peut aider √† acc√©l√©rer la v√©rification de type dans les applications plus grandes.

### D√©sactivation des erreurs TypeScript en production

Next.js √©choue votre **build de production** (`next build`) lorsque des erreurs TypeScript sont pr√©sentes dans votre projet.

Si vous souhaitez que Next.js produise dangereusement du code de production m√™me lorsque votre application contient des erreurs, vous pouvez d√©sactiver l'√©tape de v√©rification de type int√©gr√©e.

Si d√©sactiv√©e, assurez-vous d'ex√©cuter des v√©rifications de type dans le cadre de votre processus de build ou de d√©ploiement, sinon cela peut √™tre tr√®s dangereux.

Ouvrez `next.config.ts` et activez l'option `ignoreBuildErrors` dans la configuration `typescript` :

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! ATTENTION !!
    // Permet dangereusement aux builds de production de se terminer avec succ√®s m√™me si
    // votre projet contient des erreurs de type.
    // !! ATTENTION !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Bon √† savoir** : Vous pouvez ex√©cuter `tsc --noEmit` pour v√©rifier les erreurs TypeScript vous-m√™me avant de build. Ceci est utile pour les pipelines CI/CD o√π vous souhaitez v√©rifier les erreurs TypeScript avant le d√©ploiement.

### D√©clarations de type personnalis√©es

Lorsque vous avez besoin de d√©clarer des types personnalis√©s, vous pourriez √™tre tent√© de modifier `next-env.d.ts`. Cependant, ce fichier est g√©n√©r√© automatiquement, donc toute modification que vous apportez sera √©cras√©e. √Ä la place, vous devriez cr√©er un nouveau fichier, appelons-le `new-types.d.ts`, et le r√©f√©rencer dans votre `tsconfig.json` :

```json filename="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...tronqu√©...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## Changements de version

| Version   | Changements                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `v15.0.0` | Ajout du support de [`next.config.ts`](#v√©rification-de-type-de-nextconfigts) pour les projets TypeScript.                                               |
| `v13.2.0` | Les liens statiquement typ√©s sont disponibles en version b√™ta.                                                                                        |
| `v12.0.0` | [SWC](/docs/architecture/nextjs-compiler) est maintenant utilis√© par d√©faut pour compiler TypeScript et TSX pour des builds plus rapides.                    |
| `v10.2.1` | Ajout du support de la [v√©rification de type incr√©mentielle](https://www.typescriptlang.org/tsconfig#incremental) lorsqu'elle est activ√©e dans votre `tsconfig.json`. |