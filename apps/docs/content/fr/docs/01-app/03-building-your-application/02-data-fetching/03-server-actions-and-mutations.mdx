---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:12:04.570Z
title: Actions serveur et mutations
nav_title: Actions serveur et mutations
description: Apprenez √† g√©rer les soumissions de formulaires et les mutations de donn√©es avec Next.js.
related:
  description: Apprenez √† configurer les actions serveur dans Next.js
  links:
    - app/api-reference/config/next-config-js/serverActions
---

Les [actions serveur (Server Actions)](https://react.dev/reference/rsc/server-actions) sont des **fonctions asynchrones** ex√©cut√©es sur le serveur. Elles peuvent √™tre appel√©es dans les composants serveur et client pour g√©rer les soumissions de formulaires et les mutations de donn√©es dans les applications Next.js.

> **üé• √Ä regarder :** En savoir plus sur les mutations avec les actions serveur ‚Üí [YouTube (10 minutes)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## Convention

Une action serveur peut √™tre d√©finie avec la directive React [`"use server"`](https://react.dev/reference/react/use-server). Vous pouvez placer la directive en haut d'une fonction `async` pour marquer la fonction comme une action serveur, ou en haut d'un fichier s√©par√© pour marquer toutes les exportations de ce fichier comme des actions serveur.

### Composants serveur

Les composants serveur peuvent utiliser la directive `"use server"` au niveau de la fonction ou du module. Pour int√©grer une action serveur, ajoutez `"use server"` en haut du corps de la fonction :

```tsx filename="app/page.tsx" switcher
export default function Page() {
  // Action serveur
  async function create() {
    'use server'
    // Mutation de donn√©es
  }

  return '...'
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  // Action serveur
  async function create() {
    'use server'
    // Mutation de donn√©es
  }

  return '...'
}
```

### Composants client

Pour appeler une [fonction serveur](/docs/app/getting-started/updating-data#server-functions) dans un composant client, cr√©ez un nouveau fichier et ajoutez la directive `"use server"` en haut. Toutes les fonctions export√©es dans le fichier seront marqu√©es comme des fonctions serveur pouvant √™tre r√©utilis√©es dans les composants client et serveur :

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {}
```

```tsx filename="app/button.tsx" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

```jsx filename="app/button.js" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

### Passage d'actions comme props

Vous pouvez √©galement passer une action serveur √† un composant client comme prop :

```jsx
<ClientComponent updateItemAction={updateItem} />
```

```tsx filename="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

```jsx filename="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

Habituellement, le plugin TypeScript de Next.js signalerait `updateItemAction` dans `client-component.tsx` car il s'agit d'une fonction qui ne peut g√©n√©ralement pas √™tre s√©rialis√©e entre les limites client-serveur.
Cependant, les props nomm√©es `action` ou se terminant par `Action` sont suppos√©es recevoir des actions serveur.
Ceci n'est qu'une heuristique car le plugin TypeScript ne sait pas r√©ellement si elle re√ßoit une action serveur ou une fonction ordinaire.
La v√©rification de type √† l'ex√©cution garantira toujours que vous ne passiez pas accidentellement une fonction √† un composant client.

## Comportement

- Les actions serveur peuvent √™tre invoqu√©es en utilisant l'attribut `action` dans un √©l√©ment `<form>`.
  - Les composants serveur prennent en charge l'am√©lioration progressive par d√©faut, ce qui signifie que le formulaire sera soumis m√™me si JavaScript n'est pas encore charg√© ou est d√©sactiv√©.
  - Dans les composants client, les formulaires invoquant des actions serveur mettront en file d'attente les soumissions si JavaScript n'est pas encore charg√©, en priorisant l'hydratation client.
  - Apr√®s l'hydratation, le navigateur ne se rafra√Æchit pas lors de la soumission du formulaire.
- Les actions serveur ne sont pas limit√©es aux `<form>` et peuvent √™tre invoqu√©es depuis des gestionnaires d'√©v√©nements, `useEffect`, des biblioth√®ques tierces et d'autres √©l√©ments de formulaire comme `<button>`.
- Les actions serveur s'int√®grent √† l'architecture de [mise en cache et revalidation](/docs/app/deep-dive/caching) de Next.js. Lorsqu'une action est invoqu√©e, Next.js peut renvoyer √† la fois l'interface utilisateur mise √† jour et les nouvelles donn√©es en un seul aller-retour serveur.
- En arri√®re-plan, les actions utilisent la m√©thode `POST`, et seule cette m√©thode HTTP peut les invoquer.
- Les arguments et la valeur de retour des actions serveur doivent √™tre s√©rialisables par React. Voir la documentation React pour une liste des [arguments et valeurs s√©rialisables](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values).
- Les actions serveur sont des fonctions. Cela signifie qu'elles peuvent √™tre r√©utilis√©es n'importe o√π dans votre application.
- Les actions serveur h√©ritent du runtime de la page ou du layout dans lequel elles sont utilis√©es.
- Les actions serveur h√©ritent de la [configuration de segment de route (Route Segment Config)](/docs/app/api-reference/file-conventions/route-segment-config) de la page ou du layout dans lequel elles sont utilis√©es, y compris des champs comme `maxDuration`.

## Exemples

### Gestionnaires d'√©v√©nements

Bien qu'il soit courant d'utiliser des actions serveur dans des √©l√©ments `<form>`, elles peuvent √©galement √™tre invoqu√©es avec des gestionnaires d'√©v√©nements comme `onClick`. Par exemple, pour incr√©menter un compteur de likes :

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

Vous pouvez √©galement ajouter des gestionnaires d'√©v√©nements aux √©l√©ments de formulaire, par exemple pour sauvegarder un champ de formulaire `onChange` :

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publish</button>
    </form>
  )
}
```

Pour des cas comme celui-ci, o√π plusieurs √©v√©nements peuvent √™tre d√©clench√©s rapidement, nous recommandons d'utiliser un **debouncing** pour √©viter des invocations inutiles d'actions serveur.

### `useEffect`

Vous pouvez utiliser le hook React [`useEffect`](https://react.dev/reference/react/useEffect) pour invoquer une action serveur lorsque le composant est mont√© ou qu'une d√©pendance change. Ceci est utile pour les mutations qui d√©pendent d'√©v√©nements globaux ou qui doivent √™tre d√©clench√©es automatiquement. Par exemple, `onKeyDown` pour les raccourcis d'application, un hook d'observateur d'intersection pour le d√©filement infini, ou lorsque le composant est mont√© pour mettre √† jour un compteur de vues :

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    startTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // Vous pouvez utiliser `isPending` pour donner un retour aux utilisateurs
  return <p>Total Views: {views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    starTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // Vous pouvez utiliser `isPending` pour donner un retour aux utilisateurs
  return <p>Total Views: {views}</p>
}
```

N'oubliez pas de consid√©rer les [comportements et mises en garde](https://react.dev/reference/react/useEffect#caveats) de `useEffect`.

### Gestion des erreurs

Lorsqu'une erreur est lev√©e, elle sera captur√©e par le fichier `error.js` le plus proche ou la limite `<Suspense>` sur le client. Voir [Gestion des erreurs](/docs/app/getting-started/error-handling) pour plus d'informations.

> **Bon √† savoir :**
>
> - En plus de lever l'erreur, vous pouvez √©galement retourner un objet √† g√©rer par `useActionState`.

### Revalidation des donn√©es

Vous pouvez revalider le [cache Next.js](/docs/app/deep-dive/caching) dans vos actions serveur avec l'API [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

Ou invalider une r√©cup√©ration de donn√©es sp√©cifique avec une √©tiquette de cache en utilisant [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### Redirection

Si vous souhaitez rediriger l'utilisateur vers une route diff√©rente apr√®s la compl√©tion d'une action serveur, vous pouvez utiliser l'API [`redirect`](/docs/app/api-reference/functions/redirect). `redirect` doit √™tre appel√© en dehors du bloc `try/catch` :

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Mise √† jour des posts en cache
  redirect(`/post/${id}`) // Navigation vers la nouvelle page de post
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Mise √† jour des posts en cache
  redirect(`/post/${id}`) // Navigation vers la nouvelle page de post
}
```

### Cookies

Vous pouvez `get`, `set` et `delete` des cookies dans une action serveur en utilisant l'API [`cookies`](/docs/app/api-reference/functions/cookies) :

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // R√©cup√©rer un cookie
  cookieStore.get('name')?.value

  // D√©finir un cookie
  cookieStore.set('name', 'Delba')

  // Supprimer un cookie
  cookieStore.delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // R√©cup√©rer un cookie
  const cookieStore = await cookies()

  // R√©cup√©rer un cookie
  cookieStore.get('name')?.value

  // D√©finir un cookie
  cookieStore.set('name', 'Delba')

  // Supprimer un cookie
  cookieStore.delete('name')
}
```

Voir [des exemples suppl√©mentaires](/docs/app/api-reference/functions/cookies#deleting-cookies) pour supprimer des cookies depuis des actions serveur.

## S√©curit√©

Par d√©faut, lorsqu'une action serveur est cr√©√©e et export√©e, elle cr√©e un point de terminaison HTTP public
et doit √™tre trait√©e avec les m√™mes hypoth√®ses de s√©curit√© et v√©rifications d'autorisation. Cela signifie que m√™me si une action serveur ou une fonction utilitaire n'est pas import√©e ailleurs dans votre code, elle reste accessible publiquement.

Pour am√©liorer la s√©curit√©, Next.js dispose des fonctionnalit√©s int√©gr√©es suivantes :

- **Identifiants d'action s√©curis√©s :** Next.js cr√©e des identifiants chiffr√©s et non d√©terministes pour permettre au client de r√©f√©rencer et d'appeler l'action serveur. Ces identifiants sont recalcul√©s p√©riodiquement entre les builds pour une s√©curit√© renforc√©e.
- **√âlimination du code mort :** Les actions serveur inutilis√©es (r√©f√©renc√©es par leurs identifiants) sont supprim√©es du bundle client pour √©viter un acc√®s public par des tiers.

> **Bon √† savoir :**
>
> Les identifiants sont cr√©√©s pendant la compilation et sont mis en cache pour un maximum de 14 jours. Ils seront r√©g√©n√©r√©s lorsqu'un nouveau build est initi√© ou lorsque le cache de build est invalid√©.
> Cette am√©lioration de s√©curit√© r√©duit les risques dans les cas o√π une couche d'authentification est manquante. Cependant, vous devez toujours traiter les actions serveur comme des points de terminaison HTTP publics.

```jsx
// app/actions.js
'use server'

// Cette action **est** utilis√©e dans notre application, donc Next.js
// cr√©era un identifiant s√©curis√© pour permettre au client de r√©f√©rencer
// et d'appeler l'action serveur.
export async function updateUserAction(formData) {}

// Cette action **n'est pas** utilis√©e dans notre application, donc Next.js
// supprimera automatiquement ce code pendant `next build`
// et ne cr√©era pas de point de terminaison public.
export async function deleteUserAction(formData) {}
```

### Authentification et autorisation

Vous devez vous assurer que l'utilisateur est autoris√© √† effectuer l'action. Par exemple :

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('You must be signed in to perform this action')
  }

  // ...
}
```

### Fermetures et chiffrement

D√©finir une action serveur dans un composant cr√©e une [fermeture (closure)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) o√π l'action a acc√®s √† la port√©e de la fonction externe. Par exemple, l'action `publish` a acc√®s √† la variable `publishVersion` :

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('The version has changed since pressing publish');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('The version has changed since pressing publish');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

Les fermetures sont utiles lorsque vous avez besoin de capturer un _instantan√©_ de donn√©es (par exemple `publishVersion`) au moment du rendu pour pouvoir l'utiliser plus tard lorsque l'action est invoqu√©e.

Cependant, pour que cela se produise, les variables captur√©es sont envoy√©es au client et retourn√©es au serveur lorsque l'action est invoqu√©e. Pour emp√™cher l'exposition de donn√©es sensibles au client, Next.js chiffre automatiquement les variables captur√©es. Une nouvelle cl√© priv√©e est g√©n√©r√©e pour chaque action √† chaque fois qu'une application Next.js est build√©e. Cela signifie que les actions ne peuvent √™tre invoqu√©es que pour un build sp√©cifique.

> **Bon √† savoir :** Nous ne recommandons pas de compter uniquement sur le chiffrement pour emp√™cher l'exposition de valeurs sensibles au client. √Ä la place, vous devriez utiliser les [API React taint](/docs/app/api-reference/config/next-config-js/taint) pour emp√™cher proactivement l'envoi de donn√©es sp√©cifiques au client.

### Remplacement des cl√©s de chiffrement (usage avanc√©)

Lorsque vous auto-h√©bergez votre application Next.js sur plusieurs serveurs, chaque instance de serveur peut se retrouver avec une cl√© de chiffrement diff√©rente, ce qui peut entra√Æner des incoh√©rences.

Pour att√©nuer ce probl√®me, vous pouvez remplacer la cl√© de chiffrement en utilisant la variable d'environnement `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY`. Sp√©cifier cette variable garantit que vos cl√©s de chiffrement persistent entre les builds et que toutes les instances de serveur utilisent la m√™me cl√©. Cette variable **doit** √™tre chiffr√©e avec AES-GCM.

Il s'agit d'un cas d'usage avanc√© o√π un comportement de chiffrement coh√©rent entre plusieurs d√©ploiements est critique pour votre application. Vous devriez envisager des pratiques de s√©curit√© standard telles que la rotation des cl√©s et la signature.

> **Bon √† savoir :** Les applications Next.js d√©ploy√©es sur Vercel g√®rent cela automatiquement.

### Origines autoris√©es (usage avanc√©)

Comme les Actions Serveur peuvent √™tre invoqu√©es dans un √©l√©ment `<form>`, cela les expose aux [attaques CSRF](https://developer.mozilla.org/fr/docs/Glossary/CSRF).

En arri√®re-plan, les Actions Serveur utilisent la m√©thode `POST`, et seule cette m√©thode HTTP est autoris√©e pour les invoquer. Cela emp√™che la plupart des vuln√©rabilit√©s CSRF dans les navigateurs modernes, en particulier avec les [cookies SameSite](https://web.dev/articles/samesite-cookies-explained) √©tant activ√©s par d√©faut.

Comme protection suppl√©mentaire, les Actions Serveur dans Next.js comparent √©galement l'[en-t√™te Origin](https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Origin) √† l'[en-t√™te Host](https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Host) (ou `X-Forwarded-Host`). Si ceux-ci ne correspondent pas, la requ√™te sera abandonn√©e. En d'autres termes, les Actions Serveur ne peuvent √™tre invoqu√©es que sur le m√™me h√¥te que la page qui les h√©berge.

Pour les grandes applications utilisant des proxies invers√©s ou des architectures backend √† plusieurs niveaux (o√π l'API serveur diff√®re du domaine de production), il est recommand√© d'utiliser l'option de configuration [`serverActions.allowedOrigins`](/docs/app/api-reference/config/next-config-js/serverActions) pour sp√©cifier une liste d'origines s√ªres. L'option accepte un tableau de cha√Ænes de caract√®res.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

En savoir plus sur la [S√©curit√© et les Actions Serveur](https://nextjs.org/blog/security-nextjs-server-components-actions).

## Ressources suppl√©mentaires

Pour plus d'informations, consultez la documentation React suivante :

- [Actions Serveur](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
