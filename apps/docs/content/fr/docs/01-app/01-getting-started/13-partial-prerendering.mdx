---
source-updated-at: 2025-06-08T05:18:03.000Z
translation-updated-at: 2025-06-08T05:18:03.000Z
title: Comment utiliser le Pr√©rendu Partiel (Partial Prerendering)
nav_title: Pr√©rendu Partiel
description: D√©couvrez comment combiner les avantages du rendu statique et dynamique avec le Pr√©rendu Partiel (Partial Prerendering).
version: experimental
related:
  title: Prochaines √©tapes
  description: En savoir plus sur l'option de configuration pour le Pr√©rendu Partiel.
  links:
    - app/api-reference/config/next-config-js/ppr
---

Le Pr√©rendu Partiel (PPR) est une strat√©gie de rendu qui vous permet de combiner du contenu statique et dynamique dans la m√™me route. Cela am√©liore les performances initiales de la page tout en prenant en charge des donn√©es dynamiques et personnalis√©es.

<Image
  alt="Page de produit partiellement pr√©rendue montrant une navigation statique et des informations sur le produit, ainsi qu'un panier dynamique et des produits recommand√©s"
  srcLight="/learn/light/thinking-in-ppr.png"
  srcDark="/learn/dark/thinking-in-ppr.png"
  width="1600"
  height="632"
/>

Lorsqu'un utilisateur visite une route :

- Le serveur envoie une **enveloppe** contenant le contenu statique, garantissant un chargement initial rapide.
- L'enveloppe laisse des **trous** pour le contenu dynamique qui se chargera de mani√®re asynchrone.
- Les trous dynamiques sont **transmis en parall√®le**, r√©duisant ainsi le temps de chargement global de la page.

> **üé• Regarder :** Pourquoi PPR et comment √ßa fonctionne ‚Üí [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).

## Comment fonctionne le Pr√©rendu Partiel ?

Pour comprendre le Pr√©rendu Partiel, il est utile de conna√Ætre les strat√©gies de rendu disponibles dans Next.js.

### Rendu Statique (Static Rendering)

Avec le Rendu Statique, le HTML est g√©n√©r√© √† l'avance‚Äîsoit au moment de la construction, soit via [revalidation](/docs/app/guides/incremental-static-regeneration). Le r√©sultat est mis en cache et partag√© entre les utilisateurs et les requ√™tes.

Dans le Pr√©rendu Partiel, Next.js pr√©rend une **enveloppe statique** pour une route. Cela peut inclure la mise en page et tout autre composant qui ne d√©pend pas de donn√©es au moment de la requ√™te.

### Rendu Dynamique (Dynamic Rendering)

Avec le Rendu Dynamique, le HTML est g√©n√©r√© au **moment de la requ√™te**. Cela vous permet de servir un contenu personnalis√© bas√© sur des donn√©es au moment de la requ√™te.

Un composant devient dynamique s'il utilise les API suivantes :

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)
- [`fetch`](/docs/app/api-reference/functions/fetch) avec `{ cache: 'no-store' }`

Dans le Pr√©rendu Partiel, l'utilisation de ces API g√©n√®re une erreur React sp√©ciale qui informe Next.js que le composant ne peut pas √™tre rendu statiquement, provoquant une erreur de construction. Vous pouvez utiliser une limite [Suspense](#suspense) pour encapsuler votre composant et diff√©rer son rendu jusqu'au moment de l'ex√©cution.

### Suspense

React [Suspense](https://react.dev/reference/react/Suspense) est utilis√© pour diff√©rer le rendu de certaines parties de votre application jusqu'√† ce qu'une condition soit remplie.

Dans le Pr√©rendu Partiel, Suspense est utilis√© pour marquer les **limites dynamiques** dans votre arborescence de composants.

Au moment de la construction, Next.js pr√©rend le contenu statique et l'interface utilisateur de `fallback`. Le contenu dynamique est **report√©** jusqu'√† ce que l'utilisateur demande la route.

Encapsuler un composant dans Suspense ne rend pas le composant lui-m√™me dynamique (c'est l'utilisation de vos API qui le fait), mais Suspense est utilis√© comme une limite qui encapsule le contenu dynamique et permet le [streaming](#streaming).

```jsx filename="app/page.js"
import { Suspense } from 'react'
import StaticComponent from './StaticComponent'
import DynamicComponent from './DynamicComponent'
import Fallback from './Fallback'

export const experimental_ppr = true

export default function Page() {
  return (
    <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
    </>
  )
}
```

### Streaming

Le Streaming divise la route en morceaux et les transmet progressivement au client d√®s qu'ils sont pr√™ts. Cela permet √† l'utilisateur de voir certaines parties de la page imm√©diatement, avant que tout le contenu n'ait fini de se rendre.

<Image
  alt="Diagramme montrant une page partiellement rendue c√¥t√© client, avec une interface de chargement pour les morceaux en cours de streaming."
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

Dans le Pr√©rendu Partiel, les composants dynamiques encapsul√©s dans Suspense commencent √† √™tre transmis depuis le serveur en parall√®le.

<Image
  alt="Diagramme montrant la parall√©lisation des segments de route pendant le streaming, montrant la r√©cup√©ration des donn√©es, le rendu et l'hydratation des morceaux individuels."
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Pour r√©duire la surcharge r√©seau, la r√©ponse compl√®te‚Äîy compris le HTML statique et les parties dynamiques transmises‚Äîest envoy√©e dans une **seule requ√™te HTTP**. Cela √©vite des allers-retours suppl√©mentaires et am√©liore √† la fois le chargement initial et les performances globales.

## Activation du Pr√©rendu Partiel

Vous pouvez activer PPR en ajoutant l'option [`ppr`](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr) √† votre fichier `next.config.ts` :

```ts filename="next.config.ts" highlight={5} switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

export default nextConfig
```

```js filename="next.config.js" highlight={4} switcher
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}
```

La valeur `'incremental'` vous permet d'adopter PPR pour des routes sp√©cifiques :

```tsx filename="/app/dashboard/layout.tsx"
export const experimental_ppr = true

export default function Layout({ children }: { children: React.ReactNode }) {
  // ...
}
```

```jsx filename="/app/dashboard/layout.js"
export const experimental_ppr = true

export default function Layout({ children }) {
  // ...
}
```

Les routes qui n'ont pas `experimental_ppr` auront par d√©faut la valeur `false` et ne seront pas pr√©rendues avec PPR. Vous devez explicitement activer PPR pour chaque route.

> **Bon √† savoir** :
>
> - `experimental_ppr` s'appliquera √† tous les enfants du segment de route, y compris les mises en page et les pages imbriqu√©es. Vous n'avez pas besoin de l'ajouter √† chaque fichier, seulement au segment sup√©rieur d'une route.
> - Pour d√©sactiver PPR pour les segments enfants, vous pouvez d√©finir `experimental_ppr` sur `false` dans le segment enfant.

## Exemples

### API Dynamiques

Lors de l'utilisation d'API dynamiques qui n√©cessitent d'examiner la requ√™te entrante, Next.js passera en mode rendu dynamique pour la route. Pour continuer √† utiliser PPR, encapsulez le composant avec Suspense. Par exemple, le composant `<User />` est dynamique car il utilise l'API `cookies` :

```jsx filename="app/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

```tsx filename="app/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

Le composant `<User />` sera transmis en streaming tandis que tout autre contenu √† l'int√©rieur de `<Page />` sera pr√©rendu et fera partie de l'enveloppe statique.

```tsx filename="app/page.tsx" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Ceci sera pr√©rendu</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Ceci sera pr√©rendu</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

### Passage de props dynamiques

Les composants ne passent en mode rendu dynamique que lorsque la valeur est acc√©d√©e. Par exemple, si vous lisez `searchParams` depuis un composant `<Page />`, vous pouvez transmettre cette valeur √† un autre composant en tant que prop :

```tsx filename="app/page.tsx" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  return (
    <section>
      <h1>Ceci sera pr√©rendu</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({ searchParams }) {
  return (
    <section>
      <h1>Ceci sera pr√©rendu</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

√Ä l'int√©rieur du composant Table, l'acc√®s √† la valeur de `searchParams` rendra le composant dynamique tandis que le reste de la page sera pr√©rendu.

```tsx filename="app/table.tsx" switcher
export async function Table({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

```jsx filename="app/table.js" switcher
export async function Table({ searchParams }) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```