---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T19:59:08.240Z
title: Comment auto-h√©berger votre application Next.js
nav_title: Auto-h√©bergement
description: Apprenez √† auto-h√©berger votre application Next.js sur un serveur Node.js, une image Docker ou des fichiers HTML statiques (export statique).
---

{/* Le contenu de ce document est partag√© entre le routeur App et Pages. Vous pouvez utiliser le composant `<PagesOnly>Contenu</PagesOnly>` pour ajouter du contenu sp√©cifique au routeur Pages. Tout contenu partag√© ne doit pas √™tre encapsul√© dans un composant. */}

Lors du [d√©ploiement](/docs/app/getting-started/deploying) de votre application Next.js, vous pouvez configurer la mani√®re dont les diff√©rentes fonctionnalit√©s sont g√©r√©es en fonction de votre infrastructure.

> **üé• Regarder :** En savoir plus sur l'auto-h√©bergement de Next.js ‚Üí [YouTube (45 minutes)](https://www.youtube.com/watch?v=sIVL4JMqRfc).

## Optimisation des images

L'[optimisation des images](/docs/app/api-reference/components/image) via `next/image` fonctionne en auto-h√©bergement sans configuration lors d'un d√©ploiement avec `next start`. Si vous pr√©f√©rez utiliser un service distinct pour optimiser les images, vous pouvez [configurer un chargeur d'images](/docs/app/api-reference/components/image#loader).

L'optimisation des images peut √™tre utilis√©e avec un [export statique](/docs/app/guides/static-exports#image-optimization) en d√©finissant un chargeur d'images personnalis√© dans `next.config.js`. Notez que les images sont optimis√©es lors de l'ex√©cution, pas pendant la construction.

> **Bon √† savoir :**
>
> - Sur les syst√®mes Linux bas√©s sur glibc, l'optimisation des images peut n√©cessiter une [configuration suppl√©mentaire](https://sharp.pixelplumbing.com/install#linux-memory-allocator) pour √©viter une utilisation excessive de la m√©moire.
> - En savoir plus sur le [comportement de mise en cache des images optimis√©es](/docs/app/api-reference/components/image#minimumcachettl) et comment configurer la dur√©e de vie (TTL).
> - Vous pouvez √©galement [d√©sactiver l'optimisation des images](/docs/app/api-reference/components/image#unoptimized) tout en conservant les autres avantages de `next/image`. Par exemple, si vous optimisez vous-m√™me les images s√©par√©ment.

## Middleware

Le [middleware](/docs/app/building-your-application/routing/middleware) fonctionne en auto-h√©bergement sans configuration lors d'un d√©ploiement avec `next start`. Comme il n√©cessite un acc√®s √† la requ√™te entrante, il n'est pas pris en charge avec un [export statique](/docs/app/guides/static-exports).

Le middleware utilise le [runtime Edge](/docs/app/api-reference/edge), un sous-ensemble des API Node.js disponibles pour garantir une faible latence, puisqu'il peut s'ex√©cuter devant chaque route ou ressource de votre application. Si vous ne souhaitez pas cela, vous pouvez utiliser le [runtime Node.js complet](/blog/next-15-2#nodejs-middleware-experimental) pour ex√©cuter le middleware.

Si vous souhaitez ajouter une logique (ou utiliser un package externe) n√©cessitant toutes les API Node.js, vous pouvez d√©placer cette logique dans un [layout](/docs/app/api-reference/file-conventions/layout) en tant que [composant serveur](/docs/app/getting-started/server-and-client-components). Par exemple, v√©rifier les [en-t√™tes](/docs/app/api-reference/functions/headers) et [rediriger](/docs/app/api-reference/functions/redirect). Vous pouvez √©galement utiliser des en-t√™tes, cookies ou param√®tres de requ√™te pour [rediriger](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching) ou [r√©√©crire](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching) via `next.config.js`. Si cela ne fonctionne pas, vous pouvez aussi utiliser un [serveur personnalis√©](/docs/pages/guides/custom-server).

## Variables d'environnement

Next.js prend en charge les variables d'environnement au moment de la construction et lors de l'ex√©cution.

**Par d√©faut, les variables d'environnement ne sont disponibles que sur le serveur**. Pour exposer une variable d'environnement au navigateur, elle doit √™tre pr√©fix√©e par `NEXT_PUBLIC_`. Cependant, ces variables publiques seront int√©gr√©es dans le bundle JavaScript lors de `next build`.

<PagesOnly>

Pour lire les variables d'environnement lors de l'ex√©cution, nous recommandons d'utiliser `getServerSideProps` ou [d'adopter progressivement le routeur App](/docs/app/guides/migrating/app-router-migration).

</PagesOnly>

<AppOnly>

Vous pouvez lire en toute s√©curit√© les variables d'environnement sur le serveur pendant le rendu dynamique.

```tsx filename="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers et autres API dynamiques
  // activeront √©galement le rendu dynamique, ce qui signifie
  // que cette variable d'environnement est √©valu√©e lors de l'ex√©cution
  const value = process.env.MY_VALUE
  // ...
}
```

```jsx filename="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers et autres API dynamiques
  // activeront √©galement le rendu dynamique, ce qui signifie
  // que cette variable d'environnement est √©valu√©e lors de l'ex√©cution
  const value = process.env.MY_VALUE
  // ...
}
```

</AppOnly>

Cela vous permet d'utiliser une seule image Docker pouvant √™tre promue √† travers plusieurs environnements avec des valeurs diff√©rentes.

> **Bon √† savoir :**
>
> - Vous pouvez ex√©cuter du code au d√©marrage du serveur avec la [fonction `register`](/docs/app/guides/instrumentation).
> - Nous ne recommandons pas d'utiliser l'option [runtimeConfig](/docs/pages/api-reference/config/next-config-js/runtime-configuration), car elle ne fonctionne pas avec le mode de sortie autonome. Nous recommandons plut√¥t d'[adopter progressivement](/docs/app/guides/migrating/app-router-migration) le routeur App.

## Mise en cache et ISR

Next.js peut mettre en cache les r√©ponses, les pages statiques g√©n√©r√©es, les sorties de construction et d'autres ressources statiques comme les images, polices et scripts.

La mise en cache et la revalidation des pages (avec la [r√©g√©n√©ration statique incr√©mentielle](/docs/app/guides/incremental-static-regeneration)) utilisent le **m√™me cache partag√©**. Par d√©faut, ce cache est stock√© sur le syst√®me de fichiers (sur disque) sur votre serveur Next.js. **Cela fonctionne automatiquement en auto-h√©bergement** avec les routeurs App et Pages.

Vous pouvez configurer l'emplacement du cache Next.js si vous souhaitez persister les pages et donn√©es mises en cache dans un stockage durable, ou partager le cache entre plusieurs conteneurs ou instances de votre application Next.js.

### Mise en cache automatique

- Next.js d√©finit l'en-t√™te `Cache-Control` √† `public, max-age=31536000, immutable` pour les ressources r√©ellement immuables. Cela ne peut pas √™tre modifi√©. Ces fichiers immuables contiennent un hachage SHA dans leur nom, ils peuvent donc √™tre mis en cache ind√©finiment. Par exemple, les [imports d'images statiques](/docs/app/getting-started/images#local-images). Vous pouvez [configurer la dur√©e de vie (TTL)](/docs/app/api-reference/components/image#minimumcachettl) pour les images.
- La r√©g√©n√©ration statique incr√©mentielle (ISR) d√©finit l'en-t√™te `Cache-Control` √† `s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`. Ce temps de revalidation est d√©fini dans votre [fonction `getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) en secondes. Si vous d√©finissez `revalidate: false`, la dur√©e de mise en cache par d√©faut sera d'un an.
- Les pages rendues dynamiquement d√©finissent un en-t√™te `Cache-Control` √† `private, no-cache, no-store, max-age=0, must-revalidate` pour emp√™cher la mise en cache de donn√©es sp√©cifiques √† l'utilisateur. Cela s'applique aux routeurs App et Pages. Cela inclut √©galement le [mode brouillon](/docs/app/guides/draft-mode).

### Ressources statiques

Si vous souhaitez h√©berger des ressources statiques sur un domaine ou CDN diff√©rent, vous pouvez utiliser la configuration `assetPrefix` dans `next.config.js`. Next.js utilisera ce pr√©fixe pour r√©cup√©rer les fichiers JavaScript ou CSS. S√©parer vos ressources sur un domaine diff√©rent a l'inconv√©nient d'un temps suppl√©mentaire pour la r√©solution DNS et TLS.

[En savoir plus sur `assetPrefix`](/docs/app/api-reference/config/next-config-js/assetPrefix).

### Configuration de la mise en cache

Par d√©faut, les ressources mises en cache seront stock√©es en m√©moire (50 Mo par d√©faut) et sur disque. Si vous h√©bergez Next.js avec une plateforme d'orchestration de conteneurs comme Kubernetes, chaque pod aura une copie du cache. Pour √©viter d'afficher des donn√©es obsol√®tes puisque le cache n'est pas partag√© entre les pods par d√©faut, vous pouvez configurer le cache Next.js pour fournir un gestionnaire de cache et d√©sactiver la mise en cache en m√©moire.

Pour configurer l'emplacement du cache ISR/Data lors de l'auto-h√©bergement, vous pouvez d√©finir un gestionnaire personnalis√© dans votre fichier `next.config.js` :

```jsx filename="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // d√©sactiver la mise en cache en m√©moire par d√©faut
}
```

Ensuite, cr√©ez `cache-handler.js` √† la racine de votre projet, par exemple :

```jsx filename="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // Cela peut √™tre stock√© n'importe o√π, comme un stockage durable
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // Cela peut √™tre stock√© n'importe o√π, comme un stockage durable
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tags est soit une cha√Æne, soit un tableau de cha√Ænes
    tags = [tags].flat()
    // Parcourir toutes les entr√©es du cache
    for (let [key, value] of cache) {
      // Si les tags de la valeur incluent le tag sp√©cifi√©, supprimer cette entr√©e
      if (value.tags.some((tag) => tags.includes(tag))) {
        cache.delete(key)
      }
    }
  }

  // Si vous souhaitez avoir un cache temporaire en m√©moire pour une seule requ√™te qui est r√©initialis√©
  // avant la prochaine requ√™te, vous pouvez utiliser cette m√©thode
  resetRequestCache() {}
}
```

L'utilisation d'un gestionnaire de cache personnalis√© vous permet d'assurer la coh√©rence entre tous les pods h√©bergeant votre application Next.js. Par exemple, vous pouvez enregistrer les valeurs mises en cache n'importe o√π, comme [Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis) ou AWS S3.

> **Bon √† savoir :**
>
> - `revalidatePath` est une couche de commodit√© au-dessus des tags de cache. Appeler `revalidatePath` appellera la fonction `revalidateTag` avec un tag sp√©cial par d√©faut pour la page fournie.

## Cache de construction

Next.js g√©n√®re un ID lors de `next build` pour identifier quelle version de votre application est servie. La m√™me construction doit √™tre utilis√©e et d√©marr√©e sur plusieurs conteneurs.

Si vous reconstruisez pour chaque √©tape de votre environnement, vous devrez g√©n√©rer un ID de construction coh√©rent √† utiliser entre les conteneurs. Utilisez la commande `generateBuildId` dans `next.config.js` :

```jsx filename="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // Cela peut √™tre n'importe quoi, comme le dernier hash git
    return process.env.GIT_HASH
  },
}
```

## D√©synchronisation de version

Next.js att√©nue automatiquement la plupart des cas de [d√©synchronisation de version](https://www.industrialempathy.com/posts/version-skew/) et recharge automatiquement l'application pour r√©cup√©rer les nouvelles ressources lorsqu'elle est d√©tect√©e. Par exemple, s'il y a une incompatibilit√© dans le `deploymentId`, les transitions entre pages effectueront une navigation compl√®te plut√¥t que d'utiliser une valeur pr√©charg√©e.

Lors du rechargement de l'application, il peut y avoir une perte d'√©tat si elle n'est pas con√ßue pour persister entre les navigations. Par exemple, utiliser l'√©tat de l'URL ou le stockage local persisterait l'√©tat apr√®s un rafra√Æchissement. Cependant, l'√©tat des composants comme `useState` serait perdu lors de telles navigations.

<AppOnly>

## Streaming et Suspense

Le routeur App de Next.js prend en charge les [r√©ponses en streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming) en auto-h√©bergement. Si vous utilisez Nginx ou un proxy similaire, vous devrez le configurer pour d√©sactiver la mise en m√©moire tampon et activer le streaming.

Par exemple, vous pouvez d√©sactiver la mise en m√©moire tampon dans Nginx en d√©finissant `X-Accel-Buffering` √† `no` :

```js filename="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

## Pr√©-rendu partiel

Le [pr√©-rendu partiel (exp√©rimental)](/docs/app/getting-started/partial-prerendering) fonctionne par d√©faut avec Next.js et n'est pas une fonctionnalit√© r√©serv√©e aux CDN. Cela inclut le d√©ploiement en tant que serveur Node.js (via `next start`) et avec un conteneur Docker.

## Utilisation avec les CDN

Lors de l'utilisation d'un CDN devant votre application Next.js, la page inclura l'en-t√™te de r√©ponse `Cache-Control: private` lorsque les API dynamiques sont acc√©d√©es. Cela garantit que la page HTML r√©sultante est marqu√©e comme non mise en cache. Si la page est enti√®rement pr√©-rendue en statique, elle inclura `Cache-Control: public` pour permettre la mise en cache sur le CDN.

Si vous n'avez pas besoin d'un m√©lange de composants statiques et dynamiques, vous pouvez rendre toute votre route statique et mettre en cache le HTML sur un CDN. Cette optimisation statique automatique est le comportement par d√©faut lors de l'ex√©cution de `next build` si les API dynamiques ne sont pas utilis√©es.

√Ä mesure que le pr√©-rendu partiel devient stable, nous fournirons un support via l'API des adaptateurs de d√©ploiement.

</AppOnly>

<AppOnly>

## `after`

[`after`](/docs/app/api-reference/functions/after) est enti√®rement pris en charge en auto-h√©bergement avec `next start`.

Lors de l'arr√™t du serveur, assurez un arr√™t gracieux en envoyant les signaux `SIGINT` ou `SIGTERM` et en attendant. Cela permet au serveur Next.js d'attendre que les fonctions de rappel ou promesses en attente utilis√©es dans `after` soient termin√©es.

</AppOnly>

<PagesOnly>

## Arr√™ts gracieux manuels

En auto-h√©bergement, vous pouvez ex√©cuter du code lorsque le serveur s'arr√™te sur les signaux `SIGTERM` ou `SIGINT`.

Vous pouvez d√©finir la variable d'environnement `NEXT_MANUAL_SIG_HANDLE` √† `true` puis enregistrer un gestionnaire pour ce signal dans votre fichier `_document.js`. Vous devrez enregistrer la variable d'environnement directement dans le script `package.json`, et non dans le fichier `.env`.

> **Bon √† savoir** : La gestion manuelle des signaux n'est pas disponible dans `next dev`.

```json filename="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js filename="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Re√ßu SIGTERM : nettoyage')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Re√ßu SIGINT : nettoyage')
    process.exit(0)
  })
}
```

</PagesOnly>