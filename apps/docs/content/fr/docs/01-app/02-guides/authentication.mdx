---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:53:54.550Z
title: Comment impl√©menter l'authentification dans Next.js
nav_title: Authentification
description: Apprenez √† impl√©menter l'authentification dans votre application Next.js.
---

Comprendre l'authentification est crucial pour prot√©ger les donn√©es de votre application. Cette page vous guidera sur les fonctionnalit√©s de React et Next.js √† utiliser pour impl√©menter l'authentification.

Avant de commencer, il est utile de d√©composer le processus en trois concepts :

1. **[Authentification](#authentication)** : V√©rifie si l'utilisateur est bien celui qu'il pr√©tend √™tre. Cela n√©cessite que l'utilisateur prouve son identit√© avec quelque chose qu'il conna√Æt, comme un nom d'utilisateur et un mot de passe.
2. **[Gestion de session](#session-management)** : Suit l'√©tat d'authentification de l'utilisateur entre les requ√™tes.
3. **[Autorisation](#authorization)** : D√©termine quelles routes et donn√©es l'utilisateur peut acc√©der.

Ce diagramme montre le flux d'authentification utilisant les fonctionnalit√©s de React et Next.js :

<Image
  alt="Diagramme montrant le flux d'authentification avec les fonctionnalit√©s React et Next.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

Les exemples de cette page pr√©sentent une authentification basique avec nom d'utilisateur et mot de passe √† des fins √©ducatives. Bien que vous puissiez impl√©menter une solution d'authentification personnalis√©e, pour une meilleure s√©curit√© et simplicit√©, nous recommandons d'utiliser une biblioth√®que d'authentification. Celles-ci offrent des solutions int√©gr√©es pour l'authentification, la gestion de session et l'autorisation, ainsi que des fonctionnalit√©s suppl√©mentaires comme les connexions sociales, l'authentification multi-facteurs et le contr√¥le d'acc√®s bas√© sur les r√¥les. Vous trouverez une liste dans la section [Biblioth√®ques d'authentification](#auth-libraries).

## Authentification

<AppOnly>

### Fonctionnalit√© d'inscription et de connexion

Vous pouvez utiliser l'√©l√©ment [`<form>`](https://react.dev/reference/react-dom/components/form) avec les [Actions Serveur](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) de React et `useActionState` pour capturer les identifiants utilisateur, valider les champs du formulaire et appeler l'API ou la base de donn√©es de votre fournisseur d'authentification.

Comme les Actions Serveur s'ex√©cutent toujours sur le serveur, elles fournissent un environnement s√©curis√© pour g√©rer la logique d'authentification.

Voici les √©tapes pour impl√©menter la fonctionnalit√© d'inscription/connexion :

#### 1. Capturer les identifiants utilisateur

Pour capturer les identifiants utilisateur, cr√©ez un formulaire qui invoque une Action Serveur lors de la soumission. Par exemple, un formulaire d'inscription qui accepte le nom, l'email et le mot de passe de l'utilisateur :

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">S'inscrire</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">S'inscrire</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. Valider les champs du formulaire c√¥t√© serveur

Utilisez l'Action Serveur pour valider les champs du formulaire c√¥t√© serveur. Si votre fournisseur d'authentification ne fournit pas de validation de formulaire, vous pouvez utiliser une biblioth√®que de validation de sch√©ma comme [Zod](https://zod.dev/) ou [Yup](https://github.com/jquense/yup).

En utilisant Zod comme exemple, vous pouvez d√©finir un sch√©ma de formulaire avec des messages d'erreur appropri√©s :

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Le nom doit contenir au moins 2 caract√®res.' })
    .trim(),
  email: z.string().email({ message: 'Veuillez entrer un email valide.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Doit contenir au moins 8 caract√®res' })
    .regex(/[a-zA-Z]/, { message: 'Doit contenir au moins une lettre.' })
    .regex(/[0-9]/, { message: 'Doit contenir au moins un chiffre.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Doit contenir au moins un caract√®re sp√©cial.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Le nom doit contenir au moins 2 caract√®res.' })
    .trim(),
  email: z.string().email({ message: 'Veuillez entrer un email valide.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Doit contenir au moins 8 caract√®res' })
    .regex(/[a-zA-Z]/, { message: 'Doit contenir au moins une lettre.' })
    .regex(/[0-9]/, { message: 'Doit contenir au moins un chiffre.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Doit contenir au moins un caract√®re sp√©cial.',
    })
    .trim(),
})
```

Pour √©viter des appels inutiles √† l'API ou la base de donn√©es de votre fournisseur d'authentification, vous pouvez `return` pr√©matur√©ment dans l'Action Serveur si des champs du formulaire ne correspondent pas au sch√©ma d√©fini.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Valider les champs du formulaire
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si des champs sont invalides, retourner pr√©matur√©ment
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Appeler le fournisseur ou la base de donn√©es pour cr√©er un utilisateur...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Valider les champs du formulaire
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si des champs sont invalides, retourner pr√©matur√©ment
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Appeler le fournisseur ou la base de donn√©es pour cr√©er un utilisateur...
}
```

De retour dans votre `<SignupForm />`, vous pouvez utiliser le hook `useActionState` de React pour afficher les erreurs de validation pendant la soumission du formulaire :

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Le mot de passe doit :</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        S'inscrire
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Le mot de passe doit :</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        S'inscrire
      </button>
    </form>
  )
}
```

> **Bon √† savoir :**
>
> - Dans React 19, `useFormStatus` inclut des cl√©s suppl√©mentaires sur l'objet retourn√©, comme data, method et action. Si vous n'utilisez pas React 19, seule la cl√© `pending` est disponible.
> - Avant de muter des donn√©es, vous devriez toujours v√©rifier qu'un utilisateur est √©galement autoris√© √† effectuer l'action. Voir [Authentification et Autorisation](#authorization).

#### 3. Cr√©er un utilisateur ou v√©rifier ses identifiants

Apr√®s avoir valid√© les champs du formulaire, vous pouvez cr√©er un nouveau compte utilisateur ou v√©rifier son existence en appelant l'API ou la base de donn√©es de votre fournisseur d'authentification.

En reprenant l'exemple pr√©c√©dent :

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Valider les champs du formulaire
  // ...

  // 2. Pr√©parer les donn√©es pour l'insertion en base de donn√©es
  const { name, email, password } = validatedFields.data
  // Par exemple, hacher le mot de passe avant de le stocker
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Ins√©rer l'utilisateur dans la base de donn√©es ou appeler l'API d'une biblioth√®que d'authentification
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Une erreur est survenue lors de la cr√©ation de votre compte.',
    }
  }

  // TODO :
  // 4. Cr√©er une session utilisateur
  // 5. Rediriger l'utilisateur
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Valider les champs du formulaire
  // ...

  // 2. Pr√©parer les donn√©es pour l'insertion en base de donn√©es
  const { name, email, password } = validatedFields.data
  // Par exemple, hacher le mot de passe avant de le stocker
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Ins√©rer l'utilisateur dans la base de donn√©es ou appeler une API de biblioth√®que
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Une erreur est survenue lors de la cr√©ation de votre compte.',
    }
  }

  // TODO :
  // 4. Cr√©er une session utilisateur
  // 5. Rediriger l'utilisateur
}
```

Apr√®s avoir cr√©√© avec succ√®s le compte utilisateur ou v√©rifi√© ses identifiants, vous pouvez cr√©er une session pour g√©rer son √©tat d'authentification. Selon votre strat√©gie de gestion de session, celle-ci peut √™tre stock√©e dans un cookie, une base de donn√©es, ou les deux. Poursuivez avec la section [Gestion des sessions](#session-management) pour en savoir plus.

> **Conseils :**
>
> - L'exemple ci-dessus est d√©taill√© car il d√©compose les √©tapes d'authentification √† des fins p√©dagogiques. Cela montre qu'impl√©menter votre propre solution s√©curis√©e peut rapidement devenir complexe. Envisagez d'utiliser une [biblioth√®que d'authentification](#auth-libraries) pour simplifier le processus.
> - Pour am√©liorer l'exp√©rience utilisateur, vous pouvez v√©rifier les emails ou noms d'utilisateur en double plus t√¥t dans le flux d'inscription. Par exemple, pendant que l'utilisateur saisit son nom ou lorsque le champ perd le focus. Cela peut √©viter des soumissions inutiles et fournir un retour imm√©diat. Vous pouvez limiter la fr√©quence de ces v√©rifications avec des biblioth√®ques comme [use-debounce](https://www.npmjs.com/package/use-debounce).

</AppOnly>

<PagesOnly>

Voici les √©tapes pour impl√©menter un formulaire d'inscription et/ou de connexion :

1. L'utilisateur soumet ses identifiants via un formulaire.
2. Le formulaire envoie une requ√™te trait√©e par une route API.
3. Apr√®s v√©rification r√©ussie, le processus se termine, indiquant l'authentification r√©ussie.
4. En cas d'√©chec, un message d'erreur s'affiche.

Prenons un formulaire de connexion o√π les utilisateurs peuvent saisir leurs identifiants :

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // G√©rer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // G√©rer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

Le formulaire ci-dessus a deux champs pour capturer l'email et le mot de passe. √Ä la soumission, il d√©clenche une fonction qui envoie une requ√™te POST √† une route API (`/api/auth/login`).

Vous pouvez ensuite appeler l'API de votre fournisseur d'authentification dans la route API pour g√©rer l'authentification :

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

</PagesOnly>

## Gestion des sessions

La gestion des sessions garantit que l'√©tat authentifi√© de l'utilisateur est conserv√© entre les requ√™tes. Elle implique la cr√©ation, le stockage, le rafra√Æchissement et la suppression des sessions ou jetons.

Il existe deux types de sessions :

1. [**Sans √©tat (Stateless)**](#stateless-sessions) : Les donn√©es de session (ou un jeton) sont stock√©es dans les cookies du navigateur. Le cookie est envoy√© avec chaque requ√™te, permettant de v√©rifier la session c√¥t√© serveur. Cette m√©thode est plus simple mais moins s√©curis√©e si mal impl√©ment√©e.
2. [**Base de donn√©es (Database)**](#database-sessions) : Les donn√©es de session sont stock√©es dans une base de donn√©es, le navigateur ne recevant que l'ID de session chiffr√©. Cette m√©thode est plus s√©curis√©e mais plus complexe et consomme plus de ressources serveur.

> **Bon √† savoir :** Bien que vous puissiez utiliser les deux m√©thodes, nous recommandons d'utiliser une biblioth√®que de gestion de session comme [iron-session](https://github.com/vvo/iron-session) ou [Jose](https://github.com/panva/jose).

### Sessions sans √©tat (Stateless)

<AppOnly>

Pour cr√©er et g√©rer des sessions sans √©tat, suivez ces √©tapes :

1. G√©n√©rez une cl√© secr√®te pour signer votre session et stockez-la comme [variable d'environnement](/docs/app/guides/environment-variables).
2. √âcrivez la logique pour chiffrer/d√©chiffrer les donn√©es de session avec une biblioth√®que de gestion.
3. G√©rez les cookies avec l'API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js.

En plus, envisagez d'ajouter des fonctionnalit√©s pour [mettre √† jour (ou rafra√Æchir)](#updating-or-refreshing-sessions) la session lors du retour de l'utilisateur et [supprimer](#deleting-the-session) la session lors de la d√©connexion.

> **Bon √† savoir :** V√©rifiez si votre [biblioth√®que d'authentification](#auth-libraries) inclut la gestion des sessions.

#### 1. G√©n√©rer une cl√© secr√®te

Il existe plusieurs fa√ßons de g√©n√©rer une cl√© secr√®te. Par exemple, avec la commande `openssl` :

```bash filename="terminal"
openssl rand -base64 32
```

Cette commande g√©n√®re une cha√Æne al√©atoire de 32 caract√®res que vous pouvez utiliser comme cl√© secr√®te et stocker dans votre [fichier de variables d'environnement](/docs/app/guides/environment-variables) :

```bash filename=".env"
SESSION_SECRET=votre_cl√©_secr√®te
```

Vous pouvez ensuite r√©f√©rencer cette cl√© dans votre logique de gestion :

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Chiffrer et d√©chiffrer les sessions

Utilisez votre [biblioth√®que de gestion](#session-management-libraries) pr√©f√©r√©e pour chiffrer et d√©chiffrer les sessions. Continuons avec [Jose](https://www.npmjs.com/package/jose) (compatible avec [Edge Runtime](/docs/app/api-reference/edge)) et le package [`server-only`](https://www.npmjs.com/package/server-only) de React pour ex√©cuter la logique uniquement c√¥t√© serveur.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('√âchec de la v√©rification de la session')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('√âchec de la v√©rification de la session')
  }
}
```

> **Conseils :**
>
> - Le payload doit contenir le **minimum** de donn√©es uniques utilis√©es dans les requ√™tes suivantes, comme l'ID ou le r√¥le de l'utilisateur. √âvitez les informations personnelles ou sensibles comme les mots de passe.

#### 3. D√©finir les cookies (options recommand√©es)

Pour stocker la session dans un cookie, utilisez l'API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js avec ces options recommand√©es :

- **HttpOnly** : Emp√™che l'acc√®s au cookie via JavaScript c√¥t√© client.
- **Secure** : Utilise https pour envoyer le cookie.
- **SameSite** : D√©finit si le cookie peut √™tre envoy√© avec des requ√™tes cross-site.
- **Max-Age ou Expires** : Supprime le cookie apr√®s un certain temps.
- **Path** : D√©finit le chemin URL du cookie.

Consultez [MDN](https://developer.mozilla.org/fr/docs/Web/HTTP/Cookies) pour plus d'informations.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

Dans votre Server Action, invoquez `createSession()` et utilisez [`redirect()`](/docs/app/guides/redirecting) pour rediriger l'utilisateur :

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // √âtapes pr√©c√©dentes :
  // 1. Valider les champs
  // 2. Pr√©parer les donn√©es
  // 3. Ins√©rer l'utilisateur

  // √âtapes actuelles :
  // 4. Cr√©er la session
  await createSession(user.id)
  // 5. Rediriger
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // √âtapes pr√©c√©dentes :
  // 1. Valider les champs
  // 2. Pr√©parer les donn√©es
  // 3. Ins√©rer l'utilisateur

  // √âtapes actuelles :
  // 4. Cr√©er la session
  await createSession(user.id)
  // 5. Rediriger
  redirect('/profile')
}
```

> **Conseils :**
>
> - **Les cookies doivent √™tre d√©finis c√¥t√© serveur** pour √©viter la falsification c√¥t√© client.
> - üé• Regardez : En savoir plus sur les sessions sans √©tat avec Next.js ‚Üí [YouTube (11 minutes)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### Mettre √† jour (ou rafra√Æchir) les sessions

Vous pouvez prolonger la dur√©e de validit√© de la session. Utile pour maintenir la connexion apr√®s un retour sur l'application :

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Conseil :** V√©rifiez si votre biblioth√®que d'authentification prend en charge les jetons de rafra√Æchissement pour prolonger les sessions.

#### Suppression de la session

Pour supprimer la session, vous pouvez supprimer le cookie :

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

Vous pouvez ensuite r√©utiliser la fonction `deleteSession()` dans votre application, par exemple lors de la d√©connexion :

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### D√©finition et suppression des cookies

Vous pouvez utiliser les [Routes API](/docs/pages/building-your-application/routing/api-routes) pour d√©finir la session comme un cookie sur le serveur :

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie d√©fini avec succ√®s !' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie d√©fini avec succ√®s !' })
}
```

</PagesOnly>

### Sessions de base de donn√©es

Pour cr√©er et g√©rer des sessions de base de donn√©es, vous devrez suivre ces √©tapes :

1. Cr√©ez une table dans votre base de donn√©es pour stocker les sessions et les donn√©es (ou v√©rifiez si votre biblioth√®que d'authentification s'en charge).
2. Impl√©mentez des fonctionnalit√©s pour ins√©rer, mettre √† jour et supprimer des sessions.
3. Chiffrez l'ID de session avant de le stocker dans le navigateur de l'utilisateur, et assurez-vous que la base de donn√©es et le cookie restent synchronis√©s (ceci est facultatif, mais recommand√© pour les v√©rifications optimistes d'authentification dans le [Middleware](#v√©rifications-optimistes-avec-le-middleware-facultatif)).

<AppOnly>

Par exemple :

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Cr√©ez une session dans la base de donn√©es
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Retournez l'ID de session
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Chiffrez l'ID de session
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Stockez la session dans les cookies pour des v√©rifications optimistes d'authentification
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Cr√©ez une session dans la base de donn√©es
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Retournez l'ID de session
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Chiffrez l'ID de session
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Stockez la session dans les cookies pour des v√©rifications optimistes d'authentification
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Conseils** :
>
> - Pour un acc√®s plus rapide, vous pouvez envisager d'ajouter une mise en cache c√¥t√© serveur pour la dur√©e de vie de la session. Vous pouvez √©galement conserver les donn√©es de session dans votre base de donn√©es principale et combiner les requ√™tes de donn√©es pour r√©duire le nombre de requ√™tes.
> - Vous pouvez choisir d'utiliser des sessions de base de donn√©es pour des cas d'utilisation plus avanc√©s, comme suivre la derni√®re fois qu'un utilisateur s'est connect√©, le nombre d'appareils actifs, ou donner aux utilisateurs la possibilit√© de se d√©connecter de tous les appareils.

Apr√®s avoir impl√©ment√© la gestion des sessions, vous devrez ajouter une logique d'autorisation pour contr√¥ler ce que les utilisateurs peuvent acc√©der et faire dans votre application. Passez √† la section [Autorisation](#autorisation) pour en savoir plus.

</AppOnly>

<PagesOnly>

**Cr√©ation d'une session sur le serveur** :

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

</PagesOnly>

## Autorisation

Une fois qu'un utilisateur est authentifi√© et qu'une session est cr√©√©e, vous pouvez impl√©menter l'autorisation pour contr√¥ler ce que l'utilisateur peut acc√©der et faire dans votre application.

Il existe deux principaux types de v√©rifications d'autorisation :

1. **Optimiste** : V√©rifie si l'utilisateur est autoris√© √† acc√©der √† une route ou √† effectuer une action en utilisant les donn√©es de session stock√©es dans le cookie. Ces v√©rifications sont utiles pour des op√©rations rapides, comme afficher/masquer des √©l√©ments d'interface ou rediriger les utilisateurs en fonction des permissions ou r√¥les.
2. **S√©curis√©e** : V√©rifie si l'utilisateur est autoris√© √† acc√©der √† une route ou √† effectuer une action en utilisant les donn√©es de session stock√©es dans la base de donn√©es. Ces v√©rifications sont plus s√©curis√©es et sont utilis√©es pour des op√©rations n√©cessitant un acc√®s √† des donn√©es sensibles ou des actions.

Pour les deux cas, nous recommandons :

- De cr√©er une [Couche d'Acc√®s aux Donn√©es (CAD)](#cr√©ation-dune-couche-dacc√®s-aux-donn√©es-cad) pour centraliser votre logique d'autorisation.
- D'utiliser des [Objets de Transfert de Donn√©es (OTD)](#utilisation-dobjets-de-transfert-de-donn√©es-otd) pour ne retourner que les donn√©es n√©cessaires.
- D'utiliser optionnellement le [Middleware](#v√©rifications-optimistes-avec-le-middleware-facultatif) pour effectuer des v√©rifications optimistes.

### V√©rifications optimistes avec le Middleware (Facultatif)

Il existe certains cas o√π vous pouvez vouloir utiliser le [Middleware](/docs/app/building-your-application/routing/middleware) et rediriger les utilisateurs en fonction des permissions :

- Pour effectuer des v√©rifications optimistes. Comme le Middleware s'ex√©cute sur chaque route, c'est un bon moyen de centraliser la logique de redirection et de pr√©-filtrer les utilisateurs non autoris√©s.
- Pour prot√©ger des routes statiques qui partagent des donn√©es entre utilisateurs (par exemple, du contenu derri√®re un paywall).

Cependant, comme le Middleware s'ex√©cute sur chaque route, y compris les routes [pr√©charg√©es](/docs/app/getting-started/linking-and-navigating#prefetching), il est important de ne lire la session que depuis le cookie (v√©rifications optimistes), et d'√©viter les v√©rifications en base de donn√©es pour pr√©venir les probl√®mes de performance.

Par exemple :

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Sp√©cifiez les routes prot√©g√©es et publiques
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. V√©rifiez si la route actuelle est prot√©g√©e ou publique
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. D√©chiffrez la session depuis le cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Redirigez vers /login si l'utilisateur n'est pas authentifi√©
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Redirigez vers /dashboard si l'utilisateur est authentifi√©
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes sur lesquelles le Middleware ne doit pas s'ex√©cuter
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Sp√©cifiez les routes prot√©g√©es et publiques
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. V√©rifiez si la route actuelle est prot√©g√©e ou publique
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. D√©chiffrez la session depuis le cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Redirigez vers /login si l'utilisateur n'est pas authentifi√©
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Redirigez vers /dashboard si l'utilisateur est authentifi√©
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes sur lesquelles le Middleware ne doit pas s'ex√©cuter
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Bien que le Middleware puisse √™tre utile pour des v√©rifications initiales, il ne devrait pas √™tre votre seule ligne de d√©fense pour prot√©ger vos donn√©es. La majorit√© des v√©rifications de s√©curit√© devraient √™tre effectu√©es aussi pr√®s que possible de votre source de donn√©es, voir [Couche d'Acc√®s aux Donn√©es](#cr√©ation-dune-couche-dacc√®s-aux-donn√©es-cad) pour plus d'informations.

> **Conseils** :
>
> - Dans le Middleware, vous pouvez √©galement lire les cookies en utilisant `req.cookies.get('session').value`.
> - Le Middleware utilise le [Edge Runtime](/docs/app/api-reference/edge), v√©rifiez si votre biblioth√®que d'authentification et votre biblioth√®que de gestion de session sont compatibles.
> - Vous pouvez utiliser la propri√©t√© `matcher` dans le Middleware pour sp√©cifier sur quelles routes le Middleware doit s'ex√©cuter. Cependant, pour l'authentification, il est recommand√© que le Middleware s'ex√©cute sur toutes les routes.

<AppOnly>

### Cr√©ation d'une Couche d'Acc√®s aux Donn√©es (CAD)

Nous recommandons de cr√©er une CAD pour centraliser vos requ√™tes de donn√©es et votre logique d'autorisation.

La CAD devrait inclure une fonction qui v√©rifie la session de l'utilisateur lorsqu'il interagit avec votre application. Au minimum, la fonction devrait v√©rifier si la session est valide, puis rediriger ou retourner les informations utilisateur n√©cessaires pour effectuer d'autres requ√™tes.

Par exemple, cr√©ez un fichier s√©par√© pour votre CAD qui inclut une fonction `verifySession()`. Ensuite, utilisez l'API [cache](https://react.dev/reference/react/cache) de React pour m√©mo√Øser la valeur de retour de la fonction pendant un rendu React :

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

Vous pouvez ensuite invoquer la fonction `verifySession()` dans vos requ√™tes de donn√©es, Actions Serveur, ou Gestionnaires de Route :

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Retournez explicitement les colonnes dont vous avez besoin plut√¥t que l'objet utilisateur entier
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('√âchec de la r√©cup√©ration de l\'utilisateur')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Retournez explicitement les colonnes dont vous avez besoin plut√¥t que l'objet utilisateur entier
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('√âchec de la r√©cup√©ration de l\'utilisateur')
    return null
  }
})
```

> **Conseil** :
>
> - Une CAD peut √™tre utilis√©e pour prot√©ger les donn√©es r√©cup√©r√©es au moment de la requ√™te. Cependant, pour les routes statiques qui partagent des donn√©es entre utilisateurs, les donn√©es seront r√©cup√©r√©es au moment de la construction et non au moment de la requ√™te. Utilisez le [Middleware](#v√©rifications-optimistes-avec-le-middleware-facultatif) pour prot√©ger les routes statiques.
> - Pour des v√©rifications s√©curis√©es, vous pouvez v√©rifier si la session est valide en comparant l'ID de session avec votre base de donn√©es. Utilisez la fonction [cache](https://react.dev/reference/react/cache) de React pour √©viter des requ√™tes en double inutiles vers la base de donn√©es pendant un rendu.
> - Vous pouvez souhaiter consolider les requ√™tes de donn√©es li√©es dans une classe JavaScript qui ex√©cute `verifySession()` avant toute m√©thode.

### Utilisation des objets de transfert de donn√©es (DTO)

Lors de la r√©cup√©ration de donn√©es, il est recommand√© de ne retourner que les donn√©es n√©cessaires √† votre application, plut√¥t que des objets entiers. Par exemple, si vous r√©cup√©rez des donn√©es utilisateur, vous pourriez ne retourner que l'ID et le nom de l'utilisateur, plut√¥t que l'objet utilisateur complet qui pourrait contenir des mots de passe, num√©ros de t√©l√©phone, etc.

Cependant, si vous ne contr√¥lez pas la structure des donn√©es retourn√©es, ou si vous travaillez en √©quipe et souhaitez √©viter que des objets entiers soient transmis au client, vous pouvez utiliser des strat√©gies telles que la sp√©cification des champs qui peuvent √™tre expos√©s en toute s√©curit√© au client.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Retourner des colonnes sp√©cifiques ici
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Ou retourner uniquement ce qui est sp√©cifique √† la requ√™te ici
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Retourner des colonnes sp√©cifiques ici
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Ou retourner uniquement ce qui est sp√©cifique √† la requ√™te ici
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

En centralisant vos requ√™tes de donn√©es et votre logique d'autorisation dans une couche d'acc√®s aux donn√©es (DAL) et en utilisant des DTO, vous pouvez garantir que toutes les requ√™tes de donn√©es sont s√©curis√©es et coh√©rentes, ce qui facilite la maintenance, l'audit et le d√©bogage √† mesure que votre application √©volue.

> **Bon √† savoir** :
>
> - Il existe plusieurs fa√ßons de d√©finir un DTO, qu'il s'agisse d'utiliser `toJSON()`, des fonctions individuelles comme dans l'exemple ci-dessus, ou des classes JavaScript. Comme il s'agit de mod√®les JavaScript et non d'une fonctionnalit√© de React ou Next.js, nous vous recommandons de faire des recherches pour trouver le mod√®le le plus adapt√© √† votre application.
> - Pour en savoir plus sur les bonnes pratiques en mati√®re de s√©curit√©, consultez notre [article sur la s√©curit√© dans Next.js](/blog/security-nextjs-server-components-actions).

### Composants serveur

Les v√©rifications d'authentification dans les [composants serveur](/docs/app/getting-started/server-and-client-components) sont utiles pour un acc√®s bas√© sur les r√¥les. Par exemple, pour afficher conditionnellement des composants en fonction du r√¥le de l'utilisateur :

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // En supposant que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // En supposant que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

Dans cet exemple, nous utilisons la fonction `verifySession()` de notre DAL pour v√©rifier les r√¥les 'admin', 'user' et non autoris√©s. Ce mod√®le garantit que chaque utilisateur interagit uniquement avec les composants appropri√©s √† son r√¥le.

### Layouts et v√©rifications d'authentification

En raison du [rendu partiel](/docs/app/getting-started/linking-and-navigating#client-side-transitions), soyez prudent lorsque vous effectuez des v√©rifications dans les [layouts](/docs/app/api-reference/file-conventions/layout), car ceux-ci ne se rechargent pas lors de la navigation, ce qui signifie que la session utilisateur ne sera pas v√©rifi√©e √† chaque changement de route.

√Ä la place, vous devriez effectuer les v√©rifications pr√®s de votre source de donn√©es ou du composant qui sera affich√© conditionnellement.

Par exemple, consid√©rez un layout partag√© qui r√©cup√®re les donn√©es utilisateur et affiche l'image de l'utilisateur dans une navigation. Au lieu d'effectuer la v√©rification d'authentification dans le layout, vous devriez r√©cup√©rer les donn√©es utilisateur (`getUser()`) dans le layout et effectuer la v√©rification d'authentification dans votre DAL.

Cela garantit que partout o√π `getUser()` est appel√© dans votre application, la v√©rification d'authentification est effectu√©e, et emp√™che les d√©veloppeurs d'oublier de v√©rifier que l'utilisateur est autoris√© √† acc√©der aux donn√©es.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // R√©cup√©rer l'ID utilisateur depuis la session et r√©cup√©rer les donn√©es
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // R√©cup√©rer l'ID utilisateur depuis la session et r√©cup√©rer les donn√©es
})
```

> **Bon √† savoir :**
>
> - Un mod√®le courant dans les SPA consiste √† `return null` dans un layout ou un composant de haut niveau si un utilisateur n'est pas autoris√©. Ce mod√®le n'est **pas recommand√©** car les applications Next.js ont plusieurs points d'entr√©e, ce qui n'emp√™chera pas les segments de route imbriqu√©s et les actions serveur d'√™tre accessibles.

### Actions serveur

Traitez les [actions serveur](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) avec les m√™mes consid√©rations de s√©curit√© que les points d'API publics, et v√©rifiez si l'utilisateur est autoris√© √† effectuer une mutation.

Dans l'exemple ci-dessous, nous v√©rifions le r√¥le de l'utilisateur avant d'autoriser l'action √† continuer :

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Retourner pr√©matur√©ment si l'utilisateur n'est pas autoris√© √† effectuer l'action
  if (userRole !== 'admin') {
    return null
  }

  // Poursuivre l'action pour les utilisateurs autoris√©s
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Retourner pr√©matur√©ment si l'utilisateur n'est pas autoris√© √† effectuer l'action
  if (userRole !== 'admin') {
    return null
  }

  // Poursuivre l'action pour les utilisateurs autoris√©s
}
```

### Gestionnaires de route

Traitez les [gestionnaires de route](/docs/app/building-your-application/routing/route-handlers) avec les m√™mes consid√©rations de s√©curit√© que les points d'API publics, et v√©rifiez si l'utilisateur est autoris√© √† acc√©der au gestionnaire de route.

Par exemple :

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Authentification utilisateur et v√©rification du r√¥le
  const session = await verifySession()

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    // L'utilisateur n'est pas authentifi√©
    return new Response(null, { status: 401 })
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    // L'utilisateur est authentifi√© mais n'a pas les bonnes permissions
    return new Response(null, { status: 403 })
  }

  // Continuer pour les utilisateurs autoris√©s
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Authentification utilisateur et v√©rification du r√¥le
  const session = await verifySession()

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    // L'utilisateur n'est pas authentifi√©
    return new Response(null, { status: 401 })
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    // L'utilisateur est authentifi√© mais n'a pas les bonnes permissions
    return new Response(null, { status: 403 })
  }

  // Continuer pour les utilisateurs autoris√©s
}
```

L'exemple ci-dessus d√©montre un gestionnaire de route avec une v√©rification de s√©curit√© √† deux niveaux. Il v√©rifie d'abord une session active, puis confirme si l'utilisateur connect√© est un 'admin'.

## Fournisseurs de contexte

L'utilisation de fournisseurs de contexte pour l'authentification fonctionne gr√¢ce √† l'[imbrication](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). Cependant, le `context` de React n'est pas pris en charge dans les composants serveur, ce qui les rend uniquement applicables aux composants client.

Cela fonctionne, mais tout composant serveur enfant sera d'abord rendu c√¥t√© serveur et n'aura pas acc√®s aux donn√©es de session du fournisseur de contexte :

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

Si les donn√©es de session sont n√©cessaires dans les composants client (par exemple pour la r√©cup√©ration de donn√©es c√¥t√© client), utilisez l'API [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) de React pour emp√™cher que des donn√©es de session sensibles ne soient expos√©es au client.

</AppOnly>

<PagesOnly>

### Cr√©ation d'une couche d'acc√®s aux donn√©es (DAL)

#### Protection des routes API

Les routes API dans Next.js sont essentielles pour g√©rer la logique c√¥t√© serveur et la gestion des donn√©es. Il est crucial de s√©curiser ces routes pour s'assurer que seuls les utilisateurs autoris√©s peuvent acc√©der √† des fonctionnalit√©s sp√©cifiques. Cela implique g√©n√©ralement de v√©rifier le statut d'authentification de l'utilisateur et ses permissions bas√©es sur son r√¥le.

Voici un exemple de s√©curisation d'une route API :

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    res.status(401).json({
      error: 'L\'utilisateur n\'est pas authentifi√©',
    })
    return
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acc√®s non autoris√© : L\'utilisateur n\'a pas les privil√®ges d\'admin.',
    })
    return
  }

  // Poursuivre la route pour les utilisateurs autoris√©s
  // ... impl√©mentation de la route API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    res.status(401).json({
      error: 'L\'utilisateur n\'est pas authentifi√©',
    })
    return
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acc√®s non autoris√© : L\'utilisateur n\'a pas les privil√®ges d\'admin.',
    })
    return
  }

  // Poursuivre la route pour les utilisateurs autoris√©s
  // ... impl√©mentation de la route API
}
```

Cet exemple d√©montre une route API avec une v√©rification de s√©curit√© √† deux niveaux pour l'authentification et l'autorisation. Elle v√©rifie d'abord une session active, puis confirme si l'utilisateur connect√© est un 'admin'. Cette approche garantit un acc√®s s√©curis√©, limit√© aux utilisateurs authentifi√©s et autoris√©s, maintenant une s√©curit√© robuste pour le traitement des requ√™tes.

</PagesOnly>

## Ressources

Maintenant que vous avez appris l'authentification dans Next.js, voici des biblioth√®ques compatibles avec Next.js et des ressources pour vous aider √† impl√©menter une authentification et une gestion de session s√©curis√©es :

### Biblioth√®ques d'authentification

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Biblioth√®ques de gestion de session

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Pour aller plus loin

Pour continuer √† apprendre sur l'authentification et la s√©curit√©, consultez les ressources suivantes :

- [Comment penser la s√©curit√© dans Next.js](/blog/security-nextjs-server-components-actions)
- [Comprendre les attaques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Comprendre les attaques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
