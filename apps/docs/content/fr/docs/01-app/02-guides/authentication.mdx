---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:53:54.550Z
title: Comment implémenter l'authentification dans Next.js
nav_title: Authentification
description: Apprenez à implémenter l'authentification dans votre application Next.js.
---

Comprendre l'authentification est crucial pour protéger les données de votre application. Cette page vous guidera sur les fonctionnalités de React et Next.js à utiliser pour implémenter l'authentification.

Avant de commencer, il est utile de décomposer le processus en trois concepts :

1. **[Authentification](#authentication)** : Vérifie si l'utilisateur est bien celui qu'il prétend être. Cela nécessite que l'utilisateur prouve son identité avec quelque chose qu'il connaît, comme un nom d'utilisateur et un mot de passe.
2. **[Gestion de session](#session-management)** : Suit l'état d'authentification de l'utilisateur entre les requêtes.
3. **[Autorisation](#authorization)** : Détermine quelles routes et données l'utilisateur peut accéder.

Ce diagramme montre le flux d'authentification utilisant les fonctionnalités de React et Next.js :

<Image
  alt="Diagramme montrant le flux d'authentification avec les fonctionnalités React et Next.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

Les exemples de cette page présentent une authentification basique avec nom d'utilisateur et mot de passe à des fins éducatives. Bien que vous puissiez implémenter une solution d'authentification personnalisée, pour une meilleure sécurité et simplicité, nous recommandons d'utiliser une bibliothèque d'authentification. Celles-ci offrent des solutions intégrées pour l'authentification, la gestion de session et l'autorisation, ainsi que des fonctionnalités supplémentaires comme les connexions sociales, l'authentification multi-facteurs et le contrôle d'accès basé sur les rôles. Vous trouverez une liste dans la section [Bibliothèques d'authentification](#auth-libraries).

## Authentification

<AppOnly>

### Fonctionnalité d'inscription et de connexion

Vous pouvez utiliser l'élément [`<form>`](https://react.dev/reference/react-dom/components/form) avec les [Actions Serveur](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) de React et `useActionState` pour capturer les identifiants utilisateur, valider les champs du formulaire et appeler l'API ou la base de données de votre fournisseur d'authentification.

Comme les Actions Serveur s'exécutent toujours sur le serveur, elles fournissent un environnement sécurisé pour gérer la logique d'authentification.

Voici les étapes pour implémenter la fonctionnalité d'inscription/connexion :

#### 1. Capturer les identifiants utilisateur

Pour capturer les identifiants utilisateur, créez un formulaire qui invoque une Action Serveur lors de la soumission. Par exemple, un formulaire d'inscription qui accepte le nom, l'email et le mot de passe de l'utilisateur :

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">S'inscrire</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">S'inscrire</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. Valider les champs du formulaire côté serveur

Utilisez l'Action Serveur pour valider les champs du formulaire côté serveur. Si votre fournisseur d'authentification ne fournit pas de validation de formulaire, vous pouvez utiliser une bibliothèque de validation de schéma comme [Zod](https://zod.dev/) ou [Yup](https://github.com/jquense/yup).

En utilisant Zod comme exemple, vous pouvez définir un schéma de formulaire avec des messages d'erreur appropriés :

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Le nom doit contenir au moins 2 caractères.' })
    .trim(),
  email: z.string().email({ message: 'Veuillez entrer un email valide.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Doit contenir au moins 8 caractères' })
    .regex(/[a-zA-Z]/, { message: 'Doit contenir au moins une lettre.' })
    .regex(/[0-9]/, { message: 'Doit contenir au moins un chiffre.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Doit contenir au moins un caractère spécial.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Le nom doit contenir au moins 2 caractères.' })
    .trim(),
  email: z.string().email({ message: 'Veuillez entrer un email valide.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Doit contenir au moins 8 caractères' })
    .regex(/[a-zA-Z]/, { message: 'Doit contenir au moins une lettre.' })
    .regex(/[0-9]/, { message: 'Doit contenir au moins un chiffre.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Doit contenir au moins un caractère spécial.',
    })
    .trim(),
})
```

Pour éviter des appels inutiles à l'API ou la base de données de votre fournisseur d'authentification, vous pouvez `return` prématurément dans l'Action Serveur si des champs du formulaire ne correspondent pas au schéma défini.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Valider les champs du formulaire
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si des champs sont invalides, retourner prématurément
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Appeler le fournisseur ou la base de données pour créer un utilisateur...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Valider les champs du formulaire
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si des champs sont invalides, retourner prématurément
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Appeler le fournisseur ou la base de données pour créer un utilisateur...
}
```

De retour dans votre `<SignupForm />`, vous pouvez utiliser le hook `useActionState` de React pour afficher les erreurs de validation pendant la soumission du formulaire :

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Le mot de passe doit :</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        S'inscrire
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nom</label>
        <input id="name" name="name" placeholder="Nom" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Mot de passe</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Le mot de passe doit :</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        S'inscrire
      </button>
    </form>
  )
}
```

> **Bon à savoir :**
>
> - Dans React 19, `useFormStatus` inclut des clés supplémentaires sur l'objet retourné, comme data, method et action. Si vous n'utilisez pas React 19, seule la clé `pending` est disponible.
> - Avant de muter des données, vous devriez toujours vérifier qu'un utilisateur est également autorisé à effectuer l'action. Voir [Authentification et Autorisation](#authorization).

#### 3. Créer un utilisateur ou vérifier ses identifiants

Après avoir validé les champs du formulaire, vous pouvez créer un nouveau compte utilisateur ou vérifier son existence en appelant l'API ou la base de données de votre fournisseur d'authentification.

En reprenant l'exemple précédent :

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Valider les champs du formulaire
  // ...

  // 2. Préparer les données pour l'insertion en base de données
  const { name, email, password } = validatedFields.data
  // Par exemple, hacher le mot de passe avant de le stocker
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insérer l'utilisateur dans la base de données ou appeler l'API d'une bibliothèque d'authentification
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Une erreur est survenue lors de la création de votre compte.',
    }
  }

  // TODO :
  // 4. Créer une session utilisateur
  // 5. Rediriger l'utilisateur
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Valider les champs du formulaire
  // ...

  // 2. Préparer les données pour l'insertion en base de données
  const { name, email, password } = validatedFields.data
  // Par exemple, hacher le mot de passe avant de le stocker
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insérer l'utilisateur dans la base de données ou appeler une API de bibliothèque
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Une erreur est survenue lors de la création de votre compte.',
    }
  }

  // TODO :
  // 4. Créer une session utilisateur
  // 5. Rediriger l'utilisateur
}
```

Après avoir créé avec succès le compte utilisateur ou vérifié ses identifiants, vous pouvez créer une session pour gérer son état d'authentification. Selon votre stratégie de gestion de session, celle-ci peut être stockée dans un cookie, une base de données, ou les deux. Poursuivez avec la section [Gestion des sessions](#session-management) pour en savoir plus.

> **Conseils :**
>
> - L'exemple ci-dessus est détaillé car il décompose les étapes d'authentification à des fins pédagogiques. Cela montre qu'implémenter votre propre solution sécurisée peut rapidement devenir complexe. Envisagez d'utiliser une [bibliothèque d'authentification](#auth-libraries) pour simplifier le processus.
> - Pour améliorer l'expérience utilisateur, vous pouvez vérifier les emails ou noms d'utilisateur en double plus tôt dans le flux d'inscription. Par exemple, pendant que l'utilisateur saisit son nom ou lorsque le champ perd le focus. Cela peut éviter des soumissions inutiles et fournir un retour immédiat. Vous pouvez limiter la fréquence de ces vérifications avec des bibliothèques comme [use-debounce](https://www.npmjs.com/package/use-debounce).

</AppOnly>

<PagesOnly>

Voici les étapes pour implémenter un formulaire d'inscription et/ou de connexion :

1. L'utilisateur soumet ses identifiants via un formulaire.
2. Le formulaire envoie une requête traitée par une route API.
3. Après vérification réussie, le processus se termine, indiquant l'authentification réussie.
4. En cas d'échec, un message d'erreur s'affiche.

Prenons un formulaire de connexion où les utilisateurs peuvent saisir leurs identifiants :

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Gérer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Gérer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

Le formulaire ci-dessus a deux champs pour capturer l'email et le mot de passe. À la soumission, il déclenche une fonction qui envoie une requête POST à une route API (`/api/auth/login`).

Vous pouvez ensuite appeler l'API de votre fournisseur d'authentification dans la route API pour gérer l'authentification :

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

</PagesOnly>

## Gestion des sessions

La gestion des sessions garantit que l'état authentifié de l'utilisateur est conservé entre les requêtes. Elle implique la création, le stockage, le rafraîchissement et la suppression des sessions ou jetons.

Il existe deux types de sessions :

1. [**Sans état (Stateless)**](#stateless-sessions) : Les données de session (ou un jeton) sont stockées dans les cookies du navigateur. Le cookie est envoyé avec chaque requête, permettant de vérifier la session côté serveur. Cette méthode est plus simple mais moins sécurisée si mal implémentée.
2. [**Base de données (Database)**](#database-sessions) : Les données de session sont stockées dans une base de données, le navigateur ne recevant que l'ID de session chiffré. Cette méthode est plus sécurisée mais plus complexe et consomme plus de ressources serveur.

> **Bon à savoir :** Bien que vous puissiez utiliser les deux méthodes, nous recommandons d'utiliser une bibliothèque de gestion de session comme [iron-session](https://github.com/vvo/iron-session) ou [Jose](https://github.com/panva/jose).

### Sessions sans état (Stateless)

<AppOnly>

Pour créer et gérer des sessions sans état, suivez ces étapes :

1. Générez une clé secrète pour signer votre session et stockez-la comme [variable d'environnement](/docs/app/guides/environment-variables).
2. Écrivez la logique pour chiffrer/déchiffrer les données de session avec une bibliothèque de gestion.
3. Gérez les cookies avec l'API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js.

En plus, envisagez d'ajouter des fonctionnalités pour [mettre à jour (ou rafraîchir)](#updating-or-refreshing-sessions) la session lors du retour de l'utilisateur et [supprimer](#deleting-the-session) la session lors de la déconnexion.

> **Bon à savoir :** Vérifiez si votre [bibliothèque d'authentification](#auth-libraries) inclut la gestion des sessions.

#### 1. Générer une clé secrète

Il existe plusieurs façons de générer une clé secrète. Par exemple, avec la commande `openssl` :

```bash filename="terminal"
openssl rand -base64 32
```

Cette commande génère une chaîne aléatoire de 32 caractères que vous pouvez utiliser comme clé secrète et stocker dans votre [fichier de variables d'environnement](/docs/app/guides/environment-variables) :

```bash filename=".env"
SESSION_SECRET=votre_clé_secrète
```

Vous pouvez ensuite référencer cette clé dans votre logique de gestion :

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Chiffrer et déchiffrer les sessions

Utilisez votre [bibliothèque de gestion](#session-management-libraries) préférée pour chiffrer et déchiffrer les sessions. Continuons avec [Jose](https://www.npmjs.com/package/jose) (compatible avec [Edge Runtime](/docs/app/api-reference/edge)) et le package [`server-only`](https://www.npmjs.com/package/server-only) de React pour exécuter la logique uniquement côté serveur.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Échec de la vérification de la session')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Échec de la vérification de la session')
  }
}
```

> **Conseils :**
>
> - Le payload doit contenir le **minimum** de données uniques utilisées dans les requêtes suivantes, comme l'ID ou le rôle de l'utilisateur. Évitez les informations personnelles ou sensibles comme les mots de passe.

#### 3. Définir les cookies (options recommandées)

Pour stocker la session dans un cookie, utilisez l'API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js avec ces options recommandées :

- **HttpOnly** : Empêche l'accès au cookie via JavaScript côté client.
- **Secure** : Utilise https pour envoyer le cookie.
- **SameSite** : Définit si le cookie peut être envoyé avec des requêtes cross-site.
- **Max-Age ou Expires** : Supprime le cookie après un certain temps.
- **Path** : Définit le chemin URL du cookie.

Consultez [MDN](https://developer.mozilla.org/fr/docs/Web/HTTP/Cookies) pour plus d'informations.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

Dans votre Server Action, invoquez `createSession()` et utilisez [`redirect()`](/docs/app/guides/redirecting) pour rediriger l'utilisateur :

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // Étapes précédentes :
  // 1. Valider les champs
  // 2. Préparer les données
  // 3. Insérer l'utilisateur

  // Étapes actuelles :
  // 4. Créer la session
  await createSession(user.id)
  // 5. Rediriger
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // Étapes précédentes :
  // 1. Valider les champs
  // 2. Préparer les données
  // 3. Insérer l'utilisateur

  // Étapes actuelles :
  // 4. Créer la session
  await createSession(user.id)
  // 5. Rediriger
  redirect('/profile')
}
```

> **Conseils :**
>
> - **Les cookies doivent être définis côté serveur** pour éviter la falsification côté client.
> - 🎥 Regardez : En savoir plus sur les sessions sans état avec Next.js → [YouTube (11 minutes)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### Mettre à jour (ou rafraîchir) les sessions

Vous pouvez prolonger la durée de validité de la session. Utile pour maintenir la connexion après un retour sur l'application :

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Conseil :** Vérifiez si votre bibliothèque d'authentification prend en charge les jetons de rafraîchissement pour prolonger les sessions.

#### Suppression de la session

Pour supprimer la session, vous pouvez supprimer le cookie :

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

Vous pouvez ensuite réutiliser la fonction `deleteSession()` dans votre application, par exemple lors de la déconnexion :

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### Définition et suppression des cookies

Vous pouvez utiliser les [Routes API](/docs/pages/building-your-application/routing/api-routes) pour définir la session comme un cookie sur le serveur :

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie défini avec succès !' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie défini avec succès !' })
}
```

</PagesOnly>

### Sessions de base de données

Pour créer et gérer des sessions de base de données, vous devrez suivre ces étapes :

1. Créez une table dans votre base de données pour stocker les sessions et les données (ou vérifiez si votre bibliothèque d'authentification s'en charge).
2. Implémentez des fonctionnalités pour insérer, mettre à jour et supprimer des sessions.
3. Chiffrez l'ID de session avant de le stocker dans le navigateur de l'utilisateur, et assurez-vous que la base de données et le cookie restent synchronisés (ceci est facultatif, mais recommandé pour les vérifications optimistes d'authentification dans le [Middleware](#vérifications-optimistes-avec-le-middleware-facultatif)).

<AppOnly>

Par exemple :

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Créez une session dans la base de données
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Retournez l'ID de session
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Chiffrez l'ID de session
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Stockez la session dans les cookies pour des vérifications optimistes d'authentification
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Créez une session dans la base de données
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Retournez l'ID de session
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Chiffrez l'ID de session
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Stockez la session dans les cookies pour des vérifications optimistes d'authentification
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Conseils** :
>
> - Pour un accès plus rapide, vous pouvez envisager d'ajouter une mise en cache côté serveur pour la durée de vie de la session. Vous pouvez également conserver les données de session dans votre base de données principale et combiner les requêtes de données pour réduire le nombre de requêtes.
> - Vous pouvez choisir d'utiliser des sessions de base de données pour des cas d'utilisation plus avancés, comme suivre la dernière fois qu'un utilisateur s'est connecté, le nombre d'appareils actifs, ou donner aux utilisateurs la possibilité de se déconnecter de tous les appareils.

Après avoir implémenté la gestion des sessions, vous devrez ajouter une logique d'autorisation pour contrôler ce que les utilisateurs peuvent accéder et faire dans votre application. Passez à la section [Autorisation](#autorisation) pour en savoir plus.

</AppOnly>

<PagesOnly>

**Création d'une session sur le serveur** :

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

</PagesOnly>

## Autorisation

Une fois qu'un utilisateur est authentifié et qu'une session est créée, vous pouvez implémenter l'autorisation pour contrôler ce que l'utilisateur peut accéder et faire dans votre application.

Il existe deux principaux types de vérifications d'autorisation :

1. **Optimiste** : Vérifie si l'utilisateur est autorisé à accéder à une route ou à effectuer une action en utilisant les données de session stockées dans le cookie. Ces vérifications sont utiles pour des opérations rapides, comme afficher/masquer des éléments d'interface ou rediriger les utilisateurs en fonction des permissions ou rôles.
2. **Sécurisée** : Vérifie si l'utilisateur est autorisé à accéder à une route ou à effectuer une action en utilisant les données de session stockées dans la base de données. Ces vérifications sont plus sécurisées et sont utilisées pour des opérations nécessitant un accès à des données sensibles ou des actions.

Pour les deux cas, nous recommandons :

- De créer une [Couche d'Accès aux Données (CAD)](#création-dune-couche-daccès-aux-données-cad) pour centraliser votre logique d'autorisation.
- D'utiliser des [Objets de Transfert de Données (OTD)](#utilisation-dobjets-de-transfert-de-données-otd) pour ne retourner que les données nécessaires.
- D'utiliser optionnellement le [Middleware](#vérifications-optimistes-avec-le-middleware-facultatif) pour effectuer des vérifications optimistes.

### Vérifications optimistes avec le Middleware (Facultatif)

Il existe certains cas où vous pouvez vouloir utiliser le [Middleware](/docs/app/building-your-application/routing/middleware) et rediriger les utilisateurs en fonction des permissions :

- Pour effectuer des vérifications optimistes. Comme le Middleware s'exécute sur chaque route, c'est un bon moyen de centraliser la logique de redirection et de pré-filtrer les utilisateurs non autorisés.
- Pour protéger des routes statiques qui partagent des données entre utilisateurs (par exemple, du contenu derrière un paywall).

Cependant, comme le Middleware s'exécute sur chaque route, y compris les routes [préchargées](/docs/app/getting-started/linking-and-navigating#prefetching), il est important de ne lire la session que depuis le cookie (vérifications optimistes), et d'éviter les vérifications en base de données pour prévenir les problèmes de performance.

Par exemple :

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Spécifiez les routes protégées et publiques
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. Vérifiez si la route actuelle est protégée ou publique
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Déchiffrez la session depuis le cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Redirigez vers /login si l'utilisateur n'est pas authentifié
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Redirigez vers /dashboard si l'utilisateur est authentifié
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes sur lesquelles le Middleware ne doit pas s'exécuter
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Spécifiez les routes protégées et publiques
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. Vérifiez si la route actuelle est protégée ou publique
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Déchiffrez la session depuis le cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Redirigez vers /login si l'utilisateur n'est pas authentifié
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Redirigez vers /dashboard si l'utilisateur est authentifié
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Routes sur lesquelles le Middleware ne doit pas s'exécuter
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Bien que le Middleware puisse être utile pour des vérifications initiales, il ne devrait pas être votre seule ligne de défense pour protéger vos données. La majorité des vérifications de sécurité devraient être effectuées aussi près que possible de votre source de données, voir [Couche d'Accès aux Données](#création-dune-couche-daccès-aux-données-cad) pour plus d'informations.

> **Conseils** :
>
> - Dans le Middleware, vous pouvez également lire les cookies en utilisant `req.cookies.get('session').value`.
> - Le Middleware utilise le [Edge Runtime](/docs/app/api-reference/edge), vérifiez si votre bibliothèque d'authentification et votre bibliothèque de gestion de session sont compatibles.
> - Vous pouvez utiliser la propriété `matcher` dans le Middleware pour spécifier sur quelles routes le Middleware doit s'exécuter. Cependant, pour l'authentification, il est recommandé que le Middleware s'exécute sur toutes les routes.

<AppOnly>

### Création d'une Couche d'Accès aux Données (CAD)

Nous recommandons de créer une CAD pour centraliser vos requêtes de données et votre logique d'autorisation.

La CAD devrait inclure une fonction qui vérifie la session de l'utilisateur lorsqu'il interagit avec votre application. Au minimum, la fonction devrait vérifier si la session est valide, puis rediriger ou retourner les informations utilisateur nécessaires pour effectuer d'autres requêtes.

Par exemple, créez un fichier séparé pour votre CAD qui inclut une fonction `verifySession()`. Ensuite, utilisez l'API [cache](https://react.dev/reference/react/cache) de React pour mémoïser la valeur de retour de la fonction pendant un rendu React :

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

Vous pouvez ensuite invoquer la fonction `verifySession()` dans vos requêtes de données, Actions Serveur, ou Gestionnaires de Route :

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Retournez explicitement les colonnes dont vous avez besoin plutôt que l'objet utilisateur entier
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Échec de la récupération de l\'utilisateur')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Retournez explicitement les colonnes dont vous avez besoin plutôt que l'objet utilisateur entier
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Échec de la récupération de l\'utilisateur')
    return null
  }
})
```

> **Conseil** :
>
> - Une CAD peut être utilisée pour protéger les données récupérées au moment de la requête. Cependant, pour les routes statiques qui partagent des données entre utilisateurs, les données seront récupérées au moment de la construction et non au moment de la requête. Utilisez le [Middleware](#vérifications-optimistes-avec-le-middleware-facultatif) pour protéger les routes statiques.
> - Pour des vérifications sécurisées, vous pouvez vérifier si la session est valide en comparant l'ID de session avec votre base de données. Utilisez la fonction [cache](https://react.dev/reference/react/cache) de React pour éviter des requêtes en double inutiles vers la base de données pendant un rendu.
> - Vous pouvez souhaiter consolider les requêtes de données liées dans une classe JavaScript qui exécute `verifySession()` avant toute méthode.

### Utilisation des objets de transfert de données (DTO)

Lors de la récupération de données, il est recommandé de ne retourner que les données nécessaires à votre application, plutôt que des objets entiers. Par exemple, si vous récupérez des données utilisateur, vous pourriez ne retourner que l'ID et le nom de l'utilisateur, plutôt que l'objet utilisateur complet qui pourrait contenir des mots de passe, numéros de téléphone, etc.

Cependant, si vous ne contrôlez pas la structure des données retournées, ou si vous travaillez en équipe et souhaitez éviter que des objets entiers soient transmis au client, vous pouvez utiliser des stratégies telles que la spécification des champs qui peuvent être exposés en toute sécurité au client.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Retourner des colonnes spécifiques ici
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Ou retourner uniquement ce qui est spécifique à la requête ici
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Retourner des colonnes spécifiques ici
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Ou retourner uniquement ce qui est spécifique à la requête ici
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

En centralisant vos requêtes de données et votre logique d'autorisation dans une couche d'accès aux données (DAL) et en utilisant des DTO, vous pouvez garantir que toutes les requêtes de données sont sécurisées et cohérentes, ce qui facilite la maintenance, l'audit et le débogage à mesure que votre application évolue.

> **Bon à savoir** :
>
> - Il existe plusieurs façons de définir un DTO, qu'il s'agisse d'utiliser `toJSON()`, des fonctions individuelles comme dans l'exemple ci-dessus, ou des classes JavaScript. Comme il s'agit de modèles JavaScript et non d'une fonctionnalité de React ou Next.js, nous vous recommandons de faire des recherches pour trouver le modèle le plus adapté à votre application.
> - Pour en savoir plus sur les bonnes pratiques en matière de sécurité, consultez notre [article sur la sécurité dans Next.js](/blog/security-nextjs-server-components-actions).

### Composants serveur

Les vérifications d'authentification dans les [composants serveur](/docs/app/getting-started/server-and-client-components) sont utiles pour un accès basé sur les rôles. Par exemple, pour afficher conditionnellement des composants en fonction du rôle de l'utilisateur :

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // En supposant que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // En supposant que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

Dans cet exemple, nous utilisons la fonction `verifySession()` de notre DAL pour vérifier les rôles 'admin', 'user' et non autorisés. Ce modèle garantit que chaque utilisateur interagit uniquement avec les composants appropriés à son rôle.

### Layouts et vérifications d'authentification

En raison du [rendu partiel](/docs/app/getting-started/linking-and-navigating#client-side-transitions), soyez prudent lorsque vous effectuez des vérifications dans les [layouts](/docs/app/api-reference/file-conventions/layout), car ceux-ci ne se rechargent pas lors de la navigation, ce qui signifie que la session utilisateur ne sera pas vérifiée à chaque changement de route.

À la place, vous devriez effectuer les vérifications près de votre source de données ou du composant qui sera affiché conditionnellement.

Par exemple, considérez un layout partagé qui récupère les données utilisateur et affiche l'image de l'utilisateur dans une navigation. Au lieu d'effectuer la vérification d'authentification dans le layout, vous devriez récupérer les données utilisateur (`getUser()`) dans le layout et effectuer la vérification d'authentification dans votre DAL.

Cela garantit que partout où `getUser()` est appelé dans votre application, la vérification d'authentification est effectuée, et empêche les développeurs d'oublier de vérifier que l'utilisateur est autorisé à accéder aux données.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Récupérer l'ID utilisateur depuis la session et récupérer les données
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Récupérer l'ID utilisateur depuis la session et récupérer les données
})
```

> **Bon à savoir :**
>
> - Un modèle courant dans les SPA consiste à `return null` dans un layout ou un composant de haut niveau si un utilisateur n'est pas autorisé. Ce modèle n'est **pas recommandé** car les applications Next.js ont plusieurs points d'entrée, ce qui n'empêchera pas les segments de route imbriqués et les actions serveur d'être accessibles.

### Actions serveur

Traitez les [actions serveur](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) avec les mêmes considérations de sécurité que les points d'API publics, et vérifiez si l'utilisateur est autorisé à effectuer une mutation.

Dans l'exemple ci-dessous, nous vérifions le rôle de l'utilisateur avant d'autoriser l'action à continuer :

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Retourner prématurément si l'utilisateur n'est pas autorisé à effectuer l'action
  if (userRole !== 'admin') {
    return null
  }

  // Poursuivre l'action pour les utilisateurs autorisés
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Retourner prématurément si l'utilisateur n'est pas autorisé à effectuer l'action
  if (userRole !== 'admin') {
    return null
  }

  // Poursuivre l'action pour les utilisateurs autorisés
}
```

### Gestionnaires de route

Traitez les [gestionnaires de route](/docs/app/building-your-application/routing/route-handlers) avec les mêmes considérations de sécurité que les points d'API publics, et vérifiez si l'utilisateur est autorisé à accéder au gestionnaire de route.

Par exemple :

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Authentification utilisateur et vérification du rôle
  const session = await verifySession()

  // Vérifier si l'utilisateur est authentifié
  if (!session) {
    // L'utilisateur n'est pas authentifié
    return new Response(null, { status: 401 })
  }

  // Vérifier si l'utilisateur a le rôle 'admin'
  if (session.user.role !== 'admin') {
    // L'utilisateur est authentifié mais n'a pas les bonnes permissions
    return new Response(null, { status: 403 })
  }

  // Continuer pour les utilisateurs autorisés
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Authentification utilisateur et vérification du rôle
  const session = await verifySession()

  // Vérifier si l'utilisateur est authentifié
  if (!session) {
    // L'utilisateur n'est pas authentifié
    return new Response(null, { status: 401 })
  }

  // Vérifier si l'utilisateur a le rôle 'admin'
  if (session.user.role !== 'admin') {
    // L'utilisateur est authentifié mais n'a pas les bonnes permissions
    return new Response(null, { status: 403 })
  }

  // Continuer pour les utilisateurs autorisés
}
```

L'exemple ci-dessus démontre un gestionnaire de route avec une vérification de sécurité à deux niveaux. Il vérifie d'abord une session active, puis confirme si l'utilisateur connecté est un 'admin'.

## Fournisseurs de contexte

L'utilisation de fournisseurs de contexte pour l'authentification fonctionne grâce à l'[imbrication](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). Cependant, le `context` de React n'est pas pris en charge dans les composants serveur, ce qui les rend uniquement applicables aux composants client.

Cela fonctionne, mais tout composant serveur enfant sera d'abord rendu côté serveur et n'aura pas accès aux données de session du fournisseur de contexte :

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

Si les données de session sont nécessaires dans les composants client (par exemple pour la récupération de données côté client), utilisez l'API [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) de React pour empêcher que des données de session sensibles ne soient exposées au client.

</AppOnly>

<PagesOnly>

### Création d'une couche d'accès aux données (DAL)

#### Protection des routes API

Les routes API dans Next.js sont essentielles pour gérer la logique côté serveur et la gestion des données. Il est crucial de sécuriser ces routes pour s'assurer que seuls les utilisateurs autorisés peuvent accéder à des fonctionnalités spécifiques. Cela implique généralement de vérifier le statut d'authentification de l'utilisateur et ses permissions basées sur son rôle.

Voici un exemple de sécurisation d'une route API :

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Vérifier si l'utilisateur est authentifié
  if (!session) {
    res.status(401).json({
      error: 'L\'utilisateur n\'est pas authentifié',
    })
    return
  }

  // Vérifier si l'utilisateur a le rôle 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Accès non autorisé : L\'utilisateur n\'a pas les privilèges d\'admin.',
    })
    return
  }

  // Poursuivre la route pour les utilisateurs autorisés
  // ... implémentation de la route API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Vérifier si l'utilisateur est authentifié
  if (!session) {
    res.status(401).json({
      error: 'L\'utilisateur n\'est pas authentifié',
    })
    return
  }

  // Vérifier si l'utilisateur a le rôle 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Accès non autorisé : L\'utilisateur n\'a pas les privilèges d\'admin.',
    })
    return
  }

  // Poursuivre la route pour les utilisateurs autorisés
  // ... implémentation de la route API
}
```

Cet exemple démontre une route API avec une vérification de sécurité à deux niveaux pour l'authentification et l'autorisation. Elle vérifie d'abord une session active, puis confirme si l'utilisateur connecté est un 'admin'. Cette approche garantit un accès sécurisé, limité aux utilisateurs authentifiés et autorisés, maintenant une sécurité robuste pour le traitement des requêtes.

</PagesOnly>

## Ressources

Maintenant que vous avez appris l'authentification dans Next.js, voici des bibliothèques compatibles avec Next.js et des ressources pour vous aider à implémenter une authentification et une gestion de session sécurisées :

### Bibliothèques d'authentification

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Bibliothèques de gestion de session

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Pour aller plus loin

Pour continuer à apprendre sur l'authentification et la sécurité, consultez les ressources suivantes :

- [Comment penser la sécurité dans Next.js](/blog/security-nextjs-server-components-actions)
- [Comprendre les attaques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Comprendre les attaques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
