---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:15:22.444Z
title: Authentification
description: Apprenez √† impl√©menter l'authentification dans Next.js, couvrant les bonnes pratiques, la s√©curisation des routes, les techniques d'autorisation et la gestion des sessions.
---

Pour impl√©menter l'authentification dans Next.js, familiarisez-vous avec trois concepts fondamentaux :

- **[Authentification](#authentication)** : V√©rifie si l'utilisateur est bien celui qu'il pr√©tend √™tre. Cela n√©cessite que l'utilisateur prouve son identit√© avec quelque chose qu'il conna√Æt, comme un nom d'utilisateur et un mot de passe.
- **[Gestion de session](#session-management)** : Suit l'√©tat de l'utilisateur (par exemple connect√©) √† travers plusieurs requ√™tes.
- **[Autorisation](#authorization)** : D√©termine quelles parties de l'application l'utilisateur est autoris√© √† acc√©der.

Cette page d√©montre comment utiliser les fonctionnalit√©s de Next.js pour impl√©menter des mod√®les courants d'authentification, d'autorisation et de gestion de session, afin que vous puissiez choisir les meilleures solutions en fonction des besoins de votre application.

## Authentification

L'authentification v√©rifie l'identit√© d'un utilisateur. Cela se produit lorsqu'un utilisateur se connecte, soit avec un nom d'utilisateur et un mot de passe, soit via un service comme Google. Il s'agit de confirmer que les utilisateurs sont bien ceux qu'ils pr√©tendent √™tre, prot√©geant ainsi les donn√©es de l'utilisateur et l'application contre les acc√®s non autoris√©s ou les activit√©s frauduleuses.

### Strat√©gies d'authentification

Les applications web modernes utilisent couramment plusieurs strat√©gies d'authentification :

1. **OAuth/OpenID Connect (OIDC)** : Permettent un acc√®s par des tiers sans partager les identifiants de l'utilisateur. Id√©al pour les connexions via les r√©seaux sociaux et les solutions de Single Sign-On (SSO). Ils ajoutent une couche d'identit√© avec OpenID Connect.
2. **Connexion par identifiants (Email + Mot de passe)** : Un choix standard pour les applications web, o√π les utilisateurs se connectent avec un email et un mot de passe. Familier et facile √† impl√©menter, il n√©cessite des mesures de s√©curit√© robustes contre les menaces comme le phishing.
3. **Authentification sans mot de passe/par jeton** : Utilise des liens magiques par email ou des codes √† usage unique par SMS pour un acc√®s s√©curis√© sans mot de passe. Populaire pour sa commodit√© et sa s√©curit√© renforc√©e, cette m√©thode aide √† r√©duire la fatigue des mots de passe. Sa limitation est la d√©pendance √† la disponibilit√© de l'email ou du t√©l√©phone de l'utilisateur.
4. **Cl√©s d'acc√®s/WebAuthn** : Utilisent des identifiants cryptographiques uniques pour chaque site, offrant une haute s√©curit√© contre le phishing. S√©curis√© mais nouveau, cette strat√©gie peut √™tre difficile √† impl√©menter.

Le choix d'une strat√©gie d'authentification doit correspondre aux besoins sp√©cifiques de votre application, aux consid√©rations d'interface utilisateur et aux objectifs de s√©curit√©.

### Impl√©mentation de l'authentification

Dans cette section, nous explorerons le processus d'ajout d'une authentification de base par email et mot de passe √† une application web. Bien que cette m√©thode fournisse un niveau de s√©curit√© fondamental, il vaut la peine d'envisager des options plus avanc√©es comme OAuth ou les connexions sans mot de passe pour une protection renforc√©e contre les menaces de s√©curit√© courantes. Le flux d'authentification que nous allons discuter est le suivant :

<PagesOnly>

1. L'utilisateur soumet ses identifiants via un formulaire de connexion.
2. Le formulaire envoie une requ√™te qui est trait√©e par une route API.
3. Apr√®s une v√©rification r√©ussie, le processus est termin√©, indiquant que l'authentification de l'utilisateur a r√©ussi.
4. Si la v√©rification √©choue, un message d'erreur est affich√©.

Consid√©rez un formulaire de connexion o√π les utilisateurs peuvent entrer leurs identifiants :

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // G√©rer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // G√©rer les erreurs
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

Le formulaire ci-dessus a deux champs de saisie pour capturer l'email et le mot de passe de l'utilisateur. Lors de la soumission, il d√©clenche une fonction qui envoie une requ√™te POST √† une route API (`/api/auth/login`).

Vous pouvez ensuite appeler l'API de votre fournisseur d'authentification dans la route API pour g√©rer l'authentification :

```ts filename="pages/api/auth/login.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Identifiants invalides.' })
    } else {
      res.status(500).json({ error: 'Une erreur est survenue.' })
    }
  }
}
```

</PagesOnly>

<AppOnly>

1. L'utilisateur soumet ses identifiants via un formulaire de connexion.
2. Le formulaire appelle une Server Action.
3. Apr√®s une v√©rification r√©ussie, le processus est termin√©, indiquant que l'authentification de l'utilisateur a r√©ussi.
4. Si la v√©rification √©choue, un message d'erreur est affich√©.

Consid√©rez un formulaire de connexion o√π les utilisateurs peuvent entrer leurs identifiants :

```tsx filename="app/login/page.tsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <button type="submit">Se connecter</button>
    </form>
  )
}
```

Le formulaire ci-dessus a deux champs de saisie pour capturer l'email et le mot de passe de l'utilisateur. Lors de la soumission, il appelle la Server Action `authenticate`.

Vous pouvez ensuite appeler l'API de votre fournisseur d'authentification dans la Server Action pour g√©rer l'authentification :

```ts filename="app/lib/actions.ts" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState: unknown, formData: FormData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Identifiants invalides.'
        default:
          return 'Une erreur est survenue.'
      }
    }
    throw error
  }
}
```

```js filename="app/lib/actions.js" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState, formData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Identifiants invalides.'
        default:
          return 'Une erreur est survenue.'
      }
    }
    throw error
  }
}
```

</AppOnly>

Dans ce code, la m√©thode `signIn` v√©rifie les identifiants par rapport aux donn√©es utilisateur stock√©es.
Apr√®s que le fournisseur d'authentification a trait√© les identifiants, il y a deux r√©sultats possibles :

- **Authentification r√©ussie** : Cela implique que la connexion a r√©ussi. D'autres actions, comme l'acc√®s aux routes prot√©g√©es et la r√©cup√©ration des informations utilisateur, peuvent alors √™tre initi√©es.
- **Authentification √©chou√©e** : Dans les cas o√π les identifiants sont incorrects ou qu'une erreur est rencontr√©e, la fonction retourne un message d'erreur correspondant pour indiquer l'√©chec de l'authentification.

<AppOnly>

Enfin, dans votre composant `login-form.tsx`, vous pouvez utiliser `useFormState` de React pour appeler la Server Action et g√©rer les erreurs du formulaire, et utiliser `useFormStatus` pour g√©rer l'√©tat en attente du formulaire :

```tsx filename="app/login/page.tsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Se connecter
    </button>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Mot de passe" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Se connecter
    </button>
  )
}
```

</AppOnly>

Pour une configuration d'authentification plus rationalis√©e dans les projets Next.js, surtout lorsqu'on propose plusieurs m√©thodes de connexion, envisagez d'utiliser une [solution d'authentification compl√®te](#examples).

## Autorisation

Une fois qu'un utilisateur est authentifi√©, vous devez vous assurer qu'il est autoris√© √† visiter certaines routes et √† effectuer des op√©rations telles que la mutation de donn√©es avec des Server Actions et l'appel √† des Route Handlers.

### Protection des routes avec Middleware

Le [Middleware](/docs/app/building-your-application/routing/middleware) dans Next.js vous aide √† contr√¥ler qui peut acc√©der √† diff√©rentes parties de votre site. C'est important pour garder des zones comme le tableau de bord utilisateur prot√©g√©es tout en ayant d'autres pages comme les pages marketing publiques. Il est recommand√© d'appliquer le Middleware √† toutes les routes et de sp√©cifier des exclusions pour l'acc√®s public.

Voici comment impl√©menter le Middleware pour l'authentification dans Next.js :

#### Configuration du Middleware :

- Cr√©ez un fichier `middleware.ts` ou `.js` dans le r√©pertoire racine de votre projet.
- Incluez une logique pour autoriser l'acc√®s utilisateur, comme v√©rifier les jetons d'authentification.

#### D√©finition des routes prot√©g√©es :

- Toutes les routes ne n√©cessitent pas d'autorisation. Utilisez l'option `matcher` dans votre Middleware pour sp√©cifier les routes qui ne n√©cessitent pas de v√©rification d'autorisation.

#### Logique du Middleware :

- √âcrivez une logique pour v√©rifier si un utilisateur est authentifi√©. V√©rifiez les r√¥les ou les permissions des utilisateurs pour l'autorisation des routes.

#### Gestion des acc√®s non autoris√©s :

- Redirigez les utilisateurs non autoris√©s vers une page de connexion ou d'erreur selon le cas.

Exemple de fichier Middleware :

```ts filename="middleware.ts" switcher
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
export function middleware(request) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Cet exemple utilise [`Response.redirect`](https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect_static) pour g√©rer les redirections t√¥t dans le pipeline de requ√™tes, ce qui le rend efficace et centralise le contr√¥le d'acc√®s.

<AppOnly>

Pour des besoins de redirection sp√©cifiques, la fonction `redirect` peut √™tre utilis√©e dans les Server Components, Route Handlers et Server Actions pour fournir plus de contr√¥le. C'est utile pour la navigation bas√©e sur les r√¥les ou les sc√©narios sensibles au contexte.

```ts filename="app/page.tsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // Logique pour d√©terminer si une redirection est n√©cessaire
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // D√©finir d'autres routes et logique
}
```

```js filename="app/page.jsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // Logique pour d√©terminer si une redirection est n√©cessaire
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // D√©finir d'autres routes et logique
}
```

</AppOnly>

Apr√®s une authentification r√©ussie, il est important de g√©rer la navigation de l'utilisateur en fonction de ses r√¥les. Par exemple, un utilisateur admin pourrait √™tre redirig√© vers un tableau de bord admin, tandis qu'un utilisateur r√©gulier serait envoy√© vers une page diff√©rente. C'est important pour des exp√©riences sp√©cifiques aux r√¥les et une navigation conditionnelle, comme inviter les utilisateurs √† compl√©ter leur profil si n√©cessaire.

Lors de la configuration de l'autorisation, il est important de s'assurer que les principales v√©rifications de s√©curit√© se produisent l√† o√π votre application acc√®de ou modifie les donn√©es. Bien que le Middleware puisse √™tre utile pour une validation initiale, il ne devrait pas √™tre la seule ligne de d√©fense pour prot√©ger vos donn√©es. L'essentiel des v√©rifications de s√©curit√© devrait √™tre effectu√© dans la couche d'acc√®s aux donn√©es (DAL).

<PagesOnly>

### S√©curisation des routes API

Les routes API dans Next.js sont essentielles pour g√©rer la logique c√¥t√© serveur et la gestion des donn√©es. Il est crucial de s√©curiser ces routes pour garantir que seuls les utilisateurs autoris√©s peuvent acc√©der √† des fonctionnalit√©s sp√©cifiques. Cela implique g√©n√©ralement de v√©rifier le statut d'authentification de l'utilisateur et ses permissions bas√©es sur son r√¥le.

Voici un exemple de s√©curisation d'une route API :

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    res.status(401).json({
      error: "L'utilisateur n'est pas authentifi√©",
    })
    return
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: "Acc√®s non autoris√© : L'utilisateur n'a pas les privil√®ges d'administrateur.",
    })
    return
  }

  // Continuer avec la route pour les utilisateurs autoris√©s
  // ... impl√©mentation de la route API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    res.status(401).json({
      error: "L'utilisateur n'est pas authentifi√©",
    })
    return
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: "Acc√®s non autoris√© : L'utilisateur n'a pas les privil√®ges d'administrateur.",
    })
    return
  }

  // Continuer avec la route pour les utilisateurs autoris√©s
  // ... impl√©mentation de la route API
}
```

Cet exemple montre une route API avec une double v√©rification de s√©curit√© pour l'authentification et l'autorisation. Elle v√©rifie d'abord la pr√©sence d'une session active, puis confirme que l'utilisateur connect√© est un 'admin'. Cette approche garantit un acc√®s s√©curis√©, limit√© aux utilisateurs authentifi√©s et autoris√©s, maintenant une robustesse de s√©curit√© pour le traitement des requ√™tes.

</PagesOnly>

<AppOnly>

Cette approche, mise en avant dans [ce blog sur la s√©curit√©](/blog/security-nextjs-server-components-actions), pr√©conise de consolider tous les acc√®s aux donn√©es dans une couche DAL d√©di√©e. Cette strat√©gie assure un acc√®s coh√©rent aux donn√©es, minimise les bugs d'autorisation et simplifie la maintenance. Pour une s√©curit√© compl√®te, consid√©rez les domaines cl√©s suivants :

- Actions serveur : Impl√©mentez des v√©rifications de s√©curit√© dans les processus c√¥t√© serveur, surtout pour les op√©rations sensibles.
- Gestionnaires de route : G√©rez les requ√™tes entrantes avec des mesures de s√©curit√© pour limiter l'acc√®s aux utilisateurs autoris√©s.
- Couche d'acc√®s aux donn√©es (DAL) : Interagit directement avec la base de donn√©es et est cruciale pour valider et autoriser les transactions. Il est vital d'effectuer des v√©rifications critiques au sein de la DAL pour s√©curiser les donn√©es √† leur point d'interaction le plus crucial‚Äîl'acc√®s ou la modification.

Pour un guide d√©taill√© sur la s√©curisation de la DAL, incluant des exemples de code et des pratiques avanc√©es, consultez notre [section sur la couche d'acc√®s aux donn√©es](/blog/security-nextjs-server-components-actions#data-access-layer) du guide de s√©curit√©.

### S√©curisation des actions serveur

Il est important de traiter les [actions serveur](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) avec les m√™mes consid√©rations de s√©curit√© que les points d'API publics. V√©rifier l'autorisation de l'utilisateur pour chaque action est crucial. Impl√©mentez des v√©rifications dans les actions serveur pour d√©terminer les permissions de l'utilisateur, comme restreindre certaines actions aux administrateurs.

Dans l'exemple ci-dessous, nous v√©rifions le r√¥le de l'utilisateur avant d'autoriser l'action :

```ts filename="app/lib/actions.ts" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // V√©rifier si l'utilisateur est autoris√© √† effectuer l'action
  if (userRole !== 'admin') {
    throw new Error("Acc√®s non autoris√© : L'utilisateur n'a pas les privil√®ges d'administrateur.")
  }

  // Continuer avec l'action pour les utilisateurs autoris√©s
  // ... impl√©mentation de l'action
}
```

```js filename="app/lib/actions.js" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // V√©rifier si l'utilisateur est autoris√© √† effectuer l'action
  if (userRole !== 'admin') {
    throw new Error("Acc√®s non autoris√© : L'utilisateur n'a pas les privil√®ges d'administrateur.")
  }

  // Continuer avec l'action pour les utilisateurs autoris√©s
  // ... impl√©mentation de l'action
}
```

### S√©curisation des gestionnaires de route

Les gestionnaires de route dans Next.js jouent un r√¥le vital dans la gestion des requ√™tes entrantes. Comme pour les actions serveur, ils doivent √™tre s√©curis√©s pour garantir que seuls les utilisateurs autoris√©s peuvent acc√©der √† certaines fonctionnalit√©s. Cela implique souvent de v√©rifier le statut d'authentification de l'utilisateur et ses permissions.

Voici un exemple de s√©curisation d'un gestionnaire de route :

```ts filename="app/api/route.ts" switcher
export async function GET() {
  // Authentification et v√©rification du r√¥le de l'utilisateur
  const session = await getSession()

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    return new Response(null, { status: 401 }) // L'utilisateur n'est pas authentifi√©
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // L'utilisateur est authentifi√© mais n'a pas les bonnes permissions
  }

  // R√©cup√©ration des donn√©es pour les utilisateurs autoris√©s
}
```

```js filename="app/api/route.js" switcher
export async function GET() {
  // Authentification et v√©rification du r√¥le de l'utilisateur
  const session = await getSession()

  // V√©rifier si l'utilisateur est authentifi√©
  if (!session) {
    return new Response(null, { status: 401 }) // L'utilisateur n'est pas authentifi√©
  }

  // V√©rifier si l'utilisateur a le r√¥le 'admin'
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // L'utilisateur est authentifi√© mais n'a pas les bonnes permissions
  }

  // R√©cup√©ration des donn√©es pour les utilisateurs autoris√©s
}
```

Cet exemple montre un gestionnaire de route avec une double v√©rification de s√©curit√© pour l'authentification et l'autorisation. Il v√©rifie d'abord la pr√©sence d'une session active, puis confirme que l'utilisateur connect√© est un 'admin'. Cette approche garantit un acc√®s s√©curis√©, limit√© aux utilisateurs authentifi√©s et autoris√©s, maintenant une robustesse de s√©curit√© pour le traitement des requ√™tes.

### Autorisation avec les composants serveur

Les [composants serveur](/docs/app/building-your-application/rendering/server-components) dans Next.js sont con√ßus pour une ex√©cution c√¥t√© serveur et offrent un environnement s√©curis√© pour int√©grer une logique complexe comme l'autorisation. Ils permettent un acc√®s direct aux ressources back-end, optimisant les performances pour les t√¢ches intensives en donn√©es et renfor√ßant la s√©curit√© pour les op√©rations sensibles.

Dans les composants serveur, une pratique courante est de conditionner l'affichage des √©l√©ments d'interface en fonction du r√¥le de l'utilisateur. Cette approche am√©liore l'exp√©rience utilisateur et la s√©curit√© en garantissant que les utilisateurs n'acc√®dent qu'au contenu qu'ils sont autoris√©s √† voir.

**Exemple :**

```tsx filename="app/dashboard/page.tsx" switcher
export default async function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Supposons que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard /> // Composant pour les administrateurs
  } else if (userRole === 'user') {
    return <UserDashboard /> // Composant pour les utilisateurs normaux
  } else {
    return <AccessDenied /> // Composant affich√© pour un acc√®s non autoris√©
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
export default function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Supposons que 'role' fait partie de l'objet session

  if (userRole === 'admin') {
    return <AdminDashboard /> // Composant pour les administrateurs
  } else if (userRole === 'user') {
    return <UserDashboard /> // Composant pour les utilisateurs normaux
  } else {
    return <AccessDenied /> // Composant affich√© pour un acc√®s non autoris√©
  }
}
```

Dans cet exemple, le composant Dashboard affiche diff√©rentes interfaces pour les r√¥les 'admin', 'user' et non autoris√©s. Ce mod√®le garantit que chaque utilisateur interagit uniquement avec les composants adapt√©s √† son r√¥le, am√©liorant √† la fois la s√©curit√© et l'exp√©rience utilisateur.

</AppOnly>

### Bonnes pratiques

- **Gestion s√©curis√©e des sessions** : Priorisez la s√©curit√© des donn√©es de session pour pr√©venir les acc√®s non autoris√©s et les fuites de donn√©es. Utilisez le chiffrement et des pratiques de stockage s√©curis√©es.
- **Gestion dynamique des r√¥les** : Utilisez un syst√®me flexible pour les r√¥les utilisateurs afin de s'adapter facilement aux changements de permissions et de r√¥les, √©vitant les r√¥les cod√©s en dur.
- **Approche s√©curit√© d'abord** : Dans tous les aspects de la logique d'autorisation, priorisez la s√©curit√© pour prot√©ger les donn√©es utilisateurs et maintenir l'int√©grit√© de votre application. Cela inclut des tests approfondis et la prise en compte des vuln√©rabilit√©s potentielles.

## Gestion des sessions

La gestion des sessions implique le suivi et la gestion des interactions d'un utilisateur avec l'application au fil du temps, en assurant que son √©tat authentifi√© est pr√©serv√© √† travers diff√©rentes parties de l'application.

Cela √©vite les connexions r√©p√©t√©es, am√©liorant √† la fois la s√©curit√© et la commodit√© pour l'utilisateur. Il existe deux m√©thodes principales pour la gestion des sessions : les sessions bas√©es sur les cookies et les sessions en base de donn√©es.

### Sessions bas√©es sur les cookies

> **üé• Regarder :** En savoir plus sur les sessions bas√©es sur les cookies et l'authentification avec Next.js ‚Üí [YouTube (11 minutes)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

Les sessions bas√©es sur les cookies g√®rent les donn√©es utilisateur en stockant des informations de session chiffr√©es directement dans les cookies du navigateur. Lors de la connexion de l'utilisateur, ces donn√©es chiffr√©es sont stock√©es dans le cookie. Chaque requ√™te ult√©rieure au serveur inclut ce cookie, minimisant le besoin de requ√™tes r√©p√©t√©es au serveur et am√©liorant l'efficacit√© c√¥t√© client.

Cependant, cette m√©thode n√©cessite un chiffrement soign√© pour prot√©ger les donn√©es sensibles, car les cookies sont vuln√©rables aux risques de s√©curit√© c√¥t√© client. Chiffrer les donn√©es de session dans les cookies est essentiel pour prot√©ger les informations utilisateur contre les acc√®s non autoris√©s. Cela garantit que m√™me si un cookie est vol√©, les donn√©es restent illisibles.

De plus, bien que chaque cookie soit limit√© en taille (g√©n√©ralement environ 4Ko), des techniques comme le d√©coupage de cookies peuvent contourner cette limitation en divisant les donn√©es de session volumineuses en plusieurs cookies.

D√©finir un cookie dans un projet Next.js pourrait ressembler √† ceci :

**D√©finition d'un cookie c√¥t√© serveur :**

<PagesOnly>

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie d√©fini avec succ√®s !' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Cookie d√©fini avec succ√®s !' })
}
```

</PagesOnly>

<AppOnly>

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Chiffrez vos donn√©es de session
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  // Rediriger ou g√©rer la r√©ponse apr√®s la d√©finition du cookie
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Chiffrez vos donn√©es de session
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Une semaine
    path: '/',
  })
  // Rediriger ou g√©rer la r√©ponse apr√®s la d√©finition du cookie
}
```

**Acc√®s aux donn√©es de session stock√©es dans le cookie dans un composant serveur :**

```tsx filename="app/page.tsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

```jsx filename="app/page.jsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

</AppOnly>

### Sessions en base de donn√©es

La gestion des sessions en base de donn√©es implique de stocker les donn√©es de session sur le serveur, le navigateur de l'utilisateur ne recevant qu'un identifiant de session. Cet ID r√©f√©rence les donn√©es de session stock√©es c√¥t√© serveur, sans contenir les donn√©es elles-m√™mes. Cette m√©thode am√©liore la s√©curit√©, car elle garde les donn√©es sensibles √† l'√©cart de l'environnement client, r√©duisant le risque d'exposition aux attaques c√¥t√© client. Les sessions en base de donn√©es sont aussi plus √©volutives, accommodant des besoins de stockage plus importants.

Cependant, cette approche a ses compromis. Elle peut augmenter la surcharge de performance en raison des requ√™tes √† la base de donn√©es √† chaque interaction utilisateur. Des strat√©gies comme la mise en cache des donn√©es de session peuvent aider √† att√©nuer cela. De plus, la d√©pendance √† la base de donn√©es signifie que la gestion des sessions est aussi fiable que la performance et la disponibilit√© de la base de donn√©es.

Voici un exemple simplifi√© d'impl√©mentation de sessions en base de donn√©es dans une application Next.js :

**Cr√©ation d'une session c√¥t√© serveur :**

<PagesOnly>

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Erreur interne du serveur' })
  }
}
```

</PagesOnly>

<AppOnly>

```js
import db from './lib/db'

export async function createSession(user) {
  const sessionId = generateSessionId() // G√©n√©rer un ID de session unique
  await db.insertSession({ sessionId, userId: user.id, createdAt: new Date() })
  return sessionId
}
```

**R√©cup√©ration d'une session dans un middleware ou une logique c√¥t√© serveur :**

```js
import { cookies } from 'next/headers'
import db from './lib/db'

export async function getSession() {
  const sessionId = cookies().get('sessionId')?.value
  return sessionId ? await db.findSession(sessionId) : null
}
```

</AppOnly>

### Choix du syst√®me de gestion de session dans Next.js

Le choix entre les sessions bas√©es sur des cookies et celles stock√©es en base de donn√©es dans Next.js d√©pend des besoins de votre application. Les sessions bas√©es sur des cookies sont plus simples et conviennent aux applications plus l√©g√®res avec une charge serveur r√©duite, mais peuvent offrir une s√©curit√© moindre. Les sessions en base de donn√©es, bien que plus complexes, fournissent une meilleure s√©curit√© et une meilleure √©volutivit√©, id√©ales pour les applications plus importantes et sensibles aux donn√©es.

Avec des [solutions d'authentification](#exemples) comme [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5), la gestion des sessions devient plus efficace, en utilisant soit des cookies soit un stockage en base de donn√©es. Cette automatisation simplifie le processus de d√©veloppement, mais il est important de comprendre la m√©thode de gestion de session utilis√©e par votre solution choisie. Assurez-vous qu'elle correspond aux exigences de s√©curit√© et de performance de votre application.

Quel que soit votre choix, priorisez la s√©curit√© dans votre strat√©gie de gestion de session. Pour les sessions bas√©es sur des cookies, l'utilisation de cookies s√©curis√©s et HTTP-only est cruciale pour prot√©ger les donn√©es de session. Pour les sessions en base de donn√©es, des sauvegardes r√©guli√®res et une manipulation s√©curis√©e des donn√©es de session sont essentielles. La mise en place de m√©canismes d'expiration et de nettoyage des sessions est vitale dans les deux approches pour pr√©venir les acc√®s non autoris√©s et maintenir les performances et la fiabilit√© de l'application.

## Exemples

Voici des solutions d'authentification compatibles avec Next.js, consultez les guides de d√©marrage rapide ci-dessous pour apprendre √† les configurer dans votre application Next.js :

{/* TODO: Changer le lien vers authjs.dev lorsque la nouvelle documentation sera pr√™te */}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Lucia](https://lucia-auth.com/getting-started/nextjs-app)
- [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [Iron Session](https://github.com/vvo/iron-session)

## Pour aller plus loin

Pour continuer √† apprendre sur l'authentification et la s√©curit√©, consultez les ressources suivantes :

- [Comprendre les attaques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Comprendre les attaques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
