---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:23:20.063Z
title: Actions serveur et mutations
nav_title: Actions serveur et mutations
description: Apprenez √† g√©rer les soumissions de formulaires et les mutations de donn√©es avec Next.js.
related:
  description: Apprenez √† configurer les actions serveur dans Next.js
  links:
    - app/api-reference/next-config-js/serverActions
---

Les actions serveur sont des **fonctions asynchrones** ex√©cut√©es sur le serveur. Elles peuvent √™tre utilis√©es dans les composants serveur et client pour g√©rer les soumissions de formulaires et les mutations de donn√©es dans les applications Next.js.

> **üé• Regarder :** En savoir plus sur les formulaires et mutations avec les actions serveur ‚Üí [YouTube (10 minutes)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## Convention

Une action serveur peut √™tre d√©finie avec la directive React [`"use server"`](https://react.dev/reference/react/use-server). Vous pouvez placer la directive en haut d'une fonction `async` pour marquer la fonction comme une action serveur, ou en haut d'un fichier s√©par√© pour marquer toutes les exportations de ce fichier comme des actions serveur.

### Composants serveur

Les composants serveur peuvent utiliser la directive `"use server"` au niveau de la fonction ou du module. Pour int√©grer une action serveur, ajoutez `"use server"` en haut du corps de la fonction :

```tsx filename="app/page.tsx" switcher
// Composant serveur
export default function Page() {
  // Action serveur
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

```jsx filename="app/page.jsx" switcher
// Composant serveur
export default function Page() {
  // Action serveur
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

### Composants client

Les composants client ne peuvent importer que des actions utilisant la directive `"use server"` au niveau du module.

Pour appeler une action serveur dans un composant client, cr√©ez un nouveau fichier et ajoutez la directive `"use server"` en haut. Toutes les fonctions dans le fichier seront marqu√©es comme actions serveur pouvant √™tre r√©utilis√©es dans les composants client et serveur :

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {
  // ...
}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {
  // ...
}
```

```tsx filename="app/ui/button.tsx" switcher
import { create } from '@/app/actions'

export function Button() {
  return (
    // ...
  )
}
```

```jsx filename="app/ui/button.js" switcher
import { create } from '@/app/actions'

export function Button() {
  return (
    // ...
  )
}
```

Vous pouvez √©galement passer une action serveur √† un composant client comme prop :

```jsx
<ClientComponent updateItem={updateItem} />
```

```jsx filename="app/client-component.jsx"
'use client'

export default function ClientComponent({ updateItem }) {
  return <form action={updateItem}>{/* ... */}</form>
}
```

## Comportement

- Les actions serveur peuvent √™tre invoqu√©es en utilisant l'attribut `action` dans un √©l√©ment [`<form>`](#forms) :
  - Les composants serveur supportent l'am√©lioration progressive par d√©faut, ce qui signifie que le formulaire sera soumis m√™me si JavaScript n'est pas encore charg√© ou est d√©sactiv√©.
  - Dans les composants client, les formulaires invoquant des actions serveur mettront en file d'attente les soumissions si JavaScript n'est pas encore charg√©, en priorisant l'hydratation client.
  - Apr√®s l'hydratation, le navigateur ne se rafra√Æchit pas lors de la soumission du formulaire.
- Les actions serveur ne sont pas limit√©es √† `<form>` et peuvent √™tre invoqu√©es depuis des gestionnaires d'√©v√©nements, `useEffect`, des biblioth√®ques tierces et d'autres √©l√©ments de formulaire comme `<button>`.
- Les actions serveur s'int√®grent avec l'architecture de [cache et revalidation](/docs/app/building-your-application/caching) de Next.js. Lorsqu'une action est invoqu√©e, Next.js peut retourner √† la fois l'UI mise √† jour et les nouvelles donn√©es en un seul aller-retour serveur.
- En arri√®re-plan, les actions utilisent la m√©thode `POST`, et seule cette m√©thode HTTP peut les invoquer.
- Les arguments et la valeur de retour des actions serveur doivent √™tre s√©rialisables par React. Voir la documentation React pour une liste des [arguments et valeurs s√©rialisables](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values).
- Les actions serveur sont des fonctions. Cela signifie qu'elles peuvent √™tre r√©utilis√©es n'importe o√π dans votre application.
- Les actions serveur h√©ritent du [runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) de la page ou du layout o√π elles sont utilis√©es.
- Les actions serveur h√©ritent de la [configuration du segment de route](/docs/app/api-reference/file-conventions/route-segment-config) de la page ou du layout o√π elles sont utilis√©es, y compris des champs comme `maxDuration`.

## Exemples

### Formulaires

React √©tend l'√©l√©ment HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) pour permettre l'invocation d'actions serveur avec la prop `action`.

Lorsqu'elle est invoqu√©e dans un formulaire, l'action re√ßoit automatiquement l'objet [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData). Vous n'avez pas besoin d'utiliser React `useState` pour g√©rer les champs, vous pouvez extraire les donn√©es en utilisant les m√©thodes natives de [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods) :

```tsx filename="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // muter les donn√©es
    // revalider le cache
  }

  return <form action={createInvoice}>...</form>
}
```

```jsx filename="app/invoices/page.jsx" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // muter les donn√©es
    // revalider le cache
  }

  return <form action={createInvoice}>...</form>
}
```

> **Bon √† savoir :**
>
> - Exemple : [Formulaire avec √©tats de chargement et d'erreur](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - Lorsque vous travaillez avec des formulaires ayant de nombreux champs, vous pouvez envisager d'utiliser la m√©thode [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) avec [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) de JavaScript. Par exemple : `const rawFormData = Object.fromEntries(formData)`. Une chose √† noter est que le `formData` inclura des propri√©t√©s suppl√©mentaires `$ACTION_`.
> - Voir la documentation de React sur [`<form>`](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action) pour en savoir plus.

#### Passage d'arguments suppl√©mentaires

Vous pouvez passer des arguments suppl√©mentaires √† une action serveur en utilisant la m√©thode JavaScript `bind`.

```tsx filename="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Mettre √† jour le nom</button>
    </form>
  )
}
```

```jsx filename="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Mettre √† jour le nom</button>
    </form>
  )
}
```

L'action serveur recevra l'argument `userId`, en plus des donn√©es du formulaire :

```js filename="app/actions.js"
'use server'

export async function updateUser(userId, formData) {
  // ...
}
```

> **Bon √† savoir :**
>
> - Une alternative est de passer les arguments comme champs cach√©s dans le formulaire (par exemple `<input type="hidden" name="userId" value={userId} />`). Cependant, la valeur fera partie du HTML rendu et ne sera pas encod√©e.
> - `.bind` fonctionne dans les composants serveur et client. Il supporte √©galement l'am√©lioration progressive.

#### √âtats en attente

Vous pouvez utiliser le hook React [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) pour afficher un √©tat en attente pendant la soumission du formulaire.

- `useFormStatus` retourne le statut pour un `<form>` sp√©cifique, donc **il doit √™tre d√©fini comme un enfant de l'√©l√©ment `<form>`**.
- `useFormStatus` est un hook React et doit donc √™tre utilis√© dans un composant client.

```tsx filename="app/submit-button.tsx" switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" disabled={pending}>
      Ajouter
    </button>
  )
}
```

```jsx filename="app/submit-button.jsx" switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" disabled={pending}>
      Ajouter
    </button>
  )
}
```

`<SubmitButton />` peut ensuite √™tre imbriqu√© dans n'importe quel formulaire :

```tsx filename="app/page.tsx" switcher
import { SubmitButton } from '@/app/submit-button'
import { createItem } from '@/app/actions'

// Composant serveur
export default async function Home() {
  return (
    <form action={createItem}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

```jsx filename="app/page.jsx" switcher
import { SubmitButton } from '@/app/submit-button'
import { createItem } from '@/app/actions'

// Composant serveur
export default async function Home() {
  return (
    <form action={createItem}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

#### Validation c√¥t√© serveur et gestion des erreurs

Nous recommandons d'utiliser la validation HTML comme `required` et `type="email"` pour une validation de base c√¥t√© client.

Pour une validation plus avanc√©e c√¥t√© serveur, vous pouvez utiliser une biblioth√®que comme [zod](https://zod.dev/) pour valider les champs du formulaire avant de muter les donn√©es :

```tsx filename="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Email invalide',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // Retourner t√¥t si les donn√©es du formulaire sont invalides
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Muter les donn√©es
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Email invalide',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // Retourner t√¥t si les donn√©es du formulaire sont invalides
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Muter les donn√©es
}
```

Une fois les champs valid√©s c√¥t√© serveur, vous pouvez retourner un objet s√©rialisable dans votre action et utiliser le hook React [`useFormState`](https://react.dev/reference/react-dom/hooks/useFormState) pour afficher un message √† l'utilisateur.

- En passant l'action √† `useFormState`, la signature de la fonction de l'action change pour recevoir un nouveau param√®tre `prevState` ou `initialState` comme premier argument.
- `useFormState` est un hook React et doit donc √™tre utilis√© dans un composant client.

```tsx filename="app/actions.ts" switcher
'use server'

export async function createUser(prevState: any, formData: FormData) {
  // ...
  return {
    message: 'Veuillez entrer un email valide',
  }
}
```

```jsx filename="app/actions.js" switcher
'use server'

export async function createUser(prevState, formData) {
  // ...
  return {
    message: 'Veuillez entrer un email valide',
  }
}
```

Ensuite, vous pouvez passer votre action au hook `useFormState` et utiliser le `state` retourn√© pour afficher un message d'erreur.

```tsx filename="app/ui/signup.tsx" switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
      <button>S'inscrire</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
      <button>S'inscrire</button>
    </form>
  )
}
```

> **Bon √† savoir :**
>
> - Avant de muter les donn√©es, vous devez toujours vous assurer qu'un utilisateur est √©galement autoris√© √† effectuer l'action. Voir [Authentification et autorisation](#authentication-and-authorization).

#### Mises √† jour optimistes

Vous pouvez utiliser le hook React [`useOptimistic`](https://react.dev/reference/react/useOptimistic) pour mettre √† jour de mani√®re optimiste l'UI avant que l'action serveur ne se termine, plut√¥t que d'attendre la r√©ponse :

```tsx filename="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  return (
    <div>
      {optimisticMessages.map((m, k) => (
        <div key={k}>{m.message}</div>
      ))}
      <form
        action={async (formData: FormData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Envoyer</button>
      </form>
    </div>
  )
}
```

```jsx filename="app/page.jsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form
        action={async (formData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Envoyer</button>
      </form>
    </div>
  )
}
```

#### √âl√©ments imbriqu√©s

Vous pouvez invoquer une action serveur dans des √©l√©ments imbriqu√©s √† l'int√©rieur de `<form>` comme `<button>`, `<input type="submit">`, et `<input type="image">`. Ces √©l√©ments acceptent la prop `formAction` ou des [gestionnaires d'√©v√©nements](#event-handlers).

C'est utile dans les cas o√π vous souhaitez appeler plusieurs actions serveur dans un formulaire. Par exemple, vous pouvez cr√©er un √©l√©ment `<button>` sp√©cifique pour sauvegarder un brouillon de poste en plus de le publier. Voir la documentation de React sur [`<form>`](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types) pour plus d'informations.

#### Soumission programmatique de formulaire

Vous pouvez d√©clencher la soumission d'un formulaire en utilisant la m√©thode [`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit). Par exemple, lorsque l'utilisateur appuie sur `‚åò` + `Entr√©e`, vous pouvez √©couter l'√©v√©nement `onKeyDown` :

```tsx filename="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

```jsx filename="app/entry.jsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

Cela d√©clenchera la soumission du `<form>` anc√™tre le plus proche, ce qui invoquera l'Action Serveur.

### √âl√©ments non-formulaire

Bien qu'il soit courant d'utiliser les Actions Serveur dans des √©l√©ments `<form>`, elles peuvent √©galement √™tre invoqu√©es depuis d'autres parties de votre code, comme les gestionnaires d'√©v√©nements et `useEffect`.

#### Gestionnaires d'√©v√©nements

Vous pouvez invoquer une Action Serveur depuis des gestionnaires d'√©v√©nements comme `onClick`. Par exemple, pour incr√©menter un compteur de likes :

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes : {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes : {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

Pour am√©liorer l'exp√©rience utilisateur, nous recommandons d'utiliser d'autres API React comme [`useOptimistic`](https://react.dev/reference/react/useOptimistic) et [`useTransition`](https://react.dev/reference/react/useTransition) pour mettre √† jour l'interface avant que l'Action Serveur ne termine son ex√©cution sur le serveur, ou pour afficher un √©tat en attente.

Vous pouvez √©galement ajouter des gestionnaires d'√©v√©nements aux √©l√©ments de formulaire, par exemple pour sauvegarder un champ de formulaire `onChange` :

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publier</button>
    </form>
  )
}
```

Pour des cas comme celui-ci, o√π plusieurs √©v√©nements peuvent √™tre d√©clench√©s rapidement, nous recommandons d'utiliser le **debouncing** pour √©viter des invocations inutiles d'Actions Serveur.

#### `useEffect`

Vous pouvez utiliser le hook React [`useEffect`](https://react.dev/reference/react/useEffect) pour invoquer une Action Serveur lorsque le composant est mont√© ou qu'une d√©pendance change. Ceci est utile pour les mutations qui d√©pendent d'√©v√©nements globaux ou qui doivent √™tre d√©clench√©es automatiquement. Par exemple, `onKeyDown` pour les raccourcis d'application, un hook d'intersection pour le d√©filement infini, ou lorsque le composant est mont√© pour mettre √† jour un compteur de vues :

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views : {views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total Views : {views}</p>
}
```

N'oubliez pas de prendre en compte le [comportement et les mises en garde](https://react.dev/reference/react/useEffect#caveats) de `useEffect`.

### Gestion des erreurs

Lorsqu'une erreur est lev√©e, elle sera captur√©e par le fichier [`error.js`](/docs/app/building-your-application/routing/error-handling) le plus proche ou la limite `<Suspense>` sur le client. Nous recommandons d'utiliser `try/catch` pour retourner les erreurs √† g√©rer par votre interface.

Par exemple, votre Action Serveur pourrait g√©rer les erreurs lors de la cr√©ation d'un nouvel √©l√©ment en retournant un message :

```ts filename="app/actions.ts" switcher
'use server'

export async function createTodo(prevState: any, formData: FormData) {
  try {
    // Mutate data
  } catch (e) {
    throw new Error('√âchec de la cr√©ation de la t√¢che')
  }
}
```

```js filename="app/actions.js" switcher
'use server'

export async function createTodo(prevState, formData) {
  try {
    //  Mutate data
  } catch (e) {
    throw new Error('√âchec de la cr√©ation de la t√¢che')
  }
}
```

> **Bon √† savoir :**
>
> - En plus de lever l'erreur, vous pouvez √©galement retourner un objet √† g√©rer par `useFormState`. Voir [Validation c√¥t√© serveur et gestion des erreurs](#server-side-validation-and-error-handling).

### R√©validation des donn√©es

Vous pouvez r√©valider le [Cache Next.js](/docs/app/building-your-application/caching) dans vos Actions Serveur avec l'API [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

Ou invalider une r√©cup√©ration de donn√©es sp√©cifique avec une √©tiquette de cache en utilisant [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### Redirection

Si vous souhaitez rediriger l'utilisateur vers une route diff√©rente apr√®s l'ex√©cution d'une Action Serveur, vous pouvez utiliser l'API [`redirect`](/docs/app/api-reference/functions/redirect). `redirect` doit √™tre appel√© en dehors du bloc `try/catch` :

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Mettre √† jour les posts en cache
  redirect(`/post/${id}`) // Naviguer vers la nouvelle page de post
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Mettre √† jour les posts en cache
  redirect(`/post/${id}`) // Naviguer vers la nouvelle page de post
}
```

### Cookies

Vous pouvez `get`, `set`, et `delete` des cookies dans une Action Serveur en utilisant l'API [`cookies`](/docs/app/api-reference/functions/cookies) :

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Get cookie
  const value = cookies().get('name')?.value

  // Set cookie
  cookies().set('name', 'Delba')

  // Delete cookie
  cookies().delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Get cookie
  const value = cookies().get('name')?.value

  // Set cookie
  cookies().set('name', 'Delba')

  // Delete cookie
  cookies().delete('name')
}
```

Voir [des exemples suppl√©mentaires](/docs/app/api-reference/functions/cookies#deleting-cookies) pour supprimer des cookies depuis des Actions Serveur.

## S√©curit√©

### Authentification et autorisation

Vous devriez traiter les Actions Serveur comme vous le feriez pour des points de terminaison d'API publics, et vous assurer que l'utilisateur est autoris√© √† effectuer l'action. Par exemple :

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('Vous devez √™tre connect√© pour effectuer cette action')
  }

  // ...
}
```

### Fermetures et chiffrement

D√©finir une Action Serveur dans un composant cr√©e une [fermeture (closure)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) o√π l'action a acc√®s √† la port√©e de la fonction externe. Par exemple, l'action `publish` a acc√®s √† la variable `publishVersion` :

```tsx filename="app/page.tsx" switcher
export default function Page() {
  const publishVersion = await getLatestVersion();

  async function publish(formData: FormData) {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('La version a chang√© depuis l\'appui sur publier');
    }
    ...
  }

  return <button action={publish}>Publier</button>;
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('La version a chang√© depuis l\'appui sur publier');
    }
    ...
  }

  return <button action={publish}>Publier</button>;
}
```

Les fermetures sont utiles lorsque vous avez besoin de capturer un instantan√© de donn√©es (par exemple `publishVersion`) au moment du rendu pour pouvoir l'utiliser plus tard lorsque l'action est invoqu√©e.

Cependant, pour que cela se produise, les variables captur√©es sont envoy√©es au client et retourn√©es au serveur lorsque l'action est invoqu√©e. Pour emp√™cher les donn√©es sensibles d'√™tre expos√©es au client, Next.js chiffre automatiquement les variables captur√©es. Une nouvelle cl√© priv√©e est g√©n√©r√©e pour chaque action √† chaque fois qu'une application Next.js est construite. Cela signifie que les actions ne peuvent √™tre invoqu√©es que pour une construction sp√©cifique.

> **Bon √† savoir :** Nous ne recommandons pas de compter uniquement sur le chiffrement pour emp√™cher les valeurs sensibles d'√™tre expos√©es au client. √Ä la place, vous devriez utiliser les [API React taint](/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client) pour emp√™cher de mani√®re proactive certaines donn√©es d'√™tre envoy√©es au client.

### Remplacement des cl√©s de chiffrement (avanc√©)

Lorsque vous auto-h√©bergez votre application Next.js sur plusieurs serveurs, chaque instance de serveur peut se retrouver avec une cl√© de chiffrement diff√©rente, ce qui peut entra√Æner des incoh√©rences.

Pour att√©nuer cela, vous pouvez remplacer la cl√© de chiffrement en utilisant la variable d'environnement `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY`. Sp√©cifier cette variable garantit que vos cl√©s de chiffrement sont persistantes entre les constructions, et que toutes les instances de serveur utilisent la m√™me cl√©.

Ceci est un cas d'utilisation avanc√© o√π un comportement de chiffrement coh√©rent entre plusieurs d√©ploiements est critique pour votre application. Vous devriez consid√©rer les pratiques de s√©curit√© standard comme la rotation des cl√©s et la signature.

> **Bon √† savoir :** Les applications Next.js d√©ploy√©es sur Vercel g√®rent cela automatiquement.

### Origines autoris√©es (avanc√©)

Puisque les Actions Serveur peuvent √™tre invoqu√©es dans un √©l√©ment `<form>`, cela les expose aux [attaques CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF).

En arri√®re-plan, les Actions Serveur utilisent la m√©thode `POST`, et seule cette m√©thode HTTP est autoris√©e pour les invoquer. Cela emp√™che la plupart des vuln√©rabilit√©s CSRF dans les navigateurs modernes, en particulier avec les [cookies SameSite](https://web.dev/articles/samesite-cookies-explained) √©tant la valeur par d√©faut.

Comme protection suppl√©mentaire, les Actions Serveur dans Next.js comparent √©galement l'[en-t√™te Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) √† l'[en-t√™te Host](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host) (ou `X-Forwarded-Host`). Si ceux-ci ne correspondent pas, la requ√™te sera abandonn√©e. En d'autres termes, les Actions Serveur ne peuvent √™tre invoqu√©es que sur le m√™me h√¥te que la page qui les h√©berge.

Pour les grandes applications qui utilisent des proxies invers√©s ou des architectures backend √† plusieurs couches (o√π l'API serveur diff√®re du domaine de production), il est recommand√© d'utiliser l'option de configuration [`serverActions.allowedOrigins`](/docs/app/api-reference/next-config-js/serverActions) pour sp√©cifier une liste d'origines s√ªres. L'option accepte un tableau de cha√Ænes.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

En savoir plus sur [S√©curit√© et Actions Serveur](https://nextjs.org/blog/security-nextjs-server-components-actions).

## Ressources suppl√©mentaires

Pour plus d'informations sur les Actions Serveur, consultez les documents React suivants :

- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useFormState`](https://react.dev/reference/react-dom/hooks/useFormState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
