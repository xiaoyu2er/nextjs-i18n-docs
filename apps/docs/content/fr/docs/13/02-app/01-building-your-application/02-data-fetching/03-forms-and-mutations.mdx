---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:47:01.566Z
title: Formulaires et Mutations
nav_title: Formulaires et Mutations
description: Apprenez √† g√©rer les soumissions de formulaires et les mutations de donn√©es avec Next.js.
---

{/* Le contenu de ce document est partag√© entre le routeur App et Pages. Vous pouvez utiliser le composant `<PagesOnly>Contenu</PagesOnly>` pour ajouter du contenu sp√©cifique au routeur Pages. Tout contenu partag√© ne doit pas √™tre encapsul√© dans un composant. */}

<PagesOnly>

Les formulaires vous permettent de cr√©er et mettre √† jour des donn√©es dans les applications web. Next.js offre une solution puissante pour g√©rer les soumissions de formulaires et les mutations de donn√©es en utilisant les **Routes API**.

> **Bon √† savoir :**
>
> - Nous recommanderons bient√¥t [d'adopter progressivement](/docs/app/building-your-application/upgrading/app-router-migration) le routeur App et d'utiliser les [Actions Serveur](/docs/app/building-your-application/data-fetching/forms-and-mutations#how-server-actions-work) pour g√©rer les soumissions de formulaires et les mutations de donn√©es. Les Actions Serveur vous permettent de d√©finir des fonctions serveur asynchrones qui peuvent √™tre appel√©es directement depuis vos composants, sans avoir √† cr√©er manuellement une Route API.
> - Les Routes API [ne sp√©cifient pas d'en-t√™tes CORS](https://developer.mozilla.org/docs/Web/HTTP/CORS), ce qui signifie qu'elles sont par d√©faut limit√©es √† la m√™me origine.
> - Comme les Routes API s'ex√©cutent sur le serveur, nous pouvons utiliser des valeurs sensibles (comme des cl√©s API) via les [Variables d'Environnement](/docs/pages/building-your-application/configuring/environment-variables) sans les exposer au client. Ceci est crucial pour la s√©curit√© de votre application.

</PagesOnly>

<AppOnly>

Les formulaires vous permettent de cr√©er et mettre √† jour des donn√©es dans les applications web. Next.js offre une solution puissante pour g√©rer les soumissions de formulaires et les mutations de donn√©es en utilisant les **Actions Serveur**.

<details>
  <summary>Exemples</summary>

- [Formulaire avec √âtats de Chargement et d'Erreur](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

## Fonctionnement des Actions Serveur

Avec les Actions Serveur, vous n'avez pas besoin de cr√©er manuellement des points d'API. √Ä la place, vous d√©finissez des fonctions serveur asynchrones qui peuvent √™tre appel√©es directement depuis vos composants.

> **üé• Regarder :** En savoir plus sur les formulaires et mutations avec le routeur App ‚Üí [YouTube (10 minutes)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

Les Actions Serveur peuvent √™tre d√©finies dans des Composants Serveur ou appel√©es depuis des Composants Client. D√©finir l'action dans un Composant Serveur permet au formulaire de fonctionner sans JavaScript, offrant une am√©lioration progressive.

Activez les Actions Serveur dans votre fichier `next.config.js` :

```js filename="next.config.js"
module.exports = {
  experimental: {
    serverActions: true,
  },
}
```

> **Bon √† savoir :**
>
> - Les formulaires appelant des Actions Serveur depuis des Composants Serveur peuvent fonctionner sans JavaScript.
> - Les formulaires appelant des Actions Serveur depuis des Composants Client mettront les soumissions en file d'attente si JavaScript n'est pas encore charg√©, en priorisant l'hydratation client.
> - Les Actions Serveur h√©ritent du [runtime](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) de la page ou du layout dans lequel elles sont utilis√©es.
> - Les Actions Serveur fonctionnent avec des routes enti√®rement statiques (y compris la revalidation de donn√©es avec ISR).

## Revalidation des Donn√©es en Cache

Les Actions Serveur s'int√®grent profond√©ment avec l'architecture de [cache et revalidation](/docs/app/building-your-application/caching) de Next.js. Lorsqu'un formulaire est soumis, l'Action Serveur peut mettre √† jour les donn√©es en cache et revalider toutes les cl√©s de cache qui doivent changer.

Plut√¥t que d'√™tre limit√© √† un seul formulaire par route comme dans les applications traditionnelles, les Actions Serveur permettent d'avoir plusieurs actions par route. De plus, le navigateur n'a pas besoin de s'actualiser lors de la soumission d'un formulaire. En un seul aller-retour r√©seau, Next.js peut retourner √† la fois l'UI mise √† jour et les donn√©es rafra√Æchies.

Consultez les exemples ci-dessous pour [revalider des donn√©es depuis des Actions Serveur](#revalidating-data).

</AppOnly>

## Exemples

### Formulaires Serveur Uniquement

<PagesOnly>

Avec le routeur Pages, vous devez cr√©er manuellement des points d'API pour g√©rer de mani√®re s√©curis√©e les mutations de donn√©es sur le serveur.

```ts filename="pages/api/submit.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const data = req.body
  const id = await createItem(data)
  res.status(200).json({ id })
}
```

```js filename="pages/api/submit.js" switcher
export default function handler(req, res) {
  const data = req.body
  const id = await createItem(data)
  res.status(200).json({ id })
}
```

Ensuite, appelez la Route API depuis le client avec un gestionnaire d'√©v√©nements :

```tsx filename="pages/index.tsx" switcher
import { FormEvent } from 'react'

export default function Page() {
  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData,
    })

    // G√©rer la r√©ponse si n√©cessaire
    const data = await response.json()
    // ...
  }

  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit">Soumettre</button>
    </form>
  )
}
```

```jsx filename="pages/index.jsx" switcher
export default function Page() {
  async function onSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.target)
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData,
    })

    // G√©rer la r√©ponse si n√©cessaire
    const data = await response.json()
    // ...
  }

  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit">Soumettre</button>
    </form>
  )
}
```

</PagesOnly>

<AppOnly>

Pour cr√©er un formulaire serveur uniquement, d√©finissez l'Action Serveur dans un Composant Serveur. L'action peut √™tre d√©finie en ligne avec la directive `"use server"` en haut de la fonction, ou dans un fichier s√©par√© avec la directive en haut du fichier.

```tsx filename="app/page.tsx" switcher
export default function Page() {
  async function create(formData: FormData) {
    'use server'

    // muter les donn√©es
    // revalider le cache
  }

  return <form action={create}>...</form>
}
```

```jsx filename="app/page.jsx" switcher
export default function Page() {
  async function create(formData) {
    'use server'

    // muter les donn√©es
    // revalider le cache
  }

  return <form action={create}>...</form>
}
```

> **Bon √† savoir** : `<form action={create}>` prend le type de donn√©es [FormData](https://developer.mozilla.org/docs/Web/API/FormData/FormData). Dans l'exemple ci-dessus, le FormData soumis via le [`form`](https://developer.mozilla.org/docs/Web/HTML/Element/form) HTML est accessible dans l'action serveur `create`.

### Revalidation des Donn√©es

Les Actions Serveur vous permettent d'invalider le [Cache Next.js](/docs/app/building-your-application/caching) √† la demande. Vous pouvez invalider un segment de route entier avec [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export default async function submit() {
  await submitForm()
  revalidatePath('/')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export default async function submit() {
  await submitForm()
  revalidatePath('/')
}
```

Ou invalider une r√©cup√©ration de donn√©es sp√©cifique avec une √©tiquette de cache en utilisant [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) :

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export default async function submit() {
  await addPost()
  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export default async function submit() {
  await addPost()
  revalidateTag('posts')
}
```

</AppOnly>

### Redirection

<PagesOnly>

Si vous souhaitez rediriger l'utilisateur vers une route diff√©rente apr√®s une mutation, vous pouvez utiliser [`redirect`](/docs/pages/building-your-application/routing/api-routes#response-helpers) vers n'importe quelle URL absolue ou relative :

```ts filename="pages/api/submit.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const id = await addPost()
  res.redirect(307, `/post/${id}`)
}
```

```js filename="pages/api/submit.js" switcher
export default async function handler(req, res) {
  const id = await addPost()
  res.redirect(307, `/post/${id}`)
}
```

</PagesOnly>

<AppOnly>

Si vous souhaitez rediriger l'utilisateur vers une route diff√©rente apr√®s l'ex√©cution d'une Action Serveur, vous pouvez utiliser [`redirect`](/docs/app/api-reference/functions/redirect) et n'importe quelle URL absolue ou relative :

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export default async function submit() {
  const id = await addPost()
  revalidateTag('posts') // Mettre √† jour les posts en cache
  redirect(`/post/${id}`) // Naviguer vers la nouvelle route
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export default async function submit() {
  const id = await addPost()
  revalidateTag('posts') // Mettre √† jour les posts en cache
  redirect(`/post/${id}`) // Naviguer vers la nouvelle route
}
```

</AppOnly>

### Validation de Formulaire

Nous recommandons d'utiliser la validation HTML comme `required` et `type="email"` pour une validation de formulaire basique.

Pour une validation c√¥t√© serveur plus avanc√©e, utilisez une biblioth√®que de validation de sch√©ma comme [zod](https://zod.dev/) pour valider la structure des donn√©es de formulaire analys√©es :

<PagesOnly>

```ts filename="pages/api/submit.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { z } from 'zod'

const schema = z.object({
  // ...
})

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const parsed = schema.parse(req.body)
  // ...
}
```

```js filename="pages/api/submit.js" switcher
import { z } from 'zod'

const schema = z.object({
  // ...
})

export default async function handler(req, res) {
  const parsed = schema.parse(req.body)
  // ...
}
```

</PagesOnly>

<AppOnly>

```tsx filename="app/actions.ts" switcher
import { z } from 'zod'

const schema = z.object({
  // ...
})

export default async function submit(formData: FormData) {
  const parsed = schema.parse({
    id: formData.get('id'),
  })
  // ...
}
```

```jsx filename="app/actions.js" switcher
import { z } from 'zod'

const schema = z.object({
  // ...
})

export default async function submit(formData) {
  const parsed = schema.parse({
    id: formData.get('id'),
  })
  // ...
}
```

</AppOnly>

### Affichage de l'√âtat de Chargement

<AppOnly>

Utilisez le hook `useFormStatus` pour afficher un √©tat de chargement lorsqu'un formulaire est en cours de soumission sur le serveur. Le hook `useFormStatus` ne peut √™tre utilis√© que comme enfant d'un √©l√©ment `form` utilisant une Action Serveur.

Par exemple, le bouton de soumission suivant :

```tsx filename="app/submit-button.tsx" switcher
'use client'

import { experimental_useFormStatus as useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" aria-disabled={pending}>
      Ajouter
    </button>
  )
}
```

```jsx filename="app/submit-button.jsx" switcher
'use client'

import { experimental_useFormStatus as useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" aria-disabled={pending}>
      Ajouter
    </button>
  )
}
```

`<SubmitButton />` peut ensuite √™tre utilis√© dans un formulaire avec une Action Serveur :

```tsx filename="app/page.tsx" switcher
import { SubmitButton } from '@/app/submit-button'

export default async function Home() {
  return (
    <form action={...}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

```jsx filename="app/page.jsx" switcher
import { SubmitButton } from '@/app/submit-button'

export default async function Home() {
  return (
    <form action={...}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

</AppOnly>

<PagesOnly>

Vous pouvez utiliser l'√©tat React pour afficher un √©tat de chargement lorsqu'un formulaire est en cours de soumission sur le serveur :

```tsx filename="pages/index.tsx" switcher
import React, { useState, FormEvent } from 'react'

export default function Page() {
  const [isLoading, setIsLoading] = useState<boolean>(false)

  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true) // D√©finir le chargement √† true lorsque la requ√™te commence

    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })

      // G√©rer la r√©ponse si n√©cessaire
      const data = await response.json()
      // ...
    } catch (error) {
      // G√©rer l'erreur si n√©cessaire
      console.error(error)
    } finally {
      setIsLoading(false) // D√©finir le chargement √† false lorsque la requ√™te se termine
    }
  }

  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Chargement...' : 'Soumettre'}
      </button>
    </form>
  )
}
```

```jsx filename="pages/index.jsx" switcher
import React, { useState } from 'react'

export default function Page() {
  const [isLoading, setIsLoading] = useState(false)

  async function onSubmit(event) {
    event.preventDefault()
    setIsLoading(true) // D√©finir le chargement √† true lorsque la requ√™te commence

    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })

      // G√©rer la r√©ponse si n√©cessaire
      const data = await response.json()
      // ...
    } catch (error) {
      // G√©rer l'erreur si n√©cessaire
      console.error(error)
    } finally {
      setIsLoading(false) // D√©finir le chargement √† false lorsque la requ√™te se termine
    }
  }

  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Chargement...' : 'Soumettre'}
      </button>
    </form>
  )
}
```

</PagesOnly>

### Gestion des erreurs

<AppOnly>

Les Actions Serveur peuvent √©galement retourner des [objets s√©rialisables](https://developer.mozilla.org/docs/Glossary/Serialization). Par exemple, votre Action Serveur peut g√©rer les erreurs lors de la cr√©ation d'un nouvel √©l√©ment :

```ts filename="app/actions.ts" switcher
'use server'

export async function createTodo(prevState: any, formData: FormData) {
  try {
    await createItem(formData.get('todo'))
    return revalidatePath('/')
  } catch (e) {
    return { message: 'Failed to create' }
  }
}
```

```js filename="app/actions.js" switcher
'use server'

export async function createTodo(prevState, formData) {
  try {
    await createItem(formData.get('todo'))
    return revalidatePath('/')
  } catch (e) {
    return { message: 'Failed to create' }
  }
}
```

Ensuite, depuis un Composant Client, vous pouvez lire cette valeur et afficher un message d'erreur.

```tsx filename="app/add-form.tsx" switcher
'use client'

import { experimental_useFormState as useFormState } from 'react-dom'
import { experimental_useFormStatus as useFormStatus } from 'react-dom'
import { createTodo } from '@/app/actions'

const initialState = {
  message: null,
}

function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" aria-disabled={pending}>
      Ajouter
    </button>
  )
}

export function AddForm() {
  const [state, formAction] = useFormState(createTodo, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="todo">Saisir une t√¢che</label>
      <input type="text" id="todo" name="todo" required />
      <SubmitButton />
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
    </form>
  )
}
```

```jsx filename="app/add-form.jsx" switcher
'use client'

import { experimental_useFormState as useFormState } from 'react-dom'
import { experimental_useFormStatus as useFormStatus } from 'react-dom'
import { createTodo } from '@/app/actions'

const initialState = {
  message: null,
}

function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" aria-disabled={pending}>
      Ajouter
    </button>
  )
}

export function AddForm() {
  const [state, formAction] = useFormState(createTodo, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="todo">Saisir une t√¢che</label>
      <input type="text" id="todo" name="todo" required />
      <SubmitButton />
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
    </form>
  )
}
```

</AppOnly>

<PagesOnly>

Vous pouvez utiliser l'√©tat React pour afficher un message d'erreur lorsqu'une soumission de formulaire √©choue :

```tsx filename="pages/index.tsx" switcher
import React, { useState, FormEvent } from 'react'

export default function Page() {
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)

  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)
    setError(null) // Effacer les erreurs pr√©c√©dentes lorsqu'une nouvelle requ√™te d√©marre

    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        throw new Error('√âchec de la soumission des donn√©es. Veuillez r√©essayer.')
      }

      // Traiter la r√©ponse si n√©cessaire
      const data = await response.json()
      // ...
    } catch (error) {
      // Capturer le message d'erreur √† afficher √† l'utilisateur
      setError(error.message)
      console.error(error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={onSubmit}>
        <input type="text" name="name" />
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Chargement...' : 'Soumettre'}
        </button>
      </form>
    </div>
  )
}
```

```jsx filename="pages/index.jsx" switcher
import React, { useState } from 'react'

export default function Page() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)

  async function onSubmit(event) {
    event.preventDefault()
    setIsLoading(true)
    setError(null) // Effacer les erreurs pr√©c√©dentes lorsqu'une nouvelle requ√™te d√©marre

    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        throw new Error('√âchec de la soumission des donn√©es. Veuillez r√©essayer.')
      }

      // Traiter la r√©ponse si n√©cessaire
      const data = await response.json()
      // ...
    } catch (error) {
      // Capturer le message d'erreur √† afficher √† l'utilisateur
      setError(error.message)
      console.error(error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={onSubmit}>
        <input type="text" name="name" />
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Chargement...' : 'Soumettre'}
        </button>
      </form>
    </div>
  )
}
```

</PagesOnly>

<AppOnly>

### Mises √† jour optimistes

Utilisez `useOptimistic` pour mettre √† jour l'interface utilisateur de mani√®re optimiste avant que l'Action Serveur ne se termine, plut√¥t que d'attendre la r√©ponse :

```tsx filename="app/page.tsx" switcher
'use client'

import { experimental_useOptimistic as useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<Message[]>(
    messages,
    (state: Message[], newMessage: string) => [
      ...state,
      { message: newMessage },
    ]
  )

  return (
    <div>
      {optimisticMessages.map((m, k) => (
        <div key={k}>{m.message}</div>
      ))}
      <form
        action={async (formData: FormData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Envoyer</button>
      </form>
    </div>
  )
}
```

```jsx filename="app/page.jsx" switcher
'use client'

import { experimental_useOptimistic as useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form
        action={async (formData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Envoyer</button>
      </form>
    </div>
  )
}
```

</AppOnly>

### D√©finition des cookies

<PagesOnly>

Vous pouvez d√©finir des cookies dans une Route API en utilisant la m√©thode `setHeader` sur la r√©ponse :

```ts filename="pages/api/cookie.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')
  res.status(200).send('Le cookie a √©t√© d√©fini.')
}
```

```js filename="pages/api/cookie.js" switcher
export default async function handler(req, res) {
  res.setHeader('Set-Cookie', 'username=lee; Path=/; HttpOnly')
  res.status(200).send('Le cookie a √©t√© d√©fini.')
}
```

</PagesOnly>

<AppOnly>

Vous pouvez d√©finir des cookies dans une Action Serveur en utilisant la fonction [`cookies`](/docs/app/api-reference/functions/cookies) :

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function create() {
  const cart = await createCart()
  cookies().set('cartId', cart.id)
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function create() {
  const cart = await createCart()
  cookies().set('cartId', cart.id)
}
```

</AppOnly>

### Lecture des cookies

<PagesOnly>

Vous pouvez lire les cookies dans une Route API en utilisant l'assistant de requ√™te [`cookies`](/docs/pages/building-your-application/routing/api-routes#request-helpers) :

```ts filename="pages/api/cookie.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const auth = req.cookies.authorization
  // ...
}
```

```js filename="pages/api/cookie.js" switcher
export default async function handler(req, res) {
  const auth = req.cookies.authorization
  // ...
}
```

</PagesOnly>

<AppOnly>

Vous pouvez lire les cookies dans une Action Serveur en utilisant la fonction [`cookies`](/docs/app/api-reference/functions/cookies) :

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function read() {
  const auth = cookies().get('authorization')?.value
  // ...
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function read() {
  const auth = cookies().get('authorization')?.value
  // ...
}
```

</AppOnly>

### Suppression des cookies

<PagesOnly>

Vous pouvez supprimer des cookies dans une Route API en utilisant la m√©thode `setHeader` sur la r√©ponse :

```ts filename="pages/api/cookie.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')
  res.status(200).send('Le cookie a √©t√© supprim√©.')
}
```

```js filename="pages/api/cookie.js" switcher
export default async function handler(req, res) {
  res.setHeader('Set-Cookie', 'username=; Path=/; HttpOnly; Max-Age=0')
  res.status(200).send('Le cookie a √©t√© supprim√©.')
}
```

</PagesOnly>

<AppOnly>

Vous pouvez supprimer des cookies dans une Action Serveur en utilisant la fonction [`cookies`](/docs/app/api-reference/functions/cookies) :

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function delete() {
  cookies().delete('name')
  // ...
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function delete() {
  cookies().delete('name')
  // ...
}
```

Voir [des exemples suppl√©mentaires](/docs/app/api-reference/functions/cookies#deleting-cookies) pour supprimer des cookies depuis des Actions Serveur.

</AppOnly>
