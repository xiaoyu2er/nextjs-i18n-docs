---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:10:33.074Z
title: Параллельные маршруты (Parallel Routes)
description: Одновременный рендеринг одной или нескольких страниц в одном представлении с возможностью независимой навигации. Паттерн для высокодинамичных приложений.
related:
  links:
    - app/api-reference/file-conventions/default
---

Параллельные маршруты позволяют одновременно или условно отображать одну или несколько страниц в рамках одного макета. Они полезны для высокодинамичных разделов приложения, таких как дашборды и ленты в социальных сетях.

Например, для дашборда можно использовать параллельные маршруты для одновременного отображения страниц `team` и `analytics`:

<Image
  alt="Диаграмма параллельных маршрутов"
  srcLight="/docs/light/parallel-routes.png"
  srcDark="/docs/dark/parallel-routes.png"
  width="1600"
  height="942"
/>

## Конвенция

### Слоты

Параллельные маршруты создаются с использованием именованных **слотов**. Слоты определяются с помощью соглашения `@folder`. Например, следующая структура файлов определяет два слота: `@analytics` и `@team`:

<Image
  alt="Файловая структура параллельных маршрутов"
  srcLight="/docs/light/parallel-routes-file-system.png"
  srcDark="/docs/dark/parallel-routes-file-system.png"
  width="1600"
  height="687"
/>

Слоты передаются как пропсы в общий родительский макет. Для примера выше компонент в `app/layout.js` теперь принимает пропсы слотов `@analytics` и `@team` и может отображать их параллельно вместе с пропсом `children`:

```tsx filename="app/layout.tsx" switcher
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function Layout({ children, team, analytics }) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

Однако слоты **не** являются сегментами маршрута и не влияют на структуру URL. Например, для `/@analytics/views` URL будет `/views`, так как `@analytics` — это слот. Слоты объединяются с обычным [компонентом Page](/docs/app/api-reference/file-conventions/page) для формирования итоговой страницы, связанной с сегментом маршрута. Из-за этого нельзя иметь отдельные [статические](/docs/app/getting-started/partial-prerendering#static-rendering) и [динамические](/docs/app/getting-started/partial-prerendering#dynamic-rendering) слоты на одном уровне сегмента маршрута. Если один слот динамический, все слоты на этом уровне должны быть динамическими.

> **Полезно знать**:
>
> - Пропс `children` — это неявный слот, который не нужно сопоставлять с папкой. Это означает, что `app/page.js` эквивалентен `app/@children/page.js`.

### `default.js`

Можно определить файл `default.js` для отображения в качестве резервного варианта для несопоставленных слотов при первоначальной загрузке или полной перезагрузке страницы.

Рассмотрим следующую структуру папок. Слот `@team` имеет страницу `/settings`, а `@analytics` — нет.

<Image
  alt="Несопоставленные маршруты в параллельных маршрутах"
  srcLight="/docs/light/parallel-routes-unmatched-routes.png"
  srcDark="/docs/dark/parallel-routes-unmatched-routes.png"
  width="1600"
  height="930"
/>

При переходе на `/settings` слот `@team` отобразит страницу `/settings`, сохраняя текущую активную страницу для слота `@analytics`.

При обновлении Next.js отобразит `default.js` для `@analytics`. Если `default.js` не существует, вместо него будет отображена ошибка `404`.

Кроме того, поскольку `children` — это неявный слот, также необходимо создать файл `default.js` для отображения резервного варианта для `children`, когда Next.js не может восстановить активное состояние родительской страницы.

## Поведение

По умолчанию Next.js отслеживает активное _состояние_ (или подстраницу) для каждого слота. Однако содержимое, отображаемое в слоте, зависит от типа навигации:

- [**Мягкая навигация**](/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation): При клиентской навигации Next.js выполняет [частичный рендеринг](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering), изменяя подстраницу в слоте, сохраняя активные подстраницы других слотов, даже если они не соответствуют текущему URL.
- **Жесткая навигация**: После полной загрузки страницы (обновления браузера) Next.js не может определить активное состояние для слотов, не соответствующих текущему URL. Вместо этого он отобразит файл [`default.js`](#defaultjs) для несопоставленных слотов или `404`, если `default.js` не существует.

> **Полезно знать**:
>
> - Ошибка `404` для несопоставленных маршрутов помогает убедиться, что вы случайно не отобразили параллельный маршрут на странице, для которой он не предназначен.

## Примеры

### С `useSelectedLayoutSegment(s)`

И [`useSelectedLayoutSegment`](/docs/app/api-reference/functions/use-selected-layout-segment), и [`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments) принимают параметр `parallelRoutesKey`, который позволяет читать активный сегмент маршрута в слоте.

```tsx filename="app/layout.tsx" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

```jsx filename="app/layout.js" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export default function Layout({ auth }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

Когда пользователь переходит на `app/@auth/login` (или `/login` в адресной строке), `loginSegment` будет равен строке `"login"`.

### Условные маршруты

Можно использовать параллельные маршруты для условного отображения маршрутов на основе определенных условий, таких как роль пользователя. Например, для отображения разных страниц дашборда для ролей `/admin` или `/user`:

<Image
  alt="Диаграмма условных маршрутов"
  srcLight="/docs/light/conditional-routes-ui.png"
  srcDark="/docs/dark/conditional-routes-ui.png"
  width="1600"
  height="898"
/>

```tsx filename="app/dashboard/layout.tsx" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return role === 'admin' ? admin : user
}
```

```jsx filename="app/dashboard/layout.js" switcher
import { checkUserRole } from '@/lib/auth'

export default function Layout({ user, admin }) {
  const role = checkUserRole()
  return role === 'admin' ? admin : user
}
```

### Группы вкладок

Можно добавить `layout` внутри слота, чтобы позволить пользователям независимо перемещаться по слоту. Это полезно для создания вкладок.

Например, слот `@analytics` имеет две подстраницы: `/page-views` и `/visitors`.

<Image
  alt="Слот analytics с двумя подстраницами и макетом"
  srcLight="/docs/light/parallel-routes-tab-groups.png"
  srcDark="/docs/dark/parallel-routes-tab-groups.png"
  width="1600"
  height="768"
/>

Внутри `@analytics` создайте файл [`layout`](/docs/app/api-reference/file-conventions/layout) для совместного использования вкладок между двумя страницами:

```tsx filename="app/@analytics/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Просмотры страниц</Link>
        <Link href="/visitors">Посетители</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

```jsx filename="app/@analytics/layout.js" switcher
import Link from 'next/link'

export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Просмотры страниц</Link>
        <Link href="/visitors">Посетители</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

### Модальные окна

Параллельные маршруты можно использовать вместе с [перехватывающими маршрутами (Intercepting Routes)](/docs/app/api-reference/file-conventions/intercepting-routes) для создания модальных окон с поддержкой глубоких ссылок. Это позволяет решить распространенные проблемы при создании модальных окон, такие как:

- **Совместное использование содержимого модального окна через URL**.
- **Сохранение контекста** при обновлении страницы вместо закрытия модального окна.
- **Закрытие модального окна при навигации назад** вместо перехода к предыдущему маршруту.
- **Повторное открытие модального окна при навигации вперед**.

Рассмотрим следующий UI-паттерн, где пользователь может открыть модальное окно входа из макета с помощью клиентской навигации или получить доступ к отдельной странице `/login`:

<Image
  alt="Диаграмма параллельных маршрутов"
  srcLight="/docs/light/parallel-routes-auth-modal.png"
  srcDark="/docs/dark/parallel-routes-auth-modal.png"
  width="1600"
  height="687"
/>

Для реализации этого паттерна сначала создайте маршрут `/login`, который отображает **основную** страницу входа.

<Image
  alt="Диаграмма параллельных маршрутов"
  srcLight="/docs/light/parallel-routes-modal-login-page.png"
  srcDark="/docs/dark/parallel-routes-modal-login-page.png"
  width="1600"
  height="768"
/>

```tsx filename="app/login/page.tsx" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

```jsx filename="app/login/page.js" switcher
import { Login } from '@/app/ui/login'

export default function Page() {
  return <Login />
}
```

Затем внутри слота `@auth` добавьте файл [`default.js`](/docs/app/api-reference/file-conventions/default), который возвращает `null`. Это гарантирует, что модальное окно не отображается, когда оно не активно.

```tsx filename="app/@auth/default.tsx" switcher
export default function Default() {
  return null
}
```

```jsx filename="app/@auth/default.js" switcher
export default function Default() {
  return null
}
```

Внутри слота `@auth` перехватите маршрут `/login`, обновив папку `/(.)login`. Импортируйте компонент `<Modal>` и его дочерние элементы в файл `/(.)login/page.tsx`:

```tsx filename="app/@auth/(.)login/page.tsx" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

```jsx filename="app/@auth/(.)login/page.js" switcher
import { Modal } from '@/app/ui/modal'
import { Login } from '@/app/ui/login'

export default function Page() {
  return (
    <Modal>
      <Login />
    </Modal>
  )
}
```

> **Полезно знать:**
>
> - Соглашение, используемое для перехвата маршрута (например, `(.)`), зависит от структуры вашей файловой системы. См. [Конвенцию перехватывающих маршрутов](/docs/app/api-reference/file-conventions/intercepting-routes#convention).
> - Разделяя функциональность `<Modal>` и содержимое модального окна (`<Login>`), можно гарантировать, что любое содержимое внутри модального окна, например [формы](/docs/app/guides/forms), будет серверными компонентами. См. [Чередование клиентских и серверных компонентов](/docs/app/getting-started/server-and-client-components#examples#supported-pattern-passing-server-components-to-client-components-as-props) для получения дополнительной информации.

#### Открытие модального окна

Теперь можно использовать маршрутизатор Next.js для открытия и закрытия модального окна. Это гарантирует правильное обновление URL при открытии модального окна и при навигации назад и вперед.

Чтобы открыть модальное окно, передайте слот `@auth` как пропс в родительский макет и отобразите его вместе с пропсом `children`.

```tsx filename="app/layout.tsx" switcher
import Link from 'next/link'

export default function Layout({
  auth,
  children,
}: {
  auth: React.ReactNode
  children: React.ReactNode
}) {
  return (
    <>
      <nav>
        <Link href="/login">Открыть модальное окно</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

```jsx filename="app/layout.js" switcher
import Link from 'next/link'

export default function Layout({ auth, children }) {
  return (
    <>
      <nav>
        <Link href="/login">Открыть модальное окно</Link>
      </nav>
      <div>{auth}</div>
      <div>{children}</div>
    </>
  )
}
```

Когда пользователь нажимает на `<Link>`, модальное окно откроется вместо перехода на страницу `/login`. Однако при обновлении или первоначальной загрузке переход на `/login` приведет пользователя на основную страницу входа.

#### Закрытие модального окна

Можно закрыть модальное окно, вызвав `router.back()` или используя компонент `Link`.

```tsx filename="app/ui/modal.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }: { children: React.ReactNode }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        Закрыть модальное окно
      </button>
      <div>{children}</div>
    </>
  )
}
```

```jsx filename="app/ui/modal.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export function Modal({ children }) {
  const router = useRouter()

  return (
    <>
      <button
        onClick={() => {
          router.back()
        }}
      >
        Закрыть модальное окно
      </button>
      <div>{children}</div>
    </>
  )
}
```

При использовании компонента `Link` для перехода со страницы, которая не должна больше отображать слот `@auth`, необходимо убедиться, что параллельный маршрут соответствует компоненту, который возвращает `null`. Например, при переходе обратно на корневую страницу создаем компонент `@auth/page.tsx`:

```tsx filename="app/ui/modal.tsx" switcher
import Link from 'next/link'

export function Modal({ children }: { children: React.ReactNode }) {
  return (
    <>
      <Link href="/">Закрыть модальное окно</Link>
      <div>{children}</div>
    </>
  )
}
```

```jsx filename="app/ui/modal.js" switcher
import Link from 'next/link'

export function Modal({ children }) {
  return (
    <>
      <Link href="/">Закрыть модальное окно</Link>
      <div>{children}</div>
    </>
  )
}
```

```tsx filename="app/@auth/page.tsx" switcher
export default function Page() {
  return null
}
```

```jsx filename="app/@auth/page.js" switcher
export default function Page() {
  return null
}
```

Или при переходе на любую другую страницу (например, `/foo`, `/foo/bar` и т. д.) можно использовать слот catch-all:

```tsx filename="app/@auth/[...catchAll]/page.tsx" switcher
export default function CatchAll() {
  return null
}
```

```jsx filename="app/@auth/[...catchAll]/page.js" switcher
export default function CatchAll() {
  return null
}
```

> **Полезно знать:**
>
> - Мы используем маршрут catch-all в слоте `@auth` для закрытия модального окна из-за поведения параллельных маршрутов(#behavior). Поскольку клиентская навигация на маршрут, который больше не соответствует слоту, будет оставаться видимой, нам нужно сопоставить слот с маршрутом, который возвращает `null`, чтобы закрыть модальное окно.
> - Другие примеры могут включать открытие модального окна с фотографией в галерее при наличии отдельной страницы `/photo/[id]` или открытие корзины покупок в боковом модальном окне.
> - [Посмотрите пример](https://github.com/vercel-labs/nextgram) модальных окон с перехватывающими и параллельными маршрутами.

### Загрузка и обработка ошибок

Параллельные маршруты могут передаваться независимо, что позволяет определять независимые состояния ошибок и загрузки для каждого маршрута:

<Image
  alt="Параллельные маршруты позволяют настраивать состояния ошибок и загрузки"
  srcLight="/docs/light/parallel-routes-cinematic-universe.png"
  srcDark="/docs/dark/parallel-routes-cinematic-universe.png"
  width="1600"
  height="1218"
/>

См. документацию по [UI загрузки](/docs/app/building-your-application/routing/loading-ui-and-streaming) и [обработке ошибок](/docs/app/getting-started/error-handling) для получения дополнительной информации.