---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:13:56.908Z
title: Link
description: Обеспечивает быструю навигацию на стороне клиента с помощью встроенного компонента `next/link`.
---

{/* Содержание этого документа используется как в App Router, так и в Pages Router. Вы можете использовать компонент `<PagesOnly>Content</PagesOnly>` для добавления контента, специфичного для Pages Router. Любой общий контент не должен быть обёрнут в компонент. */}

`<Link>` — это React-компонент, расширяющий HTML-элемент `<a>` для предоставления [предварительной загрузки (prefetching)](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) и навигации между маршрутами на стороне клиента. Это основной способ перехода между маршрутами в Next.js.

Базовое использование:

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</PagesOnly>

## Справочник

Следующие пропсы могут быть переданы компоненту `<Link>`:

<PagesOnly>

| Пропс                              | Пример                   | Тип               | Обязательный |
| ---------------------------------- | ------------------------ | ----------------- | ------------ |
| [`href`](#href-required)           | `href="/dashboard"`      | String или Object | Да           |
| [`replace`](#replace)              | `replace={false}`        | Boolean           | -            |
| [`scroll`](#scroll)                | `scroll={false}`         | Boolean           | -            |
| [`prefetch`](#prefetch)            | `prefetch={false}`       | Boolean           | -            |
| [`legacyBehavior`](#legacybehavior)| `legacyBehavior={true}`  | Boolean           | -            |
| [`passHref`](#passhref)            | `passHref={true}`        | Boolean           | -            |
| [`shallow`](#shallow)              | `shallow={false}`        | Boolean           | -            |
| [`locale`](#locale)                | `locale="fr"`            | String или Boolean| -            |
| [`onNavigate`](#onnavigate)        | `onNavigate={(e) => {}}` | Function          | -            |

</PagesOnly>

<AppOnly>

| Пропс                      | Пример                   | Тип              | Обязательный |
| -------------------------- | ------------------------ | ---------------- | ------------ |
| [`href`](#href-required)   | `href="/dashboard"`      | String или Object| Да           |
| [`replace`](#replace)      | `replace={false}`        | Boolean          | -            |
| [`scroll`](#scroll)        | `scroll={false}`         | Boolean          | -            |
| [`prefetch`](#prefetch)    | `prefetch={false}`       | Boolean или null | -            |
| [`onNavigate`](#onnavigate)| `onNavigate={(e) => {}}` | Function         | -            |

</AppOnly>

> **Полезно знать**: Атрибуты тега `<a>`, такие как `className` или `target="_blank"`, могут быть добавлены к `<Link>` как пропсы и будут переданы базовому элементу `<a>`.

### `href` (обязательный)

Путь или URL для перехода.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

// Переход на /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

// Переход на /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

// Переход на /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

// Переход на /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</PagesOnly>

### `replace`

**По умолчанию `false`.** Когда установлено в `true`, `next/link` заменит текущее состояние истории вместо добавления нового URL в [стек истории браузера](https://developer.mozilla.org/docs/Web/API/History_API).

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `scroll`

**По умолчанию `true`.** Поведение прокрутки по умолчанию для `<Link>` в Next.js **сохраняет позицию прокрутки**, аналогично тому, как браузеры обрабатывают навигацию назад и вперёд. При переходе на новую [Страницу (Page)](/docs/app/api-reference/file-conventions/page), позиция прокрутки останется той же, пока Страница видна в области просмотра. Однако, если Страница не видна в области просмотра, Next.js прокрутит к верхней части первого элемента Страницы.

Когда `scroll = {false}`, Next.js не будет пытаться прокрутить к первому элементу Страницы.

> **Полезно знать**: Next.js проверяет `scroll: false` перед управлением поведением прокрутки. Если прокрутка включена, он идентифицирует соответствующий DOM-узел для навигации и проверяет каждый элемент верхнего уровня. Все не прокручиваемые элементы и те, которые не имеют отрендеренного HTML, пропускаются, включая элементы с фиксированным или sticky позиционированием, а также невидимые элементы, такие как те, которые вычисляются с помощью `getBoundingClientRect`. Next.js затем продолжает проверять соседние элементы, пока не найдёт прокручиваемый элемент, видимый в области просмотра.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `prefetch`

<AppOnly>

Предварительная загрузка (prefetching) происходит, когда компонент `<Link />` попадает в область видимости пользователя (изначально или при прокрутке). Next.js предварительно загружает связанный маршрут (указанный в `href`) и его данные в фоновом режиме для улучшения производительности навигации на стороне клиента. Если предварительно загруженные данные устарели к моменту наведения курсора на `<Link />`, Next.js попытается загрузить их снова. **Предварительная загрузка работает только в production-режиме**.

Для пропа `prefetch` можно передать следующие значения:

- **`null` (по умолчанию)**: Поведение предварительной загрузки зависит от того, является ли маршрут статическим или динамическим. Для статических маршрутов будет предзагружен весь маршрут (включая все его данные). Для динамических маршрутов будет предзагружена часть маршрута до ближайшего сегмента с границей [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- `true`: Весь маршрут будет предзагружен как для статических, так и для динамических маршрутов.
- `false`: Предварительная загрузка не будет происходить ни при попадании в область видимости, ни при наведении.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

Предварительная загрузка (prefetching) происходит, когда компонент `<Link />` попадает в область видимости пользователя (изначально или при прокрутке). Next.js предварительно загружает связанный маршрут (указанный в `href`) и данные в фоновом режиме для улучшения производительности навигации на стороне клиента. **Предварительная загрузка работает только в production-режиме**.

Для пропа `prefetch` можно передать следующие значения:

- **`true` (по умолчанию)**: Весь маршрут и его данные будут предзагружены.
- `false`: Предварительная загрузка не будет происходить при попадании в область видимости, но будет происходить при наведении. Если вы хотите полностью отключить загрузку при наведении, рассмотрите использование тега `<a>` или [постепенный переход](/docs/app/guides/migrating/app-router-migration) на App Router, который также позволяет отключать предзагрузку при наведении.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

### `legacyBehavior`

> **Предупреждение**: Проп `legacyBehavior` будет удалён в Next.js v16. Для перехода на новое поведение `<Link>`, удалите все теги `<a>`, используемые как дочерние элементы `<Link>`. Доступен [кодмод](/docs/app/guides/upgrading/codemods#new-link) для автоматического обновления кодовой базы.

Начиная с версии 13, элемент `<a>` больше не требуется как дочерний элемент компонента `<Link>`. Если вам всё ещё нужно старое поведение для совместимости, вы можете добавить проп `legacyBehavior`.

> **Полезно знать**: когда `legacyBehavior` не установлен в `true`, все свойства [`anchor`](https://developer.mozilla.org/docs/Web/HTML/Element/a) тега могут быть переданы в `next/link`, такие как `className`, `onClick` и т.д.

### `passHref`

Принудительно передаёт свойство `href` дочернему элементу. По умолчанию `false`. Подробнее см. в примере [передачи функционального компонента](#nesting-a-functional-component).

### `shallow`

Обновляет путь текущей страницы без повторного выполнения [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props), [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props) или [`getInitialProps`](/docs/pages/api-reference/functions/get-initial-props). По умолчанию `false`.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

### `locale`

Активная локаль автоматически добавляется. `locale` позволяет указать другую локаль. Когда `false`, `href` должен включать локаль, так как поведение по умолчанию отключено.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Поведение по умолчанию: локаль добавляется */}
      <Link href="/dashboard">Dashboard (с локалью)</Link>

      {/* Отключение добавления локали */}
      <Link href="/dashboard" locale={false}>
        Dashboard (без локали)
      </Link>

      {/* Указание другой локали */}
      <Link href="/dashboard" locale="fr">
        Dashboard (на французском)
      </Link>
    </>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Поведение по умолчанию: локаль добавляется */}
      <Link href="/dashboard">Dashboard (с локалью)</Link>

      {/* Отключение добавления локали */}
      <Link href="/dashboard" locale={false}>
        Dashboard (без локали)
      </Link>

      {/* Указание другой локали */}
      <Link href="/dashboard" locale="fr">
        Dashboard (на французском)
      </Link>
    </>
  )
}
```

</PagesOnly>

### `onNavigate`

Обработчик событий, вызываемый во время навигации на стороне клиента. Обработчик получает объект события, включающий метод `preventDefault()`, позволяющий отменить навигацию при необходимости.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Выполняется только во время SPA-навигации
        console.log('Навигация...')

        // Опционально отменить навигацию
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Выполняется только во время SPA-навигации
        console.log('Навигация...')

        // Опционально отменить навигацию
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

> **Полезно знать**: Хотя `onClick` и `onNavigate` могут показаться похожими, они служат разным целям. `onClick` выполняется для всех событий клика, в то время как `onNavigate` только во время навигации на стороне клиента. Некоторые ключевые различия:
>
> - При использовании модификаторов клавиш (`Ctrl`/`Cmd` + Click), `onClick` выполняется, но `onNavigate` нет, так как Next.js предотвращает стандартную навигацию для новых вкладок.
> - Внешние URL не вызовут `onNavigate`, так как он предназначен только для навигации на стороне клиента и в пределах одного источника.
> - Ссылки с атрибутом `download` будут работать с `onClick`, но не с `onNavigate`, так как браузер будет рассматривать URL как загрузку.

## Примеры

Следующие примеры демонстрируют использование компонента `<Link>` в различных сценариях.

<AppOnly>

### Ссылки на динамические сегменты

При ссылке на [динамические сегменты](/docs/app/api-reference/file-conventions/dynamic-routes), вы можете использовать [шаблонные литералы и интерполяцию](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals) для генерации списка ссылок. Например, для генерации списка постов блога:

```tsx filename="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

### Проверка активных ссылок

Вы можете использовать [`usePathname()`](/docs/app/api-reference/functions/use-pathname), чтобы определить, активна ли ссылка. Например, чтобы добавить класс к активной ссылке, можно проверить, совпадает ли текущий `pathname` с `href` ссылки:

```tsx filename="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

```jsx filename="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

### Прокрутка к `id`

Если вы хотите прокрутить страницу к определённому `id` при навигации, можно добавить к URL хэш-ссылку с `#` или передать её в проп `href`. Это возможно, так как `<Link>` рендерится в элемент `<a>`.

```jsx
<Link href="/dashboard#settings">Settings</Link>

// Вывод
<a href="/dashboard#settings">Settings</a>
```

> **Полезно знать**:
>
> - Next.js автоматически прокрутит страницу к [Page](/docs/app/api-reference/file-conventions/page), если она не видна в области просмотра при навигации.

</AppOnly>

### Ссылки на динамические сегменты маршрутов

Для [динамических сегментов маршрутов](/docs/app/api-reference/file-conventions/dynamic-routes) удобно использовать шаблонные литералы для создания пути ссылки.

<PagesOnly>

Например, можно сгенерировать список ссылок на динамический маршрут `pages/blog/[slug].js`:

```tsx filename="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</PagesOnly>

<AppOnly>

Например, можно сгенерировать список ссылок на динамический маршрут `app/blog/[slug]/page.js`:

```tsx filename="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</AppOnly>

### Если дочерний элемент — это кастомный компонент, оборачивающий `<a>`

<AppOnly>

Если дочерний элемент `Link` — это кастомный компонент, оборачивающий `<a>`, необходимо добавить `passHref` в `Link`. Это особенно важно при использовании библиотек вроде [styled-components](https://styled-components.com/). Без этого тег `<a>` не получит атрибут `href`, что ухудшит доступность сайта и может повлиять на SEO. Если вы используете [ESLint](/docs/pages/api-reference/config/eslint), встроенное правило `next/link-passhref` поможет убедиться в корректном использовании `passHref`.

</AppOnly>

<PagesOnly>

Если дочерний элемент `Link` — это кастомный компонент, оборачивающий `<a>`, необходимо добавить `passHref` в `Link`. Это особенно важно при использовании библиотек вроде [styled-components](https://styled-components.com/). Без этого тег `<a>` не получит атрибут `href`, что ухудшит доступность сайта и может повлиять на SEO. Если вы используете [ESLint](/docs/pages/api-reference/config/eslint), встроенное правило `next/link-passhref` поможет убедиться в корректном использовании `passHref`.

</PagesOnly>

```tsx filename="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Создаём кастомный компонент, оборачивающий <a>
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

```jsx filename="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Создаём кастомный компонент, оборачивающий <a>
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

- Если вы используете [emotion](https://emotion.sh/) с JSX pragma (`@jsx jsx`), необходимо использовать `passHref`, даже если вы напрямую используете `<a>`.
- Компонент должен поддерживать свойство `onClick` для корректной навигации.

### Вложение функционального компонента

Если дочерний элемент `Link` — это функциональный компонент, помимо `passHref` и `legacyBehavior`, необходимо обернуть компонент в [`React.forwardRef`](https://react.dev/reference/react/forwardRef):

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Определяем тип пропсов для MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Используем React.ForwardRefRenderFunction для типизации ref
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Оборачиваем компонент в React.forwardRef
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` и `ref` должны быть переданы в DOM-элемент
// для корректной обработки
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Добавляем displayName для компонента (полезно при отладке)
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Определяем тип пропсов для MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Используем React.ForwardRefRenderFunction для типизации ref
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Оборачиваем компонент в React.forwardRef
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` и `ref` должны быть переданы в DOM-элемент
// для корректной обработки
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Добавляем displayName для компонента (полезно при отладке)
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

### Передача объекта URL

`Link` также может принимать объект URL, который автоматически преобразуется в строку:

```tsx filename="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

В примере выше создаются ссылки на:

- Предопределённый маршрут: `/about?name=test`
- [Динамический маршрут](/docs/app/api-reference/file-conventions/dynamic-routes): `/blog/my-post`

Можно использовать все свойства, описанные в [документации Node.js URL module](https://nodejs.org/api/url.html#url_url_strings_and_url_objects).

</PagesOnly>

### Замена URL вместо добавления

По умолчанию компонент `Link` добавляет новый URL в стек истории (`push`). Можно использовать проп `replace`, чтобы избежать добавления новой записи:

<AppOnly>

```tsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</PagesOnly>

### Отключение прокрутки к верху страницы

<AppOnly>

По умолчанию `<Link>` в Next.js **сохраняет позицию прокрутки**, аналогично поведению браузера при навигации назад/вперёд. При переходе на новую [Page](/docs/app/api-reference/file-conventions/page) позиция прокрутки останется прежней, если страница видна в области просмотра.

Однако если страница не видна в области просмотра, Next.js прокрутит к верхней части первого элемента Page. Чтобы отключить это поведение, можно передать `scroll={false}` в `<Link>` или `scroll: false` в `router.push()`/`router.replace()`.

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

Использование `router.push()` или `router.replace()`:

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

По умолчанию `Link` прокручивает страницу к верху. При наличии хэша прокрутка выполняется к указанному id, как в обычном теге `<a>`. Чтобы отключить прокрутку к верху/хэшу, можно добавить `scroll={false}` в `Link`:

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</PagesOnly>

### Предварительная загрузка ссылок в Middleware

Часто [Middleware](/docs/app/building-your-application/routing/middleware) используется для аутентификации или других целей, связанных с перезаписью пользователя на другую страницу. Чтобы компонент `<Link />` правильно предварительно загружал ссылки с перезаписью через Middleware, необходимо указать Next.js как URL для отображения, так и URL для предварительной загрузки. Это нужно, чтобы избежать лишних запросов к middleware для определения правильного маршрута для предварительной загрузки.

Например, если вы хотите обслуживать маршрут `/dashboard` с авторизованным и публичным представлением, вы можете добавить следующее в ваш Middleware для перенаправления пользователя на нужную страницу:

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

В этом случае вам следует использовать следующий код в вашем компоненте `<Link />`:

<AppOnly>

```tsx filename="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ваш хук аутентификации

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ваш хук аутентификации

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ваш хук аутентификации

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ваш хук аутентификации

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

> **Полезно знать**: Если вы используете [Динамические маршруты](/docs/app/api-reference/file-conventions/dynamic-routes), вам нужно адаптировать пропсы `as` и `href`. Например, если у вас есть динамический маршрут `/dashboard/authed/[user]`, который вы хотите представить иначе через middleware, вы напишете: `<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>`.

</PagesOnly>

### Блокировка навигации

Вы можете использовать проп `onNavigate` для блокировки навигации при выполнении определенных условий, например, когда форма содержит несохраненные изменения. Когда вам нужно заблокировать навигацию в нескольких компонентах вашего приложения (например, предотвратить переход по любой ссылке во время редактирования формы), React Context предоставляет удобный способ разделения этого состояния блокировки. Сначала создайте контекст для отслеживания состояния блокировки навигации:

```tsx filename="app/contexts/navigation-blocker.tsx" switcher
'use client'

import { createContext, useState, useContext } from 'react'

interface NavigationBlockerContextType {
  isBlocked: boolean
  setIsBlocked: (isBlocked: boolean) => void
}

export const NavigationBlockerContext =
  createContext<NavigationBlockerContextType>({
    isBlocked: false,
    setIsBlocked: () => {},
  })

export function NavigationBlockerProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

```jsx filename="app/contexts/navigation-blocker.js" switcher
'use client'

import { createContext, useState, useContext } from 'react'

export const NavigationBlockerContext = createContext({
  isBlocked: false,
  setIsBlocked: () => {},
})

export function NavigationBlockerProvider({ children }) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

Создайте компонент формы, использующий контекст:

```tsx filename="app/components/form.tsx" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

```jsx filename="app/components/form.js" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

Создайте пользовательский компонент Link, блокирующий навигацию:

```tsx filename="app/components/custom-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

interface CustomLinkProps extends React.ComponentProps<typeof Link> {
  children: React.ReactNode
}

export function CustomLink({ children, ...props }: CustomLinkProps) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('У вас есть несохраненные изменения. Все равно уйти?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

```jsx filename="app/components/custom-link.js" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

export function CustomLink({ children, ...props }) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('У вас есть несохраненные изменения. Все равно уйти?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

Создайте компонент навигации:

```tsx filename="app/components/nav.tsx" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

```jsx filename="app/components/nav.js" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

Наконец, оберните ваше приложение провайдером `NavigationBlockerProvider` в корневом layout и используйте компоненты на вашей странице:

```tsx filename="app/layout.tsx" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

Затем используйте компоненты `Nav` и `Form` на вашей странице:

```tsx filename="app/page.tsx" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

Когда пользователь попытается перейти по ссылке `CustomLink` при наличии несохраненных изменений в форме, ему будет предложено подтвердить действие перед уходом.

## История версий

| Версия    | Изменения                                                                                                                                                                      |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.3.0` | Добавлен API `onNavigate`                                                                                                                                                         |
| `v13.0.0` | Больше не требует дочернего тега `<a>`. Предоставляется [codemod](/docs/app/guides/upgrading/codemods#remove-a-tags-from-link-components) для автоматического обновления кодовой базы. |
| `v10.0.0` | Пропсы `href`, указывающие на динамический маршрут, автоматически разрешаются и больше не требуют пропа `as`.                                                                      |
| `v8.0.0`  | Улучшена производительность предварительной загрузки.                                                                                                                                            |
| `v1.0.0`  | Введен `next/link`.                                                                                                                                                      |
