---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:03:08.351Z
title: Кэширование в Next.js
nav_title: Кэширование
description: Обзор механизмов кэширования в Next.js.
---

Next.js улучшает производительность вашего приложения и снижает затраты за счёт кэширования результатов рендеринга и запросов данных. На этой странице представлено подробное описание механизмов кэширования в Next.js, API для их настройки и их взаимодействия между собой.

> **Полезно знать**: Эта страница поможет вам понять внутреннюю работу Next.js, но **не** является обязательной для продуктивной работы. Большинство эвристик кэширования Next.js определяются использованием API и имеют настройки по умолчанию для оптимальной производительности с нулевой или минимальной конфигурацией. Если вы хотите сразу перейти к примерам, [начните здесь](/docs/app/getting-started/fetching-data).

## Обзор

Вот краткий обзор различных механизмов кэширования и их назначения:

| Механизм                                   | Что кэшируется               | Где    | Назначение                                      | Длительность                   |
| ------------------------------------------- | ---------------------------- | ------ | ----------------------------------------------- | ------------------------------- |
| [Мемоизация запросов](#request-memoization) | Возвращаемые значения функций | Сервер | Повторное использование данных в дереве React-компонентов | На время жизни запроса          |
| [Кэш данных](#data-cache)                   | Данные                       | Сервер | Хранение данных между запросами пользователей и деплоями | Постоянно (можно перевалидировать) |
| [Полный кэш маршрута](#full-route-cache)    | HTML и RSC-полезная нагрузка | Сервер | Снижение затрат на рендеринг и повышение производительности | Постоянно (можно перевалидировать) |
| [Кэш роутера](#client-side-router-cache)    | RSC-полезная нагрузка        | Клиент | Уменьшение количества запросов к серверу при навигации | Сессия пользователя или по времени |

По умолчанию Next.js кэширует максимально возможное количество данных для повышения производительности и снижения затрат. Это означает, что маршруты **рендерятся статически**, а запросы данных **кэшируются**, если вы не отказались от этого. На диаграмме ниже показано поведение кэширования по умолчанию: когда маршрут рендерится статически во время сборки и при первом посещении статического маршрута.

<Image
  alt="Диаграмма, показывающая поведение кэширования по умолчанию в Next.js для четырёх механизмов, с HIT, MISS и SET во время сборки и при первом посещении маршрута."
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

Поведение кэширования меняется в зависимости от того, рендерится ли маршрут статически или динамически, кэшируются ли данные или нет, и является ли запрос частью первого посещения или последующей навигации. В зависимости от вашего случая использования вы можете настроить поведение кэширования для отдельных маршрутов и запросов данных.

## Мемоизация запросов

Next.js расширяет API [`fetch`](#fetch), чтобы автоматически **мемоизировать** запросы с одинаковым URL и параметрами. Это означает, что вы можете вызывать функцию fetch для одних и тех же данных в нескольких местах дерева React-компонентов, выполняя её только один раз.

<Image
  alt="Дедуплицированные Fetch-запросы"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

Например, если вам нужны одни и те же данные в рамках маршрута (например, в Layout, Page и нескольких компонентах), вам не нужно получать данные на верхнем уровне дерева и передавать пропсы между компонентами. Вместо этого вы можете получать данные в компонентах, которые в них нуждаются, не беспокоясь о производительности из-за выполнения нескольких одинаковых запросов по сети.

```tsx filename="app/example.tsx" switcher
async function getItem() {
  // Функция `fetch` автоматически мемоизируется, и результат
  // кэшируется
  const res = await fetch('https://.../item/1')
  return res.json()
}

// Эта функция вызывается дважды, но выполняется только первый раз
const item = await getItem() // cache MISS

// Второй вызов может быть в любом месте вашего маршрута
const item = await getItem() // cache HIT
```

```jsx filename="app/example.js" switcher
async function getItem() {
  // Функция `fetch` автоматически мемоизируется, и результат
  // кэшируется
  const res = await fetch('https://.../item/1')
  return res.json()
}

// Эта функция вызывается дважды, но выполняется только первый раз
const item = await getItem() // cache MISS

// Второй вызов может быть в любом месте вашего маршрута
const item = await getItem() // cache HIT
```

**Как работает мемоизация запросов**

<Image
  alt="Диаграмма, показывающая, как работает мемоизация fetch во время рендеринга React."
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- Во время рендеринга маршрута при первом вызове определённого запроса его результата не будет в памяти, и это будет `MISS` в кэше.
- Поэтому функция будет выполнена, данные будут получены из внешнего источника, и результат будет сохранён в памяти.
- Последующие вызовы функции с тем же запросом в рамках того же прохода рендеринга будут `HIT` в кэше, и данные будут возвращены из памяти без выполнения функции.
- После завершения рендеринга маршрута память "сбрасывается", и все записи мемоизации запросов очищаются.

> **Полезно знать**:
>
> - Мемоизация запросов — это особенность React, а не Next.js. Она включена сюда, чтобы показать, как она взаимодействует с другими механизмами кэширования.
> - Мемоизация применяется только к методу `GET` в запросах `fetch`.
> - Мемоизация применяется только к дереву React-компонентов, это означает:
>   - Она применяется к запросам `fetch` в `generateMetadata`, `generateStaticParams`, Layouts, Pages и других Server Components.
>   - Она не применяется к запросам `fetch` в Route Handlers, так как они не являются частью дерева React-компонентов.
> - Для случаев, когда `fetch` не подходит (например, некоторые клиенты баз данных, CMS или GraphQL), вы можете использовать [функцию `cache` React](#react-cache-function) для мемоизации функций.

### Длительность

Кэш существует в течение времени жизни серверного запроса, пока дерево React-компонентов не завершит рендеринг.

### Перевалидация

Поскольку мемоизация не распространяется между серверными запросами и применяется только во время рендеринга, нет необходимости её перевалидировать.

### Отказ от кэширования

Мемоизация применяется только к методу `GET` в запросах `fetch`, другие методы, такие как `POST` и `DELETE`, не мемоизируются. Это поведение по умолчанию является оптимизацией React, и мы не рекомендуем от него отказываться.

Для управления отдельными запросами вы можете использовать свойство [`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal) из [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController). Однако это не отключит мемоизацию запросов, а скорее прервёт выполняющиеся запросы.

```js filename="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Кэш данных

Next.js имеет встроенный кэш данных, который **сохраняет** результаты запросов данных между входящими **серверными запросами** и **деплоями**. Это возможно благодаря тому, что Next.js расширяет нативный API `fetch`, позволяя каждому запросу на сервере устанавливать собственную семантику постоянного кэширования.

> **Полезно знать**: В браузере опция `cache` в `fetch` указывает, как запрос будет взаимодействовать с HTTP-кэшем браузера, в Next.js опция `cache` указывает, как серверный запрос будет взаимодействовать с серверным кэшем данных.

Вы можете использовать опции [`cache`](#fetch-optionscache) и [`next.revalidate`](#fetch-optionsnextrevalidate) в `fetch` для настройки поведения кэширования.

**Как работает кэш данных**

<Image
  alt="Диаграмма, показывающая, как кэшированные и некэшированные запросы fetch взаимодействуют с кэшем данных. Кэшированные запросы сохраняются в кэше данных и мемоизируются, некэшированные запросы получаются из источника данных, не сохраняются в кэше данных и мемоизируются."
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- При первом вызове запроса `fetch` с опцией `'force-cache'` во время рендеринга Next.js проверяет кэш данных на наличие кэшированного ответа.
- Если кэшированный ответ найден, он немедленно возвращается и [мемоизируется](#request-memoization).
- Если кэшированный ответ не найден, запрос выполняется к источнику данных, результат сохраняется в кэше данных и мемоизируется.
- Для некэшированных данных (например, когда опция `cache` не определена или используется `{ cache: 'no-store' }`), результат всегда получается из источника данных и мемоизируется.
- Независимо от того, кэшируются данные или нет, запросы всегда мемоизируются, чтобы избежать дублирования запросов на одни и те же данные во время прохода рендеринга React.

> **Различия между кэшем данных и мемоизацией запросов**
>
> Хотя оба механизма кэширования помогают улучшить производительность за счёт повторного использования кэшированных данных, кэш данных является постоянным между входящими запросами и деплоями, тогда как мемоизация длится только в течение времени жизни запроса.

### Длительность

Кэш данных сохраняется между входящими запросами и деплоями, если вы не выполните перевалидацию или не откажетесь от кэширования.

### Перевалидация

Кэшированные данные можно перевалидировать двумя способами:

- **Перевалидация по времени**: Перевалидировать данные после определённого промежутка времени и нового запроса. Это полезно для данных, которые изменяются редко, и свежесть не так критична.
- **Перевалидация по запросу**: Перевалидировать данные на основе события (например, отправки формы). Перевалидация по запросу может использовать теги или пути для перевалидации групп данных одновременно. Это полезно, когда вы хотите убедиться, что самые свежие данные отображаются как можно скорее (например, при обновлении контента из вашей headless CMS).

#### Перевалидация по времени

Для перевалидации данных через определённые интервалы времени вы можете использовать опцию `next.revalidate` в `fetch`, чтобы установить время жизни ресурса в кэше (в секундах).

```js
// Перевалидировать не чаще чем раз в час
fetch('https://...', { next: { revalidate: 3600 } })
```

Альтернативно, вы можете использовать [опции конфигурации сегментов маршрута](#segment-config-options) для настройки всех запросов `fetch` в сегменте или для случаев, когда вы не можете использовать `fetch`.

**Как работает перевалидация по времени**

<Image
  alt="Диаграмма, показывающая, как работает перевалидация по времени: после периода перевалидации возвращаются устаревшие данные для первого запроса, затем данные перевалидируются."
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- При первом вызове запроса `fetch` с `revalidate` данные будут получены из внешнего источника данных и сохранены в кэше данных.
- Любые запросы, выполненные в течение указанного периода времени (например, 60 секунд), будут возвращать кэшированные данные.
- После истечения периода времени следующий запрос всё равно вернёт кэшированные (теперь устаревшие) данные.
  - Next.js запустит перевалидацию данных в фоновом режиме.
  - После успешного получения данных Next.js обновит кэш данных свежими данными.
  - Если фоновая перевалидация не удалась, предыдущие данные останутся неизменными.

Это похоже на поведение [**stale-while-revalidate**](https://web.dev/articles/stale-while-revalidate).

#### Перевалидация по запросу

Данные можно перевалидировать по запросу по пути ([`revalidatePath`](#revalidatepath)) или по тегу кэша ([`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)).

**Как работает перевалидация по запросу**

<Image
  alt="Диаграмма, показывающая, как работает перевалидация по запросу: кэш данных обновляется свежими данными после запроса на перевалидацию."
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- При первом вызове запроса `fetch` данные будут получены из внешнего источника данных и сохранены в кэше данных.
- При запуске перевалидации по запросу соответствующие записи кэша будут удалены из кэша.
  - Это отличается от перевалидации по времени, которая сохраняет устаревшие данные в кэше до получения свежих данных.
- При следующем запросе снова будет `MISS` в кэше, и данные будут получены из внешнего источника данных и сохранены в кэше данных.

### Отказ от кэширования

Если вы _не_ хотите кэшировать ответ от `fetch`, вы можете сделать следующее:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Полный кэш маршрута

> **Связанные термины**:
>
> Вы можете встретить термины **Автоматическая статическая оптимизация**, **Генерация статических сайтов** или **Статический рендеринг**, используемые взаимозаменяемо для обозначения процесса рендеринга и кэширования маршрутов вашего приложения во время сборки.

Next.js автоматически рендерит и кэширует маршруты во время сборки. Это оптимизация, которая позволяет обслуживать кэшированный маршрут вместо рендеринга на сервере для каждого запроса, что приводит к более быстрой загрузке страниц.

Чтобы понять, как работает полный кэш маршрута, полезно посмотреть, как React обрабатывает рендеринг и как Next.js кэширует результат:

### 1. Рендеринг React на сервере

На сервере Next.js использует API React для организации рендеринга. Работа по рендерингу разделяется на части: по отдельным сегментам маршрутов и границам Suspense.

Каждая часть рендерится в два этапа:

1. React рендерит Server Components в специальный формат данных, оптимизированный для потоковой передачи, называемый **React Server Component Payload**.
2. Next.js использует React Server Component Payload и инструкции JavaScript для Client Components, чтобы отрендерить **HTML** на сервере.

Это означает, что нам не нужно ждать завершения всего рендеринга перед кэшированием работы или отправкой ответа. Вместо этого мы можем передавать ответ по мере выполнения работы.

> **Что такое React Server Component Payload?**
>
> React Server Component Payload — это компактное бинарное представление отрендеренного дерева React Server Components. Оно используется React на клиенте для обновления DOM браузера. React Server Component Payload содержит:
>
> - Результат рендеринга Server Components
> - Заполнители для мест, где должны быть отрендерены Client Components, и ссылки на их JavaScript-файлы
> - Любые пропсы, переданные из Server Component в Client Component
>
> Чтобы узнать больше, см. документацию по [Server Components](/docs/app/getting-started/server-and-client-components).

### 2. Кэширование Next.js на сервере (Полный кэш маршрута)

<Image
  alt="Поведение полного кэша маршрута по умолчанию, показывающее, как React Server Component Payload и HTML кэшируются на сервере для статически отрендеренных маршрутов."
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

Поведение Next.js по умолчанию — кэшировать результат рендеринга (React Server Component Payload и HTML) маршрута на сервере. Это применяется к статически отрендеренным маршрутам во время сборки или во время перевалидации.

### 3. Гидратация и согласование React на клиенте

Во время запроса на клиенте:

1. HTML используется для немедленного показа быстрого неинтерактивного начального превью клиентских и серверных компонентов.
2. React Server Components Payload используется для согласования деревьев клиентских и отрендеренных серверных компонентов и обновления DOM.
3. Инструкции JavaScript используются для [гидратации](https://react.dev/reference/react-dom/client/hydrateRoot) клиентских компонентов и обеспечения интерактивности приложения.

### 4. Кэширование Next.js на клиенте (Кэш роутера)

React Server Component Payload сохраняется в клиентском [кэше роутера](#client-side-router-cache) — отдельном кэше в памяти, разделённом по отдельным сегментам маршрутов. Этот кэш роутера используется для улучшения навигации, сохраняя ранее посещённые маршруты и предварительно загружая будущие маршруты.

### 5. Последующие навигации

При последующих навигациях или во время предварительной загрузки Next.js проверит, хранится ли React Server Components Payload в кэше роутера. Если да, он пропустит отправку нового запроса на сервер.

Если сегменты маршрута отсутствуют в кэше, Next.js получит React Server Components Payload с сервера и заполнит кэш роутера на клиенте.

### Статический и динамический рендеринг (Static and Dynamic Rendering)

Будет ли маршрут закэширован во время сборки, зависит от того, рендерится он статически или динамически. Статические маршруты кэшируются по умолчанию, тогда как динамические маршруты рендерятся во время запроса и не кэшируются.

На этой диаграмме показана разница между статически и динамически рендерящимися маршрутами с кэшированными и некэшированными данными:

<Image
  alt="Как статический и динамический рендеринг влияют на Full Route Cache. Статические маршруты кэшируются во время сборки или после ревалидации данных, тогда как динамические маршруты никогда не кэшируются"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

Узнайте больше о [статическом и динамическом рендеринге](/docs/app/getting-started/partial-prerendering#static-rendering).

### Длительность хранения

По умолчанию Full Route Cache является постоянным. Это означает, что результат рендеринга кэшируется между запросами пользователей.

### Инвалидация

Есть два способа инвалидировать Full Route Cache:

- **[Ревалидация данных](/docs/app/deep-dive/caching#revalidating)**: Ревалидация [Data Cache](#data-cache) приведёт к инвалидации Router Cache путём перерендеринга компонентов на сервере и кэширования нового результата рендеринга.
- **Передеплой**: В отличие от Data Cache, который сохраняется между деплоями, Full Route Cache очищается при новых деплоях.

### Отказ от кэширования

Вы можете отказаться от Full Route Cache, другими словами, динамически рендерить компоненты для каждого входящего запроса, с помощью:

- **Использования [Dynamic API](#dynamic-apis)**: Это исключит маршрут из Full Route Cache и будет рендерить его динамически во время запроса. Data Cache при этом всё ещё может использоваться.
- **Использования опций конфигурации сегмента маршрута `dynamic = 'force-dynamic'` или `revalidate = 0`**: Это пропустит Full Route Cache и Data Cache. То есть компоненты будут рендериться, а данные запрашиваться при каждом входящем запросе к серверу. Router Cache всё ещё будет применяться, так как это клиентский кэш.
- **Отказа от [Data Cache](#data-cache)**: Если маршрут содержит `fetch`-запрос, который не кэшируется, это исключит маршрут из Full Route Cache. Данные для конкретного `fetch`-запроса будут запрашиваться при каждом входящем запросе. Другие `fetch`-запросы, которые не отказываются от кэширования, всё ещё будут кэшироваться в Data Cache. Это позволяет комбинировать кэшированные и некэшированные данные.

## Клиентский Router Cache

Next.js имеет клиентский кэш маршрутизатора в памяти, который хранит RSC-полезную нагрузку сегментов маршрутов, разделённых по лэйаутам, состояниям загрузки и страницам.

Когда пользователь переходит между маршрутами, Next.js кэширует посещённые сегменты маршрутов и [предзагружает](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) маршруты, по которым пользователь, скорее всего, перейдёт. Это обеспечивает мгновенную навигацию назад/вперёд, отсутствие полной перезагрузки страницы между переходами и сохранение состояния React и состояния браузера.

С Router Cache:

- **Лэйауты** кэшируются и повторно используются при навигации ([частичный рендеринг](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)).
- **Состояния загрузки** кэшируются и повторно используются при навигации для [мгновенной навигации](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- **Страницы** по умолчанию не кэшируются, но повторно используются при навигации назад/вперёд в браузере. Вы можете включить кэширование для сегментов страниц, используя экспериментальную опцию конфигурации [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes).

{/* TODO: Обновить диаграмму в соответствии с поведением v15 */}

> **Важно знать**: Этот кэш специфичен для Next.js и Server Components и отличается от [bfcache](https://web.dev/bfcache/) браузера, хотя даёт схожий результат.

### Длительность хранения

Кэш хранится во временной памяти браузера. Два фактора определяют, как долго длится Router Cache:

- **Сессия**: Кэш сохраняется между переходами. Однако он очищается при обновлении страницы.
- **Период автоматической инвалидации**: Кэш лэйаутов и состояний загрузки автоматически инвалидируется через определённое время. Длительность зависит от того, как ресурс был [предзагружен](/docs/app/api-reference/components/link#prefetch), и был ли ресурс [статически сгенерирован](/docs/app/getting-started/partial-prerendering#static-rendering):
  - **Стандартная предзагрузка** (`prefetch={null}` или не указана): не кэшируется для динамических страниц, 5 минут для статических страниц.
  - **Полная предзагрузка** (`prefetch={true}` или `router.prefetch`): 5 минут для статических и динамических страниц.

Хотя обновление страницы очистит **все** кэшированные сегменты, период автоматической инвалидации влияет только на отдельный сегмент с момента его предзагрузки.

> **Важно знать**: Экспериментальная опция конфигурации [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) может использоваться для настройки периодов автоматической инвалидации, упомянутых выше.

### Инвалидация

Есть два способа инвалидировать Router Cache:

- В **Server Action**:
  - Ревалидация данных по требованию по пути с помощью ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)) или по тегу кэша с помощью ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))
  - Использование [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie) или [`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies) инвалидирует Router Cache, чтобы предотвратить устаревание маршрутов, использующих куки (например, аутентификацию).
- Вызов [`router.refresh`](/docs/app/api-reference/functions/use-router) инвалидирует Router Cache и делает новый запрос к серверу для текущего маршрута.

### Отказ от кэширования

Начиная с Next.js 15, сегменты страниц по умолчанию исключены из кэширования.

> **Важно знать**: Вы также можете отказаться от [предзагрузки](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching), установив свойство `prefetch` компонента `<Link>` в `false`.

## Взаимодействие кэшей

При настройке различных механизмов кэширования важно понимать, как они взаимодействуют друг с другом:

### Data Cache и Full Route Cache

- Ревалидация или отказ от Data Cache **приведёт** к инвалидации Full Route Cache, так как результат рендеринга зависит от данных.
- Инвалидация или отказ от Full Route Cache **не влияет** на Data Cache. Вы можете динамически рендерить маршрут, который содержит как кэшированные, так и некэшированные данные. Это полезно, когда большая часть вашей страницы использует кэшированные данные, но у вас есть несколько компонентов, зависящих от данных, которые нужно запрашивать во время запроса. Вы можете динамически рендерить без опасений о влиянии на производительность из-за повторного запроса всех данных.

### Data Cache и клиентский Router Cache

- Для немедленной инвалидации Data Cache и Router Cache вы можете использовать [`revalidatePath`](#revalidatepath) или [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag) в [Server Action](/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
- Ревалидация Data Cache в [Route Handler](/docs/app/building-your-application/routing/route-handlers) **не приведёт** к немедленной инвалидации Router Cache, так как Route Handler не привязан к конкретному маршруту. Это означает, что Router Cache продолжит обслуживать предыдущую полезную нагрузку до полного обновления страницы или истечения периода автоматической инвалидации.

## API

Следующая таблица предоставляет обзор того, как различные API Next.js влияют на кэширование:

| API                                                                     | Router Cache               | Full Route Cache      | Data Cache            | React Cache |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Кэшируется                 |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Кэшируется                 |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Инвалидируется             |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Кэшируется            | Кэшируется  |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Кэшируется или исключается |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Инвалидируется        | Инвалидируется        |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Кэшируется            | Кэшируется            |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Инвалидируется (Server Action) | Инвалидируется        | Инвалидируется        |             |
| [`revalidatePath`](#revalidatepath)                                     | Инвалидируется (Server Action) | Инвалидируется        | Инвалидируется        |             |
| [`const revalidate`](#segment-config-options)                           |                            | Инвалидируется или исключается | Инвалидируется или исключается |             |
| [`const dynamic`](#segment-config-options)                              |                            | Кэшируется или исключается | Кэшируется или исключается |             |
| [`cookies`](#cookies)                                                   | Инвалидируется (Server Action) | Исключается           |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Исключается           |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Кэшируется            |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Кэшируется  |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Кэшируется            |             |

### `<Link>`

По умолчанию компонент `<Link>` автоматически предзагружает маршруты из Full Route Cache и добавляет полезную нагрузку React Server Component в Router Cache.

Чтобы отключить предзагрузку, вы можете установить свойство `prefetch` в `false`. Но это не исключит кэш навсегда — сегмент маршрута всё равно будет кэшироваться на клиенте, когда пользователь посетит маршрут.

Узнайте больше о [компоненте `<Link>`](/docs/app/api-reference/components/link).

### `router.prefetch`

Опция `prefetch` хука `useRouter` может использоваться для ручной предзагрузки маршрута. Это добавляет полезную нагрузку React Server Component в Router Cache.

См. [документацию хука `useRouter`](/docs/app/api-reference/functions/use-router).

### `router.refresh`

Опция `refresh` хука `useRouter` может использоваться для ручного обновления маршрута. Это полностью очищает Router Cache и делает новый запрос к серверу для текущего маршрута. `refresh` не влияет на Data Cache или Full Route Cache.

Результат рендеринга будет согласован на клиенте с сохранением состояния React и состояния браузера.

См. [документацию хука `useRouter`](/docs/app/api-reference/functions/use-router).

### `fetch`

Данные, возвращаемые из `fetch`, **не** автоматически кэшируются в Data Cache.

Поведение кэширования `fetch` по умолчанию (например, когда опция `cache` не указана) эквивалентно установке опции `cache` в `no-store`:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

См. [документацию API `fetch`](/docs/app/api-reference/functions/fetch) для получения дополнительных опций.

### `fetch options.cache`

Вы можете включить кэширование для отдельных `fetch`-запросов, установив опцию `cache` в `force-cache`:

```jsx
// Включить кэширование
fetch(`https://...`, { cache: 'force-cache' })
```

См. [документацию API `fetch`](/docs/app/api-reference/functions/fetch) для получения дополнительных опций.

### `fetch options.next.revalidate`

Вы можете использовать опцию `next.revalidate` в `fetch` для установки периода ревалидации (в секундах) для отдельного `fetch`-запроса. Это ревалидирует Data Cache, что, в свою очередь, ревалидирует Full Route Cache. Будут запрошены свежие данные, и компоненты будут перерендерены на сервере.

```jsx
// Ревалидировать не чаще чем раз в час
fetch(`https://...`, { next: { revalidate: 3600 } })
```

См. [документацию API `fetch`](/docs/app/api-reference/functions/fetch) для получения дополнительных опций.

### `fetch options.next.tags` и `revalidateTag`

Next.js имеет систему тегирования кэша для точного управления кэшированием и ревалидацией данных.

1. При использовании `fetch` или [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache) вы можете пометить записи кэша одним или несколькими тегами.
2. Затем вы можете вызвать `revalidateTag`, чтобы очистить записи кэша, связанные с этим тегом.

Например, вы можете установить тег при запросе данных:

```jsx
// Кэшировать данные с тегом
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

Затем вызвать `revalidateTag` с тегом для очистки записи кэша:

```jsx
// Ревалидировать записи с определённым тегом
revalidateTag('a')
```

Есть два места, где вы можете использовать `revalidateTag`, в зависимости от того, чего вы хотите достичь:

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) — для ревалидации данных в ответ на событие от третьей стороны (например, вебхук). Это не приведёт к немедленной инвалидации Router Cache, так как Route Handler не привязан к конкретному маршруту.
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) — для ревалидации данных после действия пользователя (например, отправки формы). Это инвалидирует Router Cache для связанного маршрута.

### `revalidatePath`

`revalidatePath` позволяет вручную ревалидировать данные **и** перерендерить сегменты маршрута ниже определённого пути одной операцией. Вызов метода `revalidatePath` ревалидирует Data Cache, что, в свою очередь, инвалидирует Full Route Cache.

```jsx
revalidatePath('/')
```

Есть два места, где вы можете использовать `revalidatePath`, в зависимости от того, чего вы хотите достичь:

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) — для ревалидации данных в ответ на событие от третьей стороны (например, вебхук).
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) — для ревалидации данных после взаимодействия пользователя (например, отправки формы, нажатия кнопки).

См. [документацию API `revalidatePath`](/docs/app/api-reference/functions/revalidatePath) для получения дополнительной информации.

> **`revalidatePath`** vs. **`router.refresh`**:
>
> Вызов `router.refresh` очистит Router Cache и перерендерит сегменты маршрута на сервере без инвалидации Data Cache или Full Route Cache.
>
> Разница в том, что `revalidatePath` очищает Data Cache и Full Route Cache, тогда как `router.refresh()` не изменяет Data Cache и Full Route Cache, так как это клиентский API.

### Dynamic APIs

Динамические API, такие как `cookies` и `headers`, а также свойство `searchParams` в страницах зависят от информации о входящем запросе во время выполнения. Их использование исключит маршрут из Full Route Cache, другими словами, маршрут будет рендериться динамически.

#### `cookies`

Использование `cookies.set` или `cookies.delete` в Server Action инвалидирует Router Cache, чтобы предотвратить устаревание маршрутов, использующих куки (например, для отражения изменений аутентификации).

См. [документацию API `cookies`](/docs/app/api-reference/functions/cookies).

### Параметры конфигурации сегментов маршрута

Параметры конфигурации сегментов маршрута (Route Segment Config) могут использоваться для переопределения стандартных настроек сегмента маршрута или когда вы не можете использовать API `fetch` (например, клиент базы данных или сторонние библиотеки).

Следующие параметры конфигурации сегментов маршрута отключают полное кэширование маршрута (Full Route Cache):

- `const dynamic = 'force-dynamic'`

Этот параметр отключит кэширование данных для всех запросов (т.е. `no-store`):

- `const fetchCache = 'default-no-store'`

См. [`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache) для более продвинутых вариантов.

См. документацию [Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config) для дополнительных параметров.

### `generateStaticParams`

Для [динамических сегментов](/docs/app/api-reference/file-conventions/dynamic-routes) (например, `app/blog/[slug]/page.js`) пути, предоставленные `generateStaticParams`, кэшируются в Full Route Cache во время сборки. Во время запроса Next.js также будет кэшировать пути, которые не были известны во время сборки, при их первом посещении.

Для статического рендеринга всех путей во время сборки передайте полный список путей в `generateStaticParams`:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

Для статического рендеринга части путей во время сборки, а остальных — при первом посещении во время выполнения, верните частичный список путей:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // Рендеринг первых 10 постов во время сборки
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

Для статического рендеринга всех путей при их первом посещении верните пустой массив (никакие пути не будут отрендерены во время сборки) или используйте [`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic):

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Важно:** Вы должны возвращать массив из `generateStaticParams`, даже если он пустой. В противном случае маршрут будет рендериться динамически.

```jsx filename="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

Чтобы отключить кэширование во время запроса, добавьте параметр `export const dynamicParams = false` в сегменте маршрута. При использовании этой настройки будут обслуживаться только пути, предоставленные `generateStaticParams`, а другие маршруты вернут 404 или будут сопоставлены (в случае [catch-all маршрутов](/docs/app/api-reference/file-conventions/dynamic-routes#catch-all-segments)).

### Функция React `cache`

Функция React `cache` позволяет мемоизировать возвращаемое значение функции, что позволяет вызывать одну и ту же функцию несколько раз, выполняя её только один раз.

Поскольку запросы `fetch` автоматически мемоизируются, вам не нужно оборачивать их в React `cache`. Однако вы можете использовать `cache` для ручной мемоизации запросов данных в случаях, когда API `fetch` не подходит. Например, для некоторых клиентов баз данных, CMS или GraphQL.

```ts filename="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

```js filename="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
