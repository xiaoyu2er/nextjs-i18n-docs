---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:11:16.171Z
title: Реализация аутентификации в Next.js
nav_title: Аутентификация
description: Узнайте, как реализовать аутентификацию в вашем приложении Next.js.
---

Понимание аутентификации критически важно для защиты данных вашего приложения. На этой странице вы узнаете, какие функции React и Next.js использовать для реализации аутентификации.

Перед началом работы полезно разбить процесс на три концепции:

1. **[Аутентификация](#authentication)**: Проверяет, является ли пользователь тем, за кого себя выдает. Требует от пользователя подтверждения личности с помощью чего-то, что у него есть, например, имени пользователя и пароля.
2. **[Управление сеансом](#session-management)**: Отслеживает состояние аутентификации пользователя между запросами.
3. **[Авторизация](#authorization)**: Определяет, к каким маршрутам и данным пользователь может получить доступ.

Эта диаграмма показывает процесс аутентификации с использованием функций React и Next.js:

<Image
  alt="Диаграмма процесса аутентификации с функциями React и Next.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

Примеры на этой странице демонстрируют базовую аутентификацию по имени пользователя и паролю в учебных целях. Хотя вы можете реализовать собственное решение для аутентификации, для повышения безопасности и упрощения мы рекомендуем использовать библиотеку аутентификации. Они предлагают встроенные решения для аутентификации, управления сеансами и авторизации, а также дополнительные функции, такие как социальные входы, многофакторная аутентификация и управление доступом на основе ролей. Список таких библиотек вы найдете в разделе [Библиотеки аутентификации](#auth-libraries).

## Аутентификация

<AppOnly>

### Функциональность регистрации и входа

Вы можете использовать элемент [`<form>`](https://react.dev/reference/react-dom/components/form) вместе с [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) React и `useActionState` для сбора учетных данных пользователя, проверки полей формы и вызова API или базы данных вашего провайдера аутентификации.

Поскольку Server Actions всегда выполняются на сервере, они обеспечивают безопасную среду для обработки логики аутентификации.

Вот шаги для реализации функциональности регистрации/входа:

#### 1. Сбор учетных данных пользователя

Для сбора учетных данных создайте форму, которая вызывает Server Action при отправке. Например, форма регистрации, принимающая имя, email и пароль пользователя:

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Имя</label>
        <input id="name" name="name" placeholder="Имя" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Пароль</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Зарегистрироваться</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Имя</label>
        <input id="name" name="name" placeholder="Имя" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Пароль</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Зарегистрироваться</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. Проверка полей формы на сервере

Используйте Server Action для проверки полей формы на сервере. Если ваш провайдер аутентификации не предоставляет проверку формы, вы можете использовать библиотеку проверки схем, такую как [Zod](https://zod.dev/) или [Yup](https://github.com/jquense/yup).

Используя Zod в качестве примера, вы можете определить схему формы с соответствующими сообщениями об ошибках:

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Имя должно содержать не менее 2 символов.' })
    .trim(),
  email: z.string().email({ message: 'Пожалуйста, введите корректный email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Должен быть не менее 8 символов' })
    .regex(/[a-zA-Z]/, { message: 'Должен содержать хотя бы одну букву.' })
    .regex(/[0-9]/, { message: 'Должен содержать хотя бы одну цифру.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Должен содержать хотя бы один специальный символ.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Имя должно содержать не менее 2 символов.' })
    .trim(),
  email: z.string().email({ message: 'Пожалуйста, введите корректный email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Должен быть не менее 8 символов' })
    .regex(/[a-zA-Z]/, { message: 'Должен содержать хотя бы одну букву.' })
    .regex(/[0-9]/, { message: 'Должен содержать хотя бы одну цифру.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Должен содержать хотя бы один специальный символ.',
    })
    .trim(),
})
```

Чтобы избежать ненужных вызовов API или базы данных вашего провайдера аутентификации, вы можете выполнить `return` в Server Action, если какие-либо поля формы не соответствуют определенной схеме.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Проверка полей формы
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Если какие-либо поля формы недействительны, завершить раньше
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Вызов провайдера или базы данных для создания пользователя...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Проверка полей формы
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Если какие-либо поля формы недействительны, завершить раньше
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Вызов провайдера или базы данных для создания пользователя...
}
```

Вернувшись в ваш `<SignupForm />`, вы можете использовать хук `useActionState` React для отображения ошибок валидации во время отправки формы:

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Имя</label>
        <input id="name" name="name" placeholder="Имя" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Пароль</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Пароль должен:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Зарегистрироваться
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Имя</label>
        <input id="name" name="name" placeholder="Имя" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Пароль</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Пароль должен:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Зарегистрироваться
      </button>
    </form>
  )
}
```

> **Полезно знать:**
>
> - В React 19 `useFormStatus` включает дополнительные ключи в возвращаемом объекте, такие как data, method и action. Если вы не используете React 19, доступен только ключ `pending`.
> - Перед изменением данных вы всегда должны убедиться, что пользователь также авторизован для выполнения действия. См. [Аутентификация и авторизация](#authorization).

#### 3. Создание пользователя или проверка учетных данных

После проверки полей формы вы можете создать новую учетную запись пользователя или проверить существование пользователя, обратившись к API вашего провайдера аутентификации или базе данных.

Продолжая предыдущий пример:

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Проверка полей формы
  // ...

  // 2. Подготовка данных для вставки в базу данных
  const { name, email, password } = validatedFields.data
  // Например, хеширование пароля перед сохранением
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Вставка пользователя в базу данных или вызов API библиотеки аутентификации
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Произошла ошибка при создании вашей учетной записи.',
    }
  }

  // TODO:
  // 4. Создание сессии пользователя
  // 5. Перенаправление пользователя
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Проверка полей формы
  // ...

  // 2. Подготовка данных для вставки в базу данных
  const { name, email, password } = validatedFields.data
  // Например, хеширование пароля перед сохранением
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Вставка пользователя в базу данных или вызов API библиотеки
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Произошла ошибка при создании вашей учетной записи.',
    }
  }

  // TODO:
  // 4. Создание сессии пользователя
  // 5. Перенаправление пользователя
}
```

После успешного создания учетной записи или проверки учетных данных вы можете создать сессию для управления состоянием аутентификации пользователя. В зависимости от стратегии управления сессиями, сессия может храниться в cookie или базе данных, или в обоих местах. Перейдите к разделу [Управление сессиями](#session-management), чтобы узнать больше.

> **Советы:**
>
> - Приведенный выше пример подробный, так как разбивает шаги аутентификации в образовательных целях. Это подчеркивает, что реализация собственного безопасного решения может быстро усложниться. Рассмотрите использование [библиотеки аутентификации](#auth-libraries) для упрощения процесса.
> - Для улучшения пользовательского опыта вы можете проверить дублирование email или имени пользователя на ранних этапах регистрации. Например, когда пользователь вводит имя или поле ввода теряет фокус. Это поможет избежать ненужных отправок формы и предоставить немедленную обратную связь. Вы можете использовать библиотеки, такие как [use-debounce](https://www.npmjs.com/package/use-debounce), для управления частотой таких проверок.

</AppOnly>

<PagesOnly>

Вот шаги для реализации формы регистрации и/или входа:

1. Пользователь отправляет свои учетные данные через форму.
2. Форма отправляет запрос, который обрабатывается маршрутом API.
3. При успешной проверке процесс завершается, указывая на успешную аутентификацию пользователя.
4. Если проверка не удалась, отображается сообщение об ошибке.

Рассмотрим форму входа, где пользователи могут вводить свои учетные данные:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Обработка ошибок
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Пароль" required />
      <button type="submit">Войти</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Обработка ошибок
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Пароль" required />
      <button type="submit">Войти</button>
    </form>
  )
}
```

Форма выше имеет два поля ввода для сбора email и пароля пользователя. При отправке она вызывает функцию, которая отправляет POST-запрос к маршруту API (`/api/auth/login`).

Затем вы можете вызвать API вашего провайдера аутентификации в маршруте API для обработки аутентификации:

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Неверные учетные данные.' })
    } else {
      res.status(500).json({ error: 'Что-то пошло не так.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Неверные учетные данные.' })
    } else {
      res.status(500).json({ error: 'Что-то пошло не так.' })
    }
  }
}
```

</PagesOnly>

## Управление сессиями

Управление сессиями обеспечивает сохранение аутентифицированного состояния пользователя между запросами. Оно включает создание, хранение, обновление и удаление сессий или токенов.

Существует два типа сессий:

1. [**Stateless (без состояния)**](#stateless-sessions): Данные сессии (или токен) хранятся в cookie браузера. Cookie отправляется с каждым запросом, позволяя проверять сессию на сервере. Этот метод проще, но может быть менее безопасным, если реализован неправильно.
2. [**Database (база данных)**](#database-sessions): Данные сессии хранятся в базе данных, а браузер пользователя получает только зашифрованный идентификатор сессии. Этот метод более безопасен, но может быть сложнее и использовать больше ресурсов сервера.

> **Полезно знать:** Хотя вы можете использовать любой метод или оба, мы рекомендуем использовать библиотеку управления сессиями, такую как [iron-session](https://github.com/vvo/iron-session) или [Jose](https://github.com/panva/jose).

### Stateless сессии (без состояния)

<AppOnly>

Для создания и управления stateless сессиями необходимо выполнить несколько шагов:

1. Сгенерировать секретный ключ, который будет использоваться для подписи сессии, и сохранить его как [переменную окружения](/docs/app/guides/environment-variables).
2. Написать логику для шифрования/дешифрования данных сессии с использованием библиотеки управления сессиями.
3. Управлять cookie с помощью API [`cookies`](/docs/app/api-reference/functions/cookies) Next.js.

В дополнение к вышесказанному, рассмотрите возможность добавления функциональности для [обновления (или продления)](#updating-or-refreshing-sessions) сессии, когда пользователь возвращается в приложение, и [удаления](#deleting-the-session) сессии при выходе пользователя.

> **Полезно знать:** Проверьте, включает ли ваша [библиотека аутентификации](#auth-libraries) управление сессиями.

#### 1. Генерация секретного ключа

Есть несколько способов сгенерировать секретный ключ для подписи сессии. Например, вы можете использовать команду `openssl` в терминале:

```bash filename="terminal"
openssl rand -base64 32
```

Эта команда генерирует случайную строку из 32 символов, которую можно использовать как секретный ключ и сохранить в [файле переменных окружения](/docs/app/guides/environment-variables):

```bash filename=".env"
SESSION_SECRET=your_secret_key
```

Затем вы можете ссылаться на этот ключ в вашей логике управления сессиями:

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Шифрование и дешифрование сессий

Далее вы можете использовать предпочитаемую [библиотеку управления сессиями](#session-management-libraries) для шифрования и дешифрования сессий. Продолжая предыдущий пример, мы будем использовать [Jose](https://www.npmjs.com/package/jose) (совместимый с [Edge Runtime](/docs/app/api-reference/edge)) и пакет React [`server-only`](https://www.npmjs.com/package/server-only), чтобы гарантировать, что логика управления сессиями выполняется только на сервере.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Не удалось проверить сессию')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Не удалось проверить сессию')
  }
}
```

> **Советы:**
>
> - Полезная нагрузка должна содержать **минимальные**, уникальные данные пользователя, которые будут использоваться в последующих запросах, такие как ID пользователя, роль и т.д. Она не должна содержать личную информацию, такую как номер телефона, email, данные кредитной карты и т.д., или конфиденциальные данные, такие как пароли.

#### 3. Установка cookie (рекомендуемые параметры)

Для хранения сессии в cookie используйте API [`cookies`](/docs/app/api-reference/functions/cookies) Next.js. Cookie должен быть установлен на сервере и включать рекомендуемые параметры:

- **HttpOnly**: Предотвращает доступ к cookie из JavaScript на стороне клиента.
- **Secure**: Использует https для отправки cookie.
- **SameSite**: Указывает, может ли cookie отправляться с межсайтовыми запросами.
- **Max-Age или Expires**: Удаляет cookie после определенного периода.
- **Path**: Определяет URL-путь для cookie.

Пожалуйста, обратитесь к [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) для получения дополнительной информации о каждом из этих параметров.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

Вернувшись в ваше Server Action, вы можете вызвать функцию `createSession()` и использовать API [`redirect()`](/docs/app/guides/redirecting) для перенаправления пользователя на соответствующую страницу:

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // Предыдущие шаги:
  // 1. Проверка полей формы
  // 2. Подготовка данных для вставки в базу данных
  // 3. Вставка пользователя в базу данных или вызов API библиотеки

  // Текущие шаги:
  // 4. Создание сессии пользователя
  await createSession(user.id)
  // 5. Перенаправление пользователя
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // Предыдущие шаги:
  // 1. Проверка полей формы
  // 2. Подготовка данных для вставки в базу данных
  // 3. Вставка пользователя в базу данных или вызов API библиотеки

  // Текущие шаги:
  // 4. Создание сессии пользователя
  await createSession(user.id)
  // 5. Перенаправление пользователя
  redirect('/profile')
}
```

> **Советы:**
>
> - **Cookie должны устанавливаться на сервере**, чтобы предотвратить подделку на стороне клиента.
> - 🎥 Смотрите: Узнайте больше о stateless сессиях и аутентификации с Next.js → [YouTube (11 минут)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### Обновление (или продление) сессий

Вы также можете продлить время истечения сессии. Это полезно для сохранения входа пользователя после повторного доступа к приложению. Например:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Совет:** Проверьте, поддерживает ли ваша библиотека аутентификации refresh-токены, которые можно использовать для продления сессии пользователя.

#### Удаление сессии

Чтобы удалить сессию, вы можете удалить cookie:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

Затем вы можете повторно использовать функцию `deleteSession()` в вашем приложении, например, при выходе из системы:

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### Установка и удаление cookie

Вы можете использовать [API Routes](/docs/pages/building-your-application/routing/api-routes) для установки сессии как cookie на сервере:

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Одна неделя
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Одна неделя
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

### Сессии в базе данных

Для создания и управления сессиями в базе данных вам нужно выполнить следующие шаги:

1. Создать таблицу в вашей базе данных для хранения сессий и данных (или проверить, поддерживает ли это ваша библиотека аутентификации).
2. Реализовать функциональность для добавления, обновления и удаления сессий.
3. Зашифровать идентификатор сессии перед сохранением в браузере пользователя и обеспечить синхронизацию между базой данных и cookie (это опционально, но рекомендуется для оптимистичных проверок аутентификации в [Middleware](#optimistic-checks-with-middleware-optional)).

<AppOnly>

Например:

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Создать сессию в базе данных
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Вернуть идентификатор сессии
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Зашифровать идентификатор сессии
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Сохранить сессию в cookie для оптимистичных проверок аутентификации
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Создать сессию в базе данных
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Вернуть идентификатор сессии
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Зашифровать идентификатор сессии
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Сохранить сессию в cookie для оптимистичных проверок аутентификации
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Советы**:
>
> - Для более быстрого доступа вы можете рассмотреть возможность добавления кэширования на сервере на время жизни сессии. Вы также можете хранить данные сессии в основной базе данных и объединять запросы данных, чтобы уменьшить количество запросов.
> - Вы можете использовать сессии в базе данных для более сложных сценариев, таких как отслеживание времени последнего входа пользователя, количества активных устройств или предоставление пользователям возможности выхода со всех устройств.

После реализации управления сессиями вам нужно добавить логику авторизации для контроля доступа пользователей к функциям вашего приложения. Перейдите к разделу [Авторизация](#authorization), чтобы узнать больше.

</AppOnly>

<PagesOnly>

**Создание сессии на сервере**:

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

## Авторизация

После аутентификации пользователя и создания сессии вы можете реализовать авторизацию для контроля доступа пользователей к функциям вашего приложения.

Существует два основных типа проверок авторизации:

1. **Оптимистичные**: Проверяют, авторизован ли пользователь для доступа к маршруту или выполнения действия, используя данные сессии, хранящиеся в cookie. Эти проверки полезны для быстрых операций, таких как отображение/скрытие элементов интерфейса или перенаправление пользователей на основе разрешений или ролей.
2. **Безопасные**: Проверяют, авторизован ли пользователь для доступа к маршруту или выполнения действия, используя данные сессии, хранящиеся в базе данных. Эти проверки более безопасны и используются для операций, требующих доступа к конфиденциальным данным или действиям.

Для обоих случаев мы рекомендуем:

- Создать [Слой доступа к данным (DAL)](#creating-a-data-access-layer-dal) для централизации логики авторизации
- Использовать [Объекты передачи данных (DTO)](#using-data-transfer-objects-dto) для возврата только необходимых данных
- Опционально использовать [Middleware](#optimistic-checks-with-middleware-optional) для выполнения оптимистичных проверок.

### Оптимистичные проверки с Middleware (Опционально)

В некоторых случаях вы можете использовать [Middleware](/docs/app/building-your-application/routing/middleware) и перенаправлять пользователей на основе разрешений:

- Для выполнения оптимистичных проверок. Поскольку Middleware выполняется на каждом маршруте, это хороший способ централизовать логику перенаправления и предварительно фильтровать неавторизованных пользователей.
- Для защиты статических маршрутов, которые используют общие данные между пользователями (например, контент за платным доступом).

Однако, поскольку Middleware выполняется на каждом маршруте, включая [предварительно загруженные](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) маршруты, важно только читать сессию из cookie (оптимистичные проверки) и избегать проверок в базе данных, чтобы предотвратить проблемы с производительностью.

Например:

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Указать защищенные и публичные маршруты
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. Проверить, является ли текущий маршрут защищенным или публичным
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Расшифровать сессию из cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Перенаправить на /login, если пользователь не аутентифицирован
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Перенаправить на /dashboard, если пользователь аутентифицирован
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Маршруты, на которых Middleware не должен выполняться
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Указать защищенные и публичные маршруты
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. Проверить, является ли текущий маршрут защищенным или публичным
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Расшифровать сессию из cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Перенаправить на /login, если пользователь не аутентифицирован
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Перенаправить на /dashboard, если пользователь аутентифицирован
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Маршруты, на которых Middleware не должен выполняться
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Хотя Middleware может быть полезен для начальных проверок, он не должен быть единственной линией защиты ваших данных. Большинство проверок безопасности должно выполняться как можно ближе к источнику данных, см. [Слой доступа к данным (DAL)](#creating-a-data-access-layer-dal) для получения дополнительной информации.

> **Советы**:
>
> - В Middleware вы также можете читать cookie с помощью `req.cookies.get('session').value`.
> - Middleware использует [Edge Runtime](/docs/app/api-reference/edge), проверьте совместимость вашей библиотеки аутентификации и библиотеки управления сессиями.
> - Вы можете использовать свойство `matcher` в Middleware, чтобы указать, на каких маршрутах должен выполняться Middleware. Однако для аутентификации рекомендуется выполнять Middleware на всех маршрутах.

<AppOnly>

### Создание слоя доступа к данным (DAL)

Мы рекомендуем создать DAL для централизации запросов данных и логики авторизации.

DAL должен включать функцию, которая проверяет сессию пользователя при взаимодействии с вашим приложением. Как минимум, функция должна проверять, действительна ли сессия, а затем перенаправлять или возвращать информацию о пользователе, необходимую для дальнейших запросов.

Например, создайте отдельный файл для вашего DAL, который включает функцию `verifySession()`. Затем используйте API [cache](https://react.dev/reference/react/cache) React для мемоизации возвращаемого значения функции во время прохода рендеринга React:

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

Затем вы можете вызывать функцию `verifySession()` в ваших запросах данных, Server Actions, Route Handlers:

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Явно возвращайте только нужные столбцы, а не весь объект пользователя
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Явно возвращайте только нужные столбцы, а не весь объект пользователя
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

> **Совет**:
>
> - DAL можно использовать для защиты данных, запрашиваемых во время запроса. Однако для статических маршрутов, которые используют общие данные между пользователями, данные будут запрашиваться во время сборки, а не во время запроса. Используйте [Middleware](#optimistic-checks-with-middleware-optional) для защиты статических маршрутов.
> - Для безопасных проверок вы можете проверить, действительна ли сессия, сравнивая идентификатор сессии с вашей базой данных. Используйте функцию [cache](https://react.dev/reference/react/cache) React, чтобы избежать ненужных дублирующих запросов к базе данных во время прохода рендеринга.
> - Вы можете объединить связанные запросы данных в классе JavaScript, который выполняет `verifySession()` перед любыми методами.

### Использование объектов передачи данных (DTO)

При получении данных рекомендуется возвращать только необходимую информацию, которая будет использоваться в вашем приложении, а не целые объекты. Например, при запросе данных пользователя можно вернуть только его ID и имя, а не весь объект пользователя, который может содержать пароли, номера телефонов и т.д.

Однако если у вас нет контроля над структурой возвращаемых данных или вы работаете в команде и хотите избежать передачи целых объектов клиенту, можно использовать стратегии, такие как указание полей, безопасных для передачи клиенту.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Возвращаем только определенные столбцы
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Или возвращаем только то, что нужно для конкретного запроса
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Возвращаем только определенные столбцы
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Или возвращаем только то, что нужно для конкретного запроса
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

Централизуя запросы данных и логику авторизации в DAL (Data Access Layer) и используя DTO, вы можете гарантировать, что все запросы данных безопасны и согласованы, что упрощает поддержку, аудит и отладку по мере масштабирования приложения.

> **Полезно знать**:
>
> - Существует несколько способов определения DTO: от использования `toJSON()` до отдельных функций, как в примере выше, или классов JS. Поскольку это паттерны JavaScript, а не функции React или Next.js, рекомендуем изучить варианты и выбрать лучший для вашего приложения.
> - Подробнее о лучших практиках безопасности читайте в нашей статье [Безопасность в Next.js](/blog/security-nextjs-server-components-actions).

### Серверные компоненты (Server Components)

Проверка авторизации в [серверных компонентах](/docs/app/getting-started/server-and-client-components) полезна для ролевого доступа. Например, для условного рендеринга компонентов в зависимости от роли пользователя:

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // Предполагаем, что 'role' есть в объекте сессии

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // Предполагаем, что 'role' есть в объекте сессии

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

В примере мы используем функцию `verifySession()` из нашего DAL для проверки ролей 'admin', 'user' и неавторизованных пользователей. Этот паттерн гарантирует, что каждый пользователь взаимодействует только с компонентами, соответствующими его роли.

### Макеты (Layouts) и проверки авторизации

Из-за [частичного рендеринга (Partial Rendering)](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering) будьте осторожны при проверках в [макетах](/docs/app/api-reference/file-conventions/layout), так как они не перерендериваются при навигации, что означает отсутствие проверки сессии пользователя при каждом изменении маршрута.

Вместо этого следует выполнять проверки ближе к источнику данных или компоненту, который будет условно рендериться.

Например, рассмотрим общий макет, который получает данные пользователя и отображает его изображение в навигации. Вместо проверки авторизации в макете следует получать данные пользователя (`getUser()`) в макете и выполнять проверку авторизации в DAL.

Это гарантирует, что где бы ни вызывался `getUser()` в вашем приложении, проверка авторизации выполняется, и предотвращает ситуацию, когда разработчики забывают проверить, авторизован ли пользователь для доступа к данным.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Получаем ID пользователя из сессии и запрашиваем данные
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Получаем ID пользователя из сессии и запрашиваем данные
})
```

> **Полезно знать:**
>
> - Распространенный паттерн в SPA — возвращать `null` в макете или компоненте верхнего уровня, если пользователь не авторизован. Этот паттерн **не рекомендуется**, так как приложения Next.js имеют несколько точек входа, что не предотвращает доступ к вложенным сегментам маршрутов и серверным действиям (Server Actions).

### Серверные действия (Server Actions)

Относитесь к [серверным действиям](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) с теми же мерами безопасности, что и к публичным API-эндпоинтам, и проверяйте, разрешено ли пользователю выполнять мутацию.

В примере ниже мы проверяем роль пользователя перед выполнением действия:

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Прерываем выполнение, если пользователь не авторизован для действия
  if (userRole !== 'admin') {
    return null
  }

  // Продолжаем выполнение для авторизованных пользователей
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Прерываем выполнение, если пользователь не авторизован для действия
  if (userRole !== 'admin') {
    return null
  }

  // Продолжаем выполнение для авторизованных пользователей
}
```

### Обработчики маршрутов (Route Handlers)

Относитесь к [обработчикам маршрутов](/docs/app/building-your-application/routing/route-handlers) с теми же мерами безопасности, что и к публичным API-эндпоинтам, и проверяйте, разрешено ли пользователю обращаться к обработчику.

Например:

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Аутентификация пользователя и проверка роли
  const session = await verifySession()

  // Проверяем, авторизован ли пользователь
  if (!session) {
    // Пользователь не авторизован
    return new Response(null, { status: 401 })
  }

  // Проверяем, есть ли у пользователя роль 'admin'
  if (session.user.role !== 'admin') {
    // Пользователь авторизован, но не имеет прав
    return new Response(null, { status: 403 })
  }

  // Продолжаем для авторизованных пользователей
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Аутентификация пользователя и проверка роли
  const session = await verifySession()

  // Проверяем, авторизован ли пользователь
  if (!session) {
    // Пользователь не авторизован
    return new Response(null, { status: 401 })
  }

  // Проверяем, есть ли у пользователя роль 'admin'
  if (session.user.role !== 'admin') {
    // Пользователь авторизован, но не имеет прав
    return new Response(null, { status: 403 })
  }

  // Продолжаем для авторизованных пользователей
}
```

В примере выше показан обработчик маршрута с двухуровневой проверкой безопасности. Сначала проверяется активная сессия, затем подтверждается, что вошедший пользователь является 'администратором'.

## Провайдеры контекста (Context Providers)

Использование провайдеров контекста для авторизации работает благодаря [чередованию (interleaving)](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). Однако React `context` не поддерживается в серверных компонентах, что делает их применимыми только к клиентским компонентам.

Это работает, но любые дочерние серверные компоненты сначала рендерятся на сервере и не имеют доступа к данным сессии провайдера контекста:

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

Если данные сессии нужны в клиентских компонентах (например, для клиентского получения данных), используйте API React [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue), чтобы предотвратить передачу конфиденциальных данных сессии клиенту.

</AppOnly>

<PagesOnly>

### Создание уровня доступа к данным (DAL)

#### Защита API-маршрутов

API-маршруты в Next.js необходимы для обработки серверной логики и управления данными. Важно защитить эти маршруты, чтобы гарантировать, что только авторизованные пользователи могут получить доступ к определенным функциям. Обычно это включает проверку статуса аутентификации пользователя и его прав на основе ролей.

Вот пример защиты API-маршрута:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Проверяем, авторизован ли пользователь
  if (!session) {
    res.status(401).json({
      error: 'Пользователь не авторизован',
    })
    return
  }

  // Проверяем, есть ли у пользователя роль 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Несанкционированный доступ: пользователь не имеет прав администратора.',
    })
    return
  }

  // Продолжаем выполнение маршрута для авторизованных пользователей
  // ... реализация API-маршрута
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Проверяем, авторизован ли пользователь
  if (!session) {
    res.status(401).json({
      error: 'Пользователь не авторизован',
    })
    return
  }

  // Проверяем, есть ли у пользователя роль 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Несанкционированный доступ: пользователь не имеет прав администратора.',
    })
    return
  }

  // Продолжаем выполнение маршрута для авторизованных пользователей
  // ... реализация API-маршрута
}
```

Этот пример демонстрирует API-маршрут с двухуровневой проверкой безопасности для аутентификации и авторизации. Сначала проверяется активная сессия, затем подтверждается, что вошедший пользователь является 'администратором'. Такой подход обеспечивает безопасный доступ, ограниченный для авторизованных пользователей, поддерживая надежную защиту при обработке запросов.

</PagesOnly>

## Ресурсы

Теперь, когда вы узнали об аутентификации в Next.js, вот совместимые с Next.js библиотеки и ресурсы, которые помогут вам реализовать безопасную аутентификацию и управление сессиями:

### Библиотеки аутентификации

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Библиотеки управления сессиями

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Дополнительные материалы

Чтобы продолжить изучение аутентификации и безопасности, ознакомьтесь со следующими ресурсами:

- [Как думать о безопасности в Next.js](/blog/security-nextjs-server-components-actions)
- [Понимание XSS-атак](https://vercel.com/guides/understanding-xss-attacks)
- [Понимание CSRF-атак](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
