---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:11:31.023Z
title: Связывание и навигация
description: Узнайте, как работает навигация в Next.js, и как использовать компонент Link и хук `useRouter`.
related:
  links:
    - app/deep-dive/caching
    - app/api-reference/config/typescript
---

В Next.js существует четыре способа навигации между маршрутами:

- Использование [компонента `<Link>`](#link-component)
- Использование [хука `useRouter`](#userouter-hook) ([Клиентские компоненты](/docs/app/getting-started/server-and-client-components))
- Использование [функции `redirect`](#redirect-function) ([Серверные компоненты](/docs/app/getting-started/server-and-client-components))
- Использование нативного [History API](#using-the-native-history-api)

На этой странице мы рассмотрим, как использовать каждый из этих вариантов, и углубимся в принципы работы навигации.

## Компонент `<Link>`

`<Link>` — это встроенный компонент, расширяющий HTML-тег `<a>` для обеспечения [предварительной загрузки](#2-prefetching) и клиентской навигации между маршрутами. Это основной и рекомендуемый способ навигации в Next.js.

Его можно использовать, импортировав из `next/link` и передав проп `href`:

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

Существуют другие необязательные пропсы, которые можно передать в `<Link>`. Подробнее см. в [справочнике API](/docs/app/api-reference/components/link).

## Хук `useRouter()`

Хук `useRouter` позволяет программно изменять маршруты из [Клиентских компонентов](/docs/app/getting-started/server-and-client-components).

```tsx filename="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Полный список методов `useRouter` см. в [справочнике API](/docs/app/api-reference/functions/use-router).

> **Рекомендация:** Используйте компонент `<Link>` для навигации между маршрутами, если у вас нет особых причин использовать `useRouter`.

## Функция `redirect`

Для [Серверных компонентов](/docs/app/getting-started/server-and-client-components) используйте функцию `redirect`.

```tsx filename="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

```jsx filename="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

> **Полезно знать**:
>
> - По умолчанию `redirect` возвращает код состояния 307 (Временное перенаправление). При использовании в Server Action возвращается код 303 (Смотреть другое), который обычно применяется для перенаправления на страницу успеха после POST-запроса.
> - `redirect` внутренне выбрасывает ошибку, поэтому его следует вызывать вне блоков `try/catch`.
> - `redirect` можно вызывать в Клиентских компонентах во время рендеринга, но не в обработчиках событий. Вместо этого используйте [хук `useRouter`](#userouter-hook).
> - `redirect` также принимает абсолютные URL и может использоваться для перенаправления на внешние ссылки.
> - Если нужно выполнить перенаправление до процесса рендеринга, используйте [`next.config.js`](/docs/app/guides/redirecting#redirects-in-nextconfigjs) или [Middleware](/docs/app/guides/redirecting#nextresponseredirect-in-middleware).

Подробнее см. в [справочнике API `redirect`](/docs/app/api-reference/functions/redirect).

## Использование нативного History API

Next.js позволяет использовать нативные методы [`window.history.pushState`](https://developer.mozilla.org/ru/docs/Web/API/History/pushState) и [`window.history.replaceState`](https://developer.mozilla.org/ru/docs/Web/API/History/replaceState) для обновления истории браузера без перезагрузки страницы.

Вызовы `pushState` и `replaceState` интегрируются с роутером Next.js, позволяя синхронизироваться с [`usePathname`](/docs/app/api-reference/functions/use-pathname) и [`useSearchParams`](/docs/app/api-reference/functions/use-search-params).

### `window.history.pushState`

Используется для добавления новой записи в историю браузера. Пользователь может вернуться к предыдущему состоянию. Например, для сортировки списка товаров:

```tsx fileName="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Сортировать по возрастанию</button>
      <button onClick={() => updateSorting('desc')}>Сортировать по убыванию</button>
    </>
  )
}
```

```jsx fileName="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Сортировать по возрастанию</button>
      <button onClick={() => updateSorting('desc')}>Сортировать по убыванию</button>
    </>
  )
}
```

### `window.history.replaceState`

Используется для замены текущей записи в истории браузера. Пользователь не сможет вернуться к предыдущему состоянию. Например, для переключения локали приложения:

```tsx fileName="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // Например, '/en/about' или '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Английский</button>
      <button onClick={() => switchLocale('fr')}>Французский</button>
    </>
  )
}
```

```jsx fileName="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // Например, '/en/about' или '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Английский</button>
      <button onClick={() => switchLocale('fr')}>Французский</button>
    </>
  )
}
```

## Как работают маршрутизация и навигация

App Router использует гибридный подход к маршрутизации и навигации. На сервере код вашего приложения автоматически [разделяется на части](#1-code-splitting) по сегментам маршрутов. А на клиенте Next.js [предварительно загружает](#2-prefetching) и [кэширует](#3-caching) сегменты маршрутов. Это означает, что при переходе пользователя на новый маршрут страница не перезагружается, а перерисовываются только изменившиеся сегменты — что улучшает опыт навигации и производительность.

### 1. Разделение кода (Code Splitting)

Разделение кода позволяет разбить код приложения на меньшие части для загрузки и выполнения браузером. Это уменьшает объем передаваемых данных и время выполнения каждого запроса, повышая производительность.

[Серверные компоненты](/docs/app/getting-started/server-and-client-components) позволяют автоматически разделять код приложения по сегментам маршрутов. Это означает, что при навигации загружается только код, необходимый для текущего маршрута.

### 2. Предварительная загрузка (Prefetching)

Предварительная загрузка позволяет загружать маршрут в фоновом режиме до того, как пользователь посетит его.

В Next.js есть два способа предварительной загрузки маршрутов:

- **Компонент `<Link>`**: Маршруты автоматически предзагружаются, когда становятся видимыми в области просмотра пользователя. Это происходит при первой загрузке страницы или при прокрутке.
- **`router.prefetch()`**: Хук `useRouter` можно использовать для программной предзагрузки маршрутов.

Поведение предзагрузки `<Link>` по умолчанию (когда проп `prefetch` не указан или равен `null`) зависит от использования [`loading.js`](/docs/app/api-reference/file-conventions/loading). Предзагружается и кэшируется только общий макет до первого файла `loading.js` в дереве компонентов на `30s`. Это снижает затраты на загрузку динамического маршрута и позволяет показать [мгновенное состояние загрузки](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) для лучшей визуальной обратной связи.

Можно отключить предзагрузку, установив проп `prefetch` в `false`. Или загрузить полные данные страницы за пределами границ загрузки, установив `prefetch` в `true`.

Подробнее см. в [справочнике API `<Link>`](/docs/app/api-reference/components/link).

> **Полезно знать**:
>
> - Предзагрузка работает только в production, а не в development.

### 3. Кэширование

Next.js имеет **клиентский кэш в памяти** под названием [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache). При навигации по приложению полезная нагрузка React Server Component для [предзагруженных](#2-prefetching) и посещенных сегментов маршрутов сохраняется в кэше.

Это означает, что при навигации кэш повторно используется вместо нового запроса к серверу — что улучшает производительность, сокращая количество запросов и объем передаваемых данных.

Узнайте больше о работе [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache) и его настройке.

### 4. Частичный рендеринг (Partial Rendering)

Частичный рендеринг означает, что на клиенте перерисовываются только изменившиеся сегменты маршрутов, а общие сегменты сохраняются.

Например, при переходе между двумя родственными маршрутами `/dashboard/settings` и `/dashboard/analytics`, страница `settings` будет размонтирована, страница `analytics` смонтирована с новым состоянием, а общий макет `dashboard` сохранится. Такое же поведение наблюдается между маршрутами с динамическими сегментами, например, `/blog/[slug]/page` при переходе от `/blog/first` к `/blog/second`.

<Image
  alt="Как работает частичный рендеринг"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

Без частичного рендеринга каждая навигация вызывала бы полную перерисовку страницы на клиенте. Рендеринг только изменяющихся сегментов сокращает объем передаваемых данных и время выполнения, улучшая производительность.

### 5. Мягкая навигация (Soft Navigation)

Браузеры выполняют "жесткую навигацию" при переходе между страницами. App Router Next.js обеспечивает "мягкую навигацию", при которой перерисовываются только изменившиеся сегменты маршрутов (частичный рендеринг). Это позволяет сохранять состояние React на клиенте во время навигации.

### 6. Навигация назад и вперед

По умолчанию Next.js сохраняет позицию прокрутки при навигации назад и вперед и повторно использует сегменты маршрутов из [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache).

### 7. Маршрутизация между `pages/` и `app/`

При постепенной миграции с `pages/` на `app/` роутер Next.js автоматически обрабатывает жесткую навигацию между ними. Для обнаружения переходов из `pages/` в `app/` используется клиентский фильтр роутера с вероятностной проверкой маршрутов приложения, что иногда может давать ложные срабатывания. По умолчанию такие случаи должны быть очень редкими, так как вероятность ложного срабатывания установлена на 0.01%. Эту вероятность можно настроить через опцию `experimental.clientRouterFilterAllowedRate` в `next.config.js`. Важно отметить, что снижение вероятности ложных срабатываний увеличит размер фильтра в клиентском бандле.

Альтернативно, если вы предпочитаете полностью отключить эту обработку и управлять маршрутизацией между `pages/` и `app/` вручную, можно установить `experimental.clientRouterFilter` в `false` в `next.config.js`. При отключении этой функции динамические маршруты в `pages`, пересекающиеся с маршрутами в `app`, по умолчанию не будут обрабатываться корректно.