---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:20:13.534Z
title: Компонент <Image> (Legacy)
description: Обратно совместимая оптимизация изображений с Legacy Image компонентом.
---

<details>
  <summary>Примеры</summary>

- [Legacy Image Component](https://github.com/vercel/next.js/tree/canary/examples/image-legacy-component)

</details>

Начиная с Next.js 13, компонент `next/image` был переработан для улучшения производительности и удобства разработчиков. Для обеспечения обратной совместимости старый `next/image` был переименован в `next/legacy/image`.

См. **новую** [справочную документацию по `next/image`](/docs/pages/api-reference/components/image)

## Сравнение

По сравнению с `next/legacy/image`, новый компонент `next/image` имеет следующие изменения:

- Удалена обёртка `<span>` вокруг `<img>` в пользу [нативного вычисления соотношения сторон](https://caniuse.com/mdn-html_elements_img_aspect_ratio_computed_from_attributes)
- Добавлена поддержка стандартного пропа `style`
  - Удалён проп `layout` в пользу `style` или `className`
  - Удалён проп `objectFit` в пользу `style` или `className`
  - Удалён проп `objectPosition` в пользу `style` или `className`
- Удалена реализация `IntersectionObserver` в пользу [нативной ленивой загрузки](https://caniuse.com/loading-lazy-attr)
  - Удалён проп `lazyBoundary`, так как нет нативного эквивалента
  - Удалён проп `lazyRoot`, так как нет нативного эквивалента
- Удалена конфигурация `loader` в пользу пропа [`loader`](#loader)
- Проп `alt` стал обязательным вместо опционального
- Изменён callback `onLoadingComplete` для получения ссылки на элемент `<img>`

## Обязательные пропсы

Компонент `<Image />` требует следующие свойства.

### src

Должен быть одним из следующих:

- [Статически импортированный](/docs/pages/building-your-application/optimizing/images#local-images) файл изображения
- Строка пути. Может быть абсолютным внешним URL или внутренним путём в зависимости от пропа [`loader`](#loader) или [конфигурации загрузчика](#loader-configuration).

При использовании внешнего URL его необходимо добавить в [`remotePatterns`](#remote-patterns) в `next.config.js`.

### width

Свойство `width` может представлять либо _отображаемую_ ширину, либо _оригинальную_ ширину в пикселях, в зависимости от свойств [`layout`](#layout) и [`sizes`](#sizes).

При использовании `layout="intrinsic"` или `layout="fixed"` свойство `width` представляет _отображаемую_ ширину в пикселях, поэтому влияет на размер изображения.

При использовании `layout="responsive"` или `layout="fill"` свойство `width` представляет _оригинальную_ ширину в пикселях, поэтому влияет только на соотношение сторон.

Свойство `width` обязательно, за исключением [статически импортированных изображений](/docs/pages/building-your-application/optimizing/images#local-images) или изображений с `layout="fill"`.

### height

Свойство `height` может представлять либо _отображаемую_ высоту, либо _оригинальную_ высоту в пикселях, в зависимости от свойств [`layout`](#layout) и [`sizes`](#sizes).

При использовании `layout="intrinsic"` или `layout="fixed"` свойство `height` представляет _отображаемую_ высоту в пикселях, поэтому влияет на размер изображения.

При использовании `layout="responsive"` или `layout="fill"` свойство `height` представляет _оригинальную_ высоту в пикселях, поэтому влияет только на соотношение сторон.

Свойство `height` обязательно, за исключением [статически импортированных изображений](/docs/pages/building-your-application/optimizing/images#local-images) или изображений с `layout="fill"`.

## Опциональные пропсы

Компонент `<Image />` принимает ряд дополнительных свойств помимо обязательных. В этом разделе описаны наиболее часто используемые свойства компонента Image. Подробности о редко используемых свойствах можно найти в разделе [Расширенные пропсы](#advanced-props).

### layout

Поведение изображения при изменении размера области просмотра.

| `layout`              | Поведение                                                 | `srcSet`                                                                                                    | `sizes` | Имеет обёртку и размеры |
| --------------------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------- | --------------------- |
| `intrinsic` (по умолчанию) | Уменьшается до ширины контейнера, но не больше оригинального размера | `1x`, `2x` (на основе [imageSizes](#image-sizes))                                                            | N/A     | да                   |
| `fixed`               | Фиксированный размер согласно `width` и `height`                    | `1x`, `2x` (на основе [imageSizes](#image-sizes))                                                            | N/A     | да                   |
| `responsive`          | Масштабируется по ширине контейнера                          | `640w`, `750w`, ... `2048w`, `3840w` (на основе [imageSizes](#image-sizes) и [deviceSizes](#device-sizes)) | `100vw` | да                   |
| `fill`                | Растягивается по осям X и Y для заполнения контейнера              | `640w`, `750w`, ... `2048w`, `3840w` (на основе [imageSizes](#image-sizes) и [deviceSizes](#device-sizes)) | `100vw` | да                   |

- [Демонстрация `intrinsic` layout (по умолчанию)](https://image-legacy-component.nextjs.gallery/layout-intrinsic)
  - При `intrinsic` изображение будет уменьшаться для меньших областей просмотра, но сохранять оригинальные размеры для больших.
- [Демонстрация `fixed` layout](https://image-legacy-component.nextjs.gallery/layout-fixed)
  - При `fixed` размеры изображения не изменяются при изменении области просмотра (без адаптивности), аналогично нативному элементу `img`.
- [Демонстрация `responsive` layout](https://image-legacy-component.nextjs.gallery/layout-responsive)
  - При `responsive` изображение будет уменьшаться для меньших областей просмотра и увеличиваться для больших.
  - Убедитесь, что родительский элемент использует `display: block` в своих стилях.
- [Демонстрация `fill` layout](https://image-legacy-component.nextjs.gallery/layout-fill)
  - При `fill` изображение растягивается по ширине и высоте до размеров родительского элемента, если он имеет относительное позиционирование.
  - Обычно используется в сочетании со свойством [`objectFit`](#objectfit).
  - Убедитесь, что родительский элемент имеет `position: relative` в своих стилях.
- [Демонстрация фонового изображения](https://image-legacy-component.nextjs.gallery/background)

### loader

Пользовательская функция для разрешения URL. Установка loader как пропа компонента Image переопределяет стандартный loader, определённый в [разделе `images` файла `next.config.js`](#loader-configuration).

`loader` — это функция, возвращающая строку URL для изображения, принимающая следующие параметры:

- [`src`](#src)
- [`width`](#width)
- [`quality`](#quality)

Пример использования пользовательского loader:

```js
import Image from 'next/legacy/image'

const myLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}

const MyImage = (props) => {
  return (
    <Image
      loader={myLoader}
      src="me.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

### sizes

Строка, предоставляющая информацию о ширине изображения на разных контрольных точках. Значение `sizes` значительно влияет на производительность для изображений с `layout="responsive"` или `layout="fill"`. Игнорируется для изображений с `layout="intrinsic"` или `layout="fixed"`.

Свойство `sizes` выполняет две важные функции, связанные с производительностью изображений:

Во-первых, значение `sizes` используется браузером для определения, какой размер изображения загружать из автоматически генерируемого набора источников `next/legacy/image`. Когда браузер делает выбор, он ещё не знает размер изображения на странице, поэтому выбирает изображение того же размера или больше, чем область просмотра. Свойство `sizes` позволяет сообщить браузеру, что изображение на самом деле будет меньше, чем полный экран. Если значение `sizes` не указано, используется значение по умолчанию `100vw` (полная ширина экрана).

Во-вторых, значение `sizes` анализируется и используется для обрезки значений в автоматически созданном наборе источников. Если свойство `sizes` включает значения, такие как `50vw`, которые представляют процент от ширины области просмотра, то набор источников обрезается, чтобы исключить значения, которые слишком малы для использования.

Например, если вы знаете, что ваши стили приведут к тому, что изображение будет занимать всю ширину на мобильных устройствах, 2 колонки на планшетах и 3 колонки на десктопах, вы должны указать свойство sizes примерно так:

```js
import Image from 'next/legacy/image'
const Example = () => (
  <div className="grid-element">
    <Image
      src="/example.png"
      layout="fill"
      sizes="(max-width: 768px) 100vw,
              (max-width: 1200px) 50vw,
              33vw"
    />
  </div>
)
```

Этот пример `sizes` может значительно повлиять на показатели производительности. Без `33vw` изображение, загружаемое с сервера, было бы в 3 раза шире, чем необходимо. Поскольку размер файла пропорционален квадрату ширины, без `sizes` пользователь загружал бы изображение в 9 раз больше необходимого.

Подробнее о `srcset` и `sizes`:

- [web.dev](https://web.dev/learn/design/responsive-images/#sizes)
- [mdn](https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-sizes)

### quality

Качество оптимизированного изображения, целое число от `1` до `100`, где `100` — наилучшее качество. По умолчанию `75`.

### priority

Если `true`, изображение будет считаться высокоприоритетным и будет [предзагружено](https://web.dev/preload-responsive-images/). Ленивая загрузка автоматически отключается для изображений с `priority`.

Свойство `priority` следует использовать для любого изображения, определённого как [Largest Contentful Paint (LCP)](https://nextjs.org/learn/seo/web-performance/lcp) элемент. Может быть уместным иметь несколько приоритетных изображений, так как разные изображения могут быть LCP элементами для разных размеров области просмотра.

Следует использовать только для изображений, видимых выше сгиба. По умолчанию `false`.

### placeholder

Заполнитель, используемый во время загрузки изображения. Возможные значения: `blur` или `empty`. По умолчанию `empty`.

При `blur` в качестве заполнителя будет использоваться свойство [`blurDataURL`](#blurdataurl). Если `src` является объектом из [статического импорта](/docs/pages/building-your-application/optimizing/images#local-images) и импортированное изображение имеет расширение `.jpg`, `.png`, `.webp` или `.avif`, то `blurDataURL` будет заполнено автоматически.

Для динамических изображений вы должны предоставить свойство [`blurDataURL`](#blurdataurl). Решения, такие как [Plaiceholder](https://github.com/joe-bell/plaiceholder), могут помочь с генерацией `base64`.

При `empty` во время загрузки изображения не будет заполнителя, только пустое пространство.

Попробуйте:

- [Демонстрация заполнителя `blur`](https://image-legacy-component.nextjs.gallery/placeholder)
- [Демонстрация эффекта мерцания с пропом `blurDataURL`](https://image-legacy-component.nextjs.gallery/shimmer)
- [Демонстрация цветного эффекта с пропом `blurDataURL`](https://image-legacy-component.nextjs.gallery/color)

## Расширенные пропсы

В некоторых случаях может потребоваться более расширенное использование. Компонент `<Image />` опционально принимает следующие расширенные свойства.

### style

Позволяет [передавать CSS стили](https://developer.mozilla.org/docs/Web/HTML/Element/style) к базовому элементу изображения.

Обратите внимание, что все режимы `layout` применяют свои собственные стили к элементу изображения, и эти автоматические стили имеют приоритет над пропом `style`.

Также учитывайте, что обязательные пропсы `width` и `height` могут взаимодействовать с вашими стилями. Если вы используете стили для изменения `width` изображения, вы должны также установить стиль `height="auto"`, иначе изображение будет искажено.

### objectFit

Определяет, как изображение будет заполнять родительский контейнер при использовании `layout="fill"`.

Это значение передаётся в [CSS свойство object-fit](https://developer.mozilla.org/docs/Web/CSS/object-fit) для изображения `src`.

### objectPosition

Определяет позиционирование изображения внутри родительского элемента при использовании `layout="fill"`.

Это значение передаётся в [CSS свойство object-position](https://developer.mozilla.org/docs/Web/CSS/object-position), применяемое к изображению.

### onLoadingComplete

Callback функция, вызываемая после полной загрузки изображения и удаления [заполнителя](#placeholder).

Функция `onLoadingComplete` принимает один параметр — объект со следующими свойствами:

- [`naturalWidth`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/naturalWidth)
- [`naturalHeight`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/naturalHeight)

### loading

> **Внимание**: Это свойство предназначено только для расширенного использования. Установка изображения на загрузку с `eager` обычно **ухудшает производительность**.
>
> Мы рекомендуем использовать свойство [`priority`](#priority) вместо этого, которое правильно загружает изображение eagerly для большинства случаев использования.

Поведение загрузки изображения. По умолчанию `lazy`.

При `lazy` загрузка изображения откладывается до достижения вычисленного расстояния от области просмотра.

При `eager` изображение загружается немедленно.

[Подробнее](https://developer.mozilla.org/docs/Web/HTML/Element/img#attr-loading)

### blurDataURL

[Data URL](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs), используемый в качестве заполнителя до успешной загрузки изображения `src`. Действует только в сочетании с [`placeholder="blur"`](#placeholder).

Должен быть изображением в формате base64. Оно будет увеличено и размыто, поэтому рекомендуется использовать очень маленькое изображение (10px или меньше). Использование больших изображений в качестве заполнителей может ухудшить производительность вашего приложения.

Попробуйте:

- [Демонстрация стандартного пропа `blurDataURL`](https://image-legacy-component.nextjs.gallery/placeholder)
- [Демонстрация эффекта мерцания с пропом `blurDataURL`](https://image-legacy-component.nextjs.gallery/shimmer)
- [Демонстрация цветного эффекта с пропом `blurDataURL`](https://image-legacy-component.nextjs.gallery/color)

Вы также можете [сгенерировать Data URL однотонного цвета](https://png-pixel.com) для соответствия изображению.

### lazyBoundary

Строка (с синтаксисом, аналогичным свойству margin), которая действует как ограничивающая рамка для обнаружения пересечения изображения с областью просмотра и запуска ленивой [загрузки](#loading). По умолчанию `"200px"`.

Если изображение вложено в прокручиваемый родительский элемент, отличный от корневого документа, вам также нужно назначить проп [lazyRoot](#lazyroot).

[Подробнее](https://developer.mozilla.org/docs/Web/API/IntersectionObserver/rootMargin)

### lazyRoot

React [Ref](https://react.dev/learn/referencing-values-with-refs), указывающий на прокручиваемый родительский элемент. По умолчанию `null` (область просмотра документа).

Ref должен указывать на DOM элемент или React компонент, который [передаёт Ref](https://react.dev/reference/react/forwardRef) на базовый DOM элемент.

**Пример указания на DOM элемент**

```jsx
import Image from 'next/legacy/image'
import React from 'react'

const Example = () => {
  const lazyRoot = React.useRef(null)

  return (
    <div ref={lazyRoot} style={{ overflowX: 'scroll', width: '500px' }}>
      <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
      <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
    </div>
  )
}
```

**Пример указания на React компонент**

```jsx
import Image from 'next/legacy/image'
import React from 'react'

const Container = React.forwardRef((props, ref) => {
  return (
    <div ref={ref} style={{ overflowX: 'scroll', width: '500px' }}>
      {props.children}
    </div>
  )
})

const Example = () => {
  const lazyRoot = React.useRef(null)

  return (
    <Container ref={lazyRoot}>
      <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
      <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
    </Container>
  )
}
```

[Подробнее](https://developer.mozilla.org/docs/Web/API/IntersectionObserver/root)

### unoptimized

Когда установлено в `true`, исходное изображение будет отображаться как есть, без изменения качества, размера или формата. По умолчанию `false`.

```js
import Image from 'next/image'

const UnoptimizedImage = (props) => {
  return <Image {...props} unoptimized />
}
```

Начиная с Next.js 12.3.0, это свойство можно применить ко всем изображениям, обновив `next.config.js` следующей конфигурацией:

```js filename="next.config.js"
module.exports = {
  images: {
    unoptimized: true,
  },
}
```

## Другие свойства

Остальные свойства компонента `<Image />` будут переданы базовому элементу `img`, за исключением следующих:

- `srcSet`. Вместо этого используйте [Размеры устройств](#device-sizes).
- `ref`. Вместо этого используйте [`onLoadingComplete`](#onloadingcomplete).
- `decoding`. Всегда установлено в `"async"`.

## Параметры конфигурации

### Шаблоны удалённых изображений

Для защиты вашего приложения от злоумышленников требуется настройка для использования внешних изображений. Это гарантирует, что только изображения из вашего аккаунта будут обрабатываться API оптимизации изображений Next.js. Эти внешние изображения можно настроить с помощью свойства `remotePatterns` в файле `next.config.js`, как показано ниже:

```js filename="next.config.js"
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/account123/**',
      },
    ],
  },
}
```

> **Полезно знать**: В примере выше свойство `src` компонента `next/legacy/image` должно начинаться с `https://example.com/account123/`. Любой другой протокол, имя хоста, порт или несоответствующий путь вызовут ошибку 400 Bad Request.

Ниже приведён ещё один пример свойства `remotePatterns` в файле `next.config.js`:

```js filename="next.config.js"
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',
      },
    ],
  },
}
```

> **Полезно знать**: В примере выше свойство `src` компонента `next/legacy/image` должно начинаться с `https://img1.example.com`, `https://me.avatar.example.com` или любого количества поддоменов. Любой другой протокол или несоответствующее имя хоста вызовут ошибку 400 Bad Request.

Шаблоны с подстановочными знаками можно использовать как для `pathname`, так и для `hostname`, они имеют следующий синтаксис:

- `*` соответствует одному сегменту пути или поддомену
- `**` соответствует любому количеству сегментов пути в конце или поддоменов в начале

Синтаксис `**` не работает в середине шаблона.

### Домены

> **Предупреждение**: Рекомендуем настраивать строгие [`remotePatterns`](#remote-patterns) вместо `domains` для защиты вашего приложения от злоумышленников. Используйте `domains` только если вы владеете всем контентом, обслуживаемым с домена.

Аналогично [`remotePatterns`](#remote-patterns), конфигурация `domains` может использоваться для предоставления списка разрешённых имён хостов для внешних изображений.

Однако конфигурация `domains` не поддерживает подстановочные знаки и не может ограничивать протокол, порт или путь.

Ниже приведён пример свойства `domains` в файле `next.config.js`:

```js filename="next.config.js"
module.exports = {
  images: {
    domains: ['assets.acme.com'],
  },
}
```

### Настройка загрузчика

Если вы хотите использовать облачного провайдера для оптимизации изображений вместо встроенного API оптимизации изображений Next.js, вы можете настроить `loader` и префикс пути в файле `next.config.js`. Это позволяет использовать относительные URL для свойства [`src`](#src) изображения и автоматически генерировать правильный абсолютный URL для вашего провайдера.

```js filename="next.config.js"
module.exports = {
  images: {
    loader: 'imgix',
    path: 'https://example.com/myaccount/',
  },
}
```

### Встроенные загрузчики

Следующие облачные провайдеры оптимизации изображений включены:

- По умолчанию: Работает автоматически с `next dev`, `next start` или пользовательским сервером
- [Vercel](https://vercel.com): Работает автоматически при развертывании на Vercel, не требует настройки. [Подробнее](https://vercel.com/docs/concepts/image-optimization?utm_source=next-site&utm_medium=docs&utm_campaign=next-website)
- [Imgix](https://www.imgix.com): `loader: 'imgix'`
- [Cloudinary](https://cloudinary.com): `loader: 'cloudinary'`
- [Akamai](https://www.akamai.com): `loader: 'akamai'`
- Пользовательский: `loader: 'custom'` используйте собственного облачного провайдера, реализовав свойство [`loader`](#loader) в компоненте `next/legacy/image`

Если вам нужен другой провайдер, вы можете использовать свойство [`loader`](#loader) с `next/legacy/image`.

> Изображения не могут быть оптимизированы во время сборки с использованием [`output: 'export'`](/docs/pages/building-your-application/deploying/static-exports), только по запросу. Чтобы использовать `next/legacy/image` с `output: 'export'`, вам потребуется использовать загрузчик, отличный от стандартного. [Подробнее в обсуждении.](https://github.com/vercel/next.js/discussions/19065)

> Стандартный загрузчик компонента `next/legacy/image` использует [`squoosh`](https://www.npmjs.com/package/@squoosh/lib), так как он быстро устанавливается и подходит для среды разработки. При использовании `next start` в production-среде настоятельно рекомендуется установить [`sharp`](https://www.npmjs.com/package/sharp), выполнив `npm i sharp` в директории проекта. Это не требуется для развертываний на Vercel, так как `sharp` устанавливается автоматически.

## Продвинутые настройки

Следующая конфигурация предназначена для сложных случаев использования и обычно не требуется. Если вы решите настроить указанные ниже свойства, вы переопределите любые изменения стандартных настроек Next.js в будущих обновлениях.

### Размеры устройств

Если вы знаете ожидаемую ширину устройств ваших пользователей, вы можете указать список точек останова ширины устройств с помощью свойства `deviceSizes` в `next.config.js`. Эти ширины используются, когда компонент `next/legacy/image` использует `layout="responsive"` или `layout="fill"`, чтобы гарантировать, что правильное изображение будет обслуживаться для устройства пользователя.

Если конфигурация не предоставлена, используется стандартный набор, указанный ниже.

```js filename="next.config.js"
module.exports = {
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  },
}
```

### Размеры изображений

Вы можете указать список ширин изображений с помощью свойства `images.imageSizes` в файле `next.config.js`. Эти ширины объединяются с массивом [размеров устройств](#device-sizes), чтобы сформировать полный набор размеров, используемых для генерации [srcset](https://developer.mozilla.org/docs/Web/API/HTMLImageElement/srcset) изображений.

Причина разделения на два списка в том, что `imageSizes` используется только для изображений, которые предоставляют свойство [`sizes`](#sizes), указывающее, что изображение меньше полной ширины экрана. **Поэтому размеры в `imageSizes` должны быть меньше, чем наименьший размер в `deviceSizes`.**

Если конфигурация не предоставлена, используется стандартный набор, указанный ниже.

```js filename="next.config.js"
module.exports = {
  images: {
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
}
```

### Поддерживаемые форматы

Стандартный [API оптимизации изображений](#loader-configuration) автоматически определяет поддерживаемые браузером форматы изображений через заголовок `Accept` запроса.

Если заголовок `Accept` соответствует более чем одному из настроенных форматов, используется первое совпадение в массиве. Поэтому порядок элементов в массиве имеет значение. Если совпадений нет (или исходное изображение [анимировано](#animated-images)), API оптимизации изображений вернётся к исходному формату изображения.

Если конфигурация не предоставлена, используется стандартный набор, указанный ниже.

```js filename="next.config.js"
module.exports = {
  images: {
    formats: ['image/webp'],
  },
}
```

Вы можете включить поддержку AVIF следующей конфигурацией.

```js filename="next.config.js"
module.exports = {
  images: {
    formats: ['image/avif', 'image/webp'],
  },
}
```

> **Полезно знать**: AVIF обычно занимает на 20% больше времени для кодирования, но сжимается на 20% лучше по сравнению с WebP. Это означает, что при первом запросе изображения оно обычно будет обрабатываться медленнее, но последующие запросы, которые кэшируются, будут быстрее.

## Поведение кэширования

Ниже описаны алгоритмы кэширования для стандартного [загрузчика](#loader). Для всех других загрузчиков обратитесь к документации вашего облачного провайдера.

Изображения оптимизируются динамически по запросу и сохраняются в директории `<distDir>/cache/images`. Оптимизированный файл изображения будет обслуживаться для последующих запросов до истечения срока действия. Когда поступает запрос, соответствующий кэшированному, но устаревшему файлу, устаревшее изображение сразу же возвращается. Затем изображение повторно оптимизируется в фоновом режиме (так называемая ревалидация) и сохраняется в кэше с новой датой истечения срока действия.

Статус кэша изображения можно определить, прочитав значение заголовка ответа `x-nextjs-cache` (`x-vercel-cache` при развертывании на Vercel). Возможные значения:

- `MISS` - путь отсутствует в кэше (происходит максимум один раз, при первом посещении)
- `STALE` - путь есть в кэше, но превышено время ревалидации, поэтому он будет обновлён в фоновом режиме
- `HIT` - путь есть в кэше и не превышено время ревалидации

Срок действия (или, точнее, Max Age) определяется либо конфигурацией [`minimumCacheTTL`](#minimum-cache-ttl), либо заголовком `Cache-Control` исходного изображения, в зависимости от того, что больше. В частности, используется значение `max-age` заголовка `Cache-Control`. Если найдены и `s-maxage`, и `max-age`, предпочтение отдаётся `s-maxage`. Значение `max-age` также передаётся всем нижестоящим клиентам, включая CDN и браузеры.

- Вы можете настроить [`minimumCacheTTL`](#minimum-cache-ttl), чтобы увеличить срок кэширования, когда исходное изображение не включает заголовок `Cache-Control` или его значение очень мало.
- Вы можете настроить [`deviceSizes`](#device-sizes) и [`imageSizes`](#image-sizes), чтобы уменьшить общее количество возможных генерируемых изображений.
- Вы можете настроить [форматы](#acceptable-formats), чтобы отключить несколько форматов в пользу одного.

### Минимальное время жизни кэша

Вы можете настроить время жизни (TTL) в секундах для кэшированных оптимизированных изображений. Во многих случаях лучше использовать [статический импорт изображений](/docs/pages/building-your-application/optimizing/images#local-images), который автоматически хэширует содержимое файла и кэширует изображение навсегда с заголовком `Cache-Control: immutable`.

```js filename="next.config.js"
module.exports = {
  images: {
    minimumCacheTTL: 60,
  },
}
```

Срок действия (или Max Age) оптимизированного изображения определяется либо `minimumCacheTTL`, либо заголовком `Cache-Control` исходного изображения, в зависимости от того, что больше.

Если вам нужно изменить поведение кэширования для конкретного изображения, вы можете настроить [`headers`](/docs/pages/api-reference/next-config-js/headers), чтобы установить заголовок `Cache-Control` для исходного изображения (например, `/some-asset.jpg`, а не `/_next/image`).

На данный момент нет механизма для инвалидации кэша, поэтому лучше держать `minimumCacheTTL` небольшим. В противном случае вам может потребоваться вручную изменить свойство [`src`](#src) или удалить `<distDir>/cache/images`.

### Отключение статического импорта

Стандартное поведение позволяет импортировать статические файлы, такие как `import icon from './icon.png'`, а затем передавать их в свойство `src`.

В некоторых случаях может потребоваться отключить эту функцию, если она конфликтует с другими плагинами, которые ожидают другого поведения импорта.

Вы можете отключить статический импорт изображений в файле `next.config.js`:

```js filename="next.config.js"
module.exports = {
  images: {
    disableStaticImages: true,
  },
}
```

### Опасное разрешение SVG

Стандартный [загрузчик](#loader) не оптимизирует SVG-изображения по нескольким причинам. Во-первых, SVG — это векторный формат, что означает возможность изменения размера без потерь. Во-вторых, SVG имеет множество функций, аналогичных HTML/CSS, что может привести к уязвимостям без правильных [заголовков Content Security Policy (CSP)](/docs/app/api-reference/next-config-js/headers).

Если вам нужно обслуживать SVG-изображения с помощью стандартного API оптимизации изображений, вы можете установить `dangerouslyAllowSVG` в файле `next.config.js`:

```js filename="next.config.js"
module.exports = {
  images: {
    dangerouslyAllowSVG: true,
    contentDispositionType: 'attachment',
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
}
```

Кроме того, настоятельно рекомендуется также установить `contentDispositionType`, чтобы заставить браузер загружать изображение, а также `contentSecurityPolicy`, чтобы предотвратить выполнение скриптов, встроенных в изображение.

### Анимированные изображения

Стандартный [загрузчик](#loader) автоматически пропустит оптимизацию для анимированных изображений и будет обслуживать изображение как есть.

Автоопределение анимированных файлов работает по принципу best-effort и поддерживает GIF, APNG и WebP. Если вы хотите явно отключить оптимизацию для определённого анимированного изображения, используйте свойство [unoptimized](#unoptimized).

## История версий

| Версия    | Изменения                                     |
| --------- | --------------------------------------------- |
| `v13.0.0` | `next/image` переименован в `next/legacy/image` |
