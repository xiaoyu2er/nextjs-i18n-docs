---
source-updated-at: 2025-05-29T18:05:49.000Z
translation-updated-at: 2025-06-02T19:32:41.712Z
title: Улучшения использования памяти в Webpack для Next.js 8
description: >-
  Недавно была выпущена версия Next.js 8. Этот релиз включал значительное снижение
  использования памяти во время сборки. В этой статье мы расскажем, как нам удалось
  оптимизировать webpack для всего сообщества.
author:
  - name: Коннор Дэвис
    image: /static/team/connor.jpg
  - name: Тим Нойткенс
    image: /static/team/tim.jpg
date: 2019-02-19T14:00:00.000Z
image: >-
  https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/webpack-memory/twitter-card.png
---

Недавно была представлена [Next.js 8](/blog/next-8). Этот релиз включал значительное снижение использования памяти во время сборки. В этой статье мы расскажем, как нам удалось оптимизировать webpack для всего сообщества.

Next.js — это фреймворк с нулевой конфигурацией, построенный на таких инструментах, как [webpack](https://webpack.js.org/) и [Babel](https://babeljs.io). Его цель — помочь вам сосредоточиться на важном: коде вашего приложения.

Современные веб-приложения состоят из одной или нескольких страниц. Например, главная страница, блог, панель управления или список товаров.

В Next.js эти страницы становятся файлами в специальной директории `pages` в корне вашего проекта.

Например: файл `pages/about.js` соответствует URL `/about`.

Одно из ключевых ограничений фреймворка — он должен хорошо работать как для одной страницы, так и для тысяч страниц.

Во время реализации [Serverless Next.js](/blog/next-8#serverless-nextjs) быстро стало очевидно, что запуск `next build` для проекта с сотнями страниц приводит к высокому использованию памяти. Иногда превышая лимит кучи памяти Node.js примерно в 1,4 ГБ.

Мы начали профилировать использование памяти во время сборки с помощью инструментов разработчика Chrome.

В полученных профилях мы обнаружили момент, когда webpack выделял **548 МБ** памяти за один раз.

Объем выделяемой памяти напрямую зависел от количества страниц: больше страниц — больше использование памяти.

![Инструмент профилирования памяти Chrome Developer Tools показал выделение 548 МБ за один раз](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/webpack-memory/allocation-before.png)

Инструмент профилирования памяти Chrome Developer Tools показал выделение 548 МБ за один раз

Изучив стек вызовов в профиле памяти, мы смогли найти функцию, которая вызывала скачок выделения памяти.

Само выделение происходило при вызове [`source.source()`](https://github.com/webpack/webpack/blob/v4.28.4/lib/Compiler.js#L334), который генерирует итоговый файл и сохраняет его в память.

Однако, если посмотреть выше на функцию, вызывающую `source()`, можно увидеть, что [`compilation.assets`](https://github.com/webpack/webpack/blob/v4.28.4/lib/Compiler.js#L316) перебирался с помощью `asyncLib.forEach`. Это означает, что [предоставленная функция](https://github.com/webpack/webpack/blob/v4.28.4/lib/Compiler.js#L317) вызывалась для каждого файла в массиве `compilation.assets` одновременно.

Таким образом, если, например, есть 100 страниц, и каждая страница должна быть записана на диск, приведенный выше код пытался бы записать все 100 одновременно, включая генерацию всех 100 файлов сразу.

Решение этой проблемы — использование [семафора](https://ru.wikipedia.org/wiki/Семафор_(информатика)) для ограничения количества одновременных записей. Обычно мы используем для этого [async-sema](https://github.com/vercel/async-sema), но в данном случае в webpack уже был подходящий метод в [neo-async](https://github.com/webpack/webpack/blob/v4.28.4/lib/Compiler.js#L8):

```
asyncLib.forEach(compilation.assets, (source, file, callback) => {
  // и т.д.
});
```

> Предыдущий код, который выполнял функцию для всех ассетов одновременно

```
asyncLib.forEachLimit(compilation.assets, 15, (source, file, callback) => {
  // и т.д.
});
```

> Новый код, который выполняет функцию одновременно максимум для 15 ассетов

После реализации этого ограничения параллелизма и повторного профилирования использования памяти мы увидели, что выделение памяти разделилось на меньшие части по **34 МБ**.

![Профайлер теперь показывал выделение памяти порциями по 34 МБ с течением времени](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/webpack-memory/after-limiting.png)

Профайлер теперь показывал выделение памяти порциями по 34 МБ с течением времени

Это изменение показало очень многообещающие результаты, но на практике сборка все равно выходила за пределы памяти, поэтому мы продолжили профилирование и исследование проблемы.

Дальнейший анализ профиля памяти показал, что после вызова [`source.source()`](https://github.com/webpack/webpack/blob/v4.28.4/lib/Compiler.js#L334) память не очищалась (не происходила сборка мусора).

В webpack ассеты обычно являются экземплярами [классов Source](https://github.com/webpack/webpack-sources). Эти классы реализуют метод `source()`, который генерирует исходный код файла.

Профиль показал, что многие ассеты были экземплярами [`CachedSource`](https://github.com/webpack/webpack-sources#cachedsource). `CachedSource` работает так, что при вызове `source()` результат кэшируется в памяти до тех пор, пока ассет не будет удален.

Проверка плагинов webpack, используемых в Next.js, показала, что у нас не было плагинов, вызывающих `source()` после того, как webpack записывал файл, а значит, кэширование записанного значения не давало преимуществ.

После [совместной работы](https://github.com/webpack/webpack/pull/8609) с [Тобиасом Копперсом](https://twitter.com/wSokra) он [реализовал новую опцию `output.futureEmitAssets`](https://github.com/webpack/webpack/pull/8642), которая позволяет включить новое поведение записи ассетов.

С этим новым поведением выделяемые блоки памяти сократились до **_182 КБ_** с течением времени.

![После всех оптимизаций профайлер показывает выделение памяти порциями по 184 КБ с течением времени](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/webpack-memory/allocation-after.png)

После всех оптимизаций профайлер показывает выделение памяти порциями по 184 КБ с течением времени

[Next.js 8](/blog/next-8) уже включает все эти оптимизации. При использовании Next.js ничего менять не нужно.

Эта оптимизация была внедрена в webpack, а значит, не только пользователи Next.js, но и все пользователи webpack получат выгоду от этих улучшений.

Мы продолжим активно улучшать использование памяти и производительность Next.js и webpack.