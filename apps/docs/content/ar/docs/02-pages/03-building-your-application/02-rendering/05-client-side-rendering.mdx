---
source-updated-at: 2025-05-21T18:33:43.000Z
translation-updated-at: 2025-06-02T20:04:39.788Z
title: التصيير من جانب العميل (CSR)
description: تعلم كيفية تنفيذ التصيير من جانب العميل في موجه الصفحات (Pages Router).
related:
  description: تعرف على طرق التصيير البديلة في Next.js.
  links:
    - pages/building-your-application/rendering/server-side-rendering
    - pages/building-your-application/rendering/static-site-generation
    - pages/guides/incremental-static-regeneration
    - app/building-your-application/routing/loading-ui-and-streaming
---

في التصيير من جانب العميل (CSR) مع React، يقوم المتصفح بتحميل صفحة HTML أساسية وشفرة JavaScript اللازمة للصفحة. ثم يتم استخدام JavaScript لتحديث DOM وتصيير الصفحة. عند التحميل الأول للتطبيق، قد يلاحظ المستخدم تأخيرًا بسيطًا قبل رؤية الصفحة كاملة، وذلك لأن الصفحة لا تُصيَّر بالكامل إلا بعد تنزيل جميع شفرات JavaScript وتحليلها وتنفيذها.

بعد تحميل الصفحة لأول مرة، يكون التنقل بين الصفحات الأخرى على نفس الموقع أسرع عادةً، حيث يحتاج فقط إلى جلب البيانات الضرورية، ويمكن لـ JavaScript إعادة تصيير أجزاء من الصفحة دون الحاجة إلى تحديث كامل للصفحة.

في Next.js، هناك طريقتان لتنفيذ التصيير من جانب العميل:

1. استخدام خطاف React `useEffect()` داخل صفحاتك بدلاً من طرق التصيير من جانب الخادم ([`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) و [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props)).
2. استخدام مكتبة لجلب البيانات مثل [SWR](https://swr.vercel.app/) أو [TanStack Query](https://tanstack.com/query/latest/) لجلب البيانات من جانب العميل (مُوصى به).

إليك مثالاً لاستخدام `useEffect()` داخل صفحة Next.js:

```jsx filename="pages/index.js"
import React, { useState, useEffect } from 'react'

export function Page() {
  const [data, setData] = useState(null)

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data')
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      const result = await response.json()
      setData(result)
    }

    fetchData().catch((e) => {
      // التعامل مع الخطأ حسب الحاجة
      console.error('حدث خطأ أثناء جلب البيانات: ', e)
    })
  }, [])

  return <p>{data ? `بياناتك: ${data}` : 'جاري التحميل...'}</p>
}
```

في المثال أعلاه، يبدأ المكون بعرض "جاري التحميل...". ثم بمجرد جلب البيانات، يعيد التصيير ويعرض البيانات.

على الرغم من أن جلب البيانات باستخدام `useEffect` هو نمط قد تراه في تطبيقات React القديمة، إلا أننا نوصي باستخدام مكتبة لجلب البيانات لتحسين الأداء، التخزين المؤقت، التحديثات التفاؤلية، والمزيد. إليك مثال بسيط باستخدام [SWR](https://swr.vercel.app/) لجلب البيانات من جانب العميل:

```jsx filename="pages/index.js"
import useSWR from 'swr'

export function Page() {
  const { data, error, isLoading } = useSWR(
    'https://api.example.com/data',
    fetcher
  )

  if (error) return <p>فشل التحميل.</p>
  if (isLoading) return <p>جاري التحميل...</p>

  return <p>بياناتك: {data}</p>
}
```

> **معلومة مفيدة**:
>
> ضع في اعتبارك أن CSR يمكن أن يؤثر على تحسين محركات البحث (SEO). قد لا تقوم بعض زواحف محركات البحث بتنفيذ JavaScript وبالتالي ترى فقط الحالة الأولية الفارغة أو حالة التحميل لتطبيقك. كما يمكن أن يؤدي إلى مشاكل أداء للمستخدمين الذين لديهم اتصال إنترنت بطيء أو أجهزة ضعيفة، حيث يحتاجون إلى انتظار تحميل وتنفيذ جميع شفرات JavaScript قبل رؤية الصفحة كاملة. يشجع Next.js على نهج هجين يسمح لك باستخدام مزيج من [التصيير من جانب الخادم](/docs/pages/building-your-application/rendering/server-side-rendering)، [التوليد الثابت للموقع](/docs/pages/building-your-application/rendering/static-site-generation)، والتصيير من جانب العميل، **حسب احتياجات كل صفحة** في تطبيقك. في موجه التطبيق (App Router)، يمكنك أيضًا استخدام [واجهة التحميل مع Suspense](/docs/app/building-your-application/routing/loading-ui-and-streaming) لعرض مؤشر تحميل أثناء تصيير الصفحة.