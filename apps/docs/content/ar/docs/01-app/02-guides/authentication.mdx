---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T22:19:26.550Z
title: كيفية تنفيذ المصادقة في Next.js
nav_title: المصادقة
description: تعلم كيفية تنفيذ المصادقة في تطبيق Next.js الخاص بك.
---

فهم المصادقة أمر بالغ الأهمية لحماية بيانات تطبيقك. سيرشدك هذه الصفحة إلى ميزات React وNext.js التي يمكن استخدامها لتنفيذ المصادقة.

قبل البدء، من المفيد تقسيم العملية إلى ثلاثة مفاهيم:

1. **[المصادقة](#authentication)**: التحقق مما إذا كان المستخدم هو من يدعي أنه هو. يتطلب من المستخدم إثبات هويته بشيء يمتلكه، مثل اسم المستخدم وكلمة المرور.
2. **[إدارة الجلسة](#session-management)**: تتبع حالة مصادقة المستخدم عبر الطلبات.
3. **[الترخيص](#authorization)**: تحديد المسارات والبيانات التي يمكن للمستخدم الوصول إليها.

يظهر هذا الرسم التخطيطي تدفق المصادقة باستخدام ميزات React وNext.js:

<Image
  alt="رسم تخطيطي يظهر تدفق المصادقة بميزات React وNext.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

تقدم الأمثلة في هذه الصفحة شرحًا أساسيًا لمصادقة اسم المستخدم وكلمة المرور لأغراض تعليمية. بينما يمكنك تنفيذ حل مصادقة مخصص، نوصي باستخدام مكتبة مصادقة لزيادة الأمان والبساطة. توفر هذه المكتبات حلولًا مدمجة للمصادقة وإدارة الجلسات والترخيص، بالإضافة إلى ميزات إضافية مثل تسجيلات الدخول الاجتماعية والمصادقة متعددة العوامل والتحكم في الوصول القائم على الأدوار. يمكنك العثور على قائمة في قسم [مكتبات المصادقة](#auth-libraries).

## المصادقة

<AppOnly>

### وظائف التسجيل وتسجيل الدخول

يمكنك استخدام عنصر [`<form>`](https://react.dev/reference/react-dom/components/form) مع [إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) في React و`useActionState` لالتقاط بيانات اعتماد المستخدم والتحقق من صحة حقول النموذج واستدعاء واجهة برمجة التطبيقات أو قاعدة البيانات الخاصة بمزود المصادقة.

نظرًا لأن إجراءات الخادم تنفذ دائمًا على الخادم، فإنها توفر بيئة آمنة للتعامل مع منطق المصادقة.

إليك الخطوات لتنفيذ وظائف التسجيل/تسجيل الدخول:

#### 1. التقاط بيانات اعتماد المستخدم

للتقاط بيانات اعتماد المستخدم، أنشئ نموذجًا يستدعي إجراء خادم عند الإرسال. على سبيل المثال، نموذج تسجيل يقبل اسم المستخدم والبريد الإلكتروني وكلمة المرور:

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. التحقق من صحة حقول النموذج على الخادم

استخدم إجراء الخادم للتحقق من صحة حقول النموذج على الخادم. إذا كان مزود المصادقة لا يوفر التحقق من صحة النموذج، يمكنك استخدام مكتبة تحقق من المخطط مثل [Zod](https://zod.dev/) أو [Yup](https://github.com/jquense/yup).

باستخدام Zod كمثال، يمكنك تحديد مخطط نموذج مع رسائل خطأ مناسبة:

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})
```

لمنع استدعاءات غير ضرورية لواجهة برمجة التطبيقات أو قاعدة البيانات الخاصة بمزود المصادقة، يمكنك `إرجاع` مبكرًا في إجراء الخادم إذا كانت أي حقول نموذج لا تتطابق مع المخطط المحدد.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Call the provider or db to create a user...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Call the provider or db to create a user...
}
```

في نموذج `<SignupForm />` الخاص بك، يمكنك استخدام خطاف `useActionState` في React لعرض أخطاء التحقق أثناء إرسال النموذج:

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" placeholder="Email" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>Password must:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Sign Up
      </button>
    </form>
  )
}
```

> **جيد أن تعرف:**
>
> - في React 19، يتضمن `useFormStatus` مفاتيح إضافية على الكائن المعاد، مثل data وmethod وaction. إذا كنت لا تستخدم React 19، فإن المفتاح `pending` فقط متاح.
> - قبل تعديل البيانات، يجب عليك دائمًا التأكد من أن المستخدم مصرح له أيضًا بتنفيذ الإجراء. راجع [المصادقة والترخيص](#authorization).

#### ٣. إنشاء مستخدم أو التحقق من بيانات الاعتماد

بعد التحقق من حقول النموذج، يمكنك إنشاء حساب مستخدم جديد أو التحقق من وجود المستخدم عن طريق استدعاء واجهة برمجة التطبيقات (API) أو قاعدة البيانات الخاصة بمزود المصادقة.

متابعة من المثال السابق:

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. التحقق من حقول النموذج
  // ...

  // 2. تحضير البيانات للإدراج في قاعدة البيانات
  const { name, email, password } = validatedFields.data
  // مثلاً: تشفير كلمة مرور المستخدم قبل تخزينها
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. إدراج المستخدم في قاعدة البيانات أو استدعاء واجهة برمجة التطبيقات لمكتبة المصادقة
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'حدث خطأ أثناء إنشاء حسابك.',
    }
  }

  // TODO:
  // 4. إنشاء جلسة المستخدم
  // 5. توجيه المستخدم
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. التحقق من حقول النموذج
  // ...

  // 2. تحضير البيانات للإدراج في قاعدة البيانات
  const { name, email, password } = validatedFields.data
  // مثلاً: تشفير كلمة مرور المستخدم قبل تخزينها
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. إدراج المستخدم في قاعدة البيانات أو استدعاء واجهة برمجة التطبيقات لمكتبة المصادقة
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'حدث خطأ أثناء إنشاء حسابك.',
    }
  }

  // TODO:
  // 4. إنشاء جلسة المستخدم
  // 5. توجيه المستخدم
}
```

بعد إنشاء حساب المستخدم بنجاح أو التحقق من بيانات الاعتماد، يمكنك إنشاء جلسة لإدارة حالة مصادقة المستخدم. اعتمادًا على استراتيجية إدارة الجلسة، يمكن تخزين الجلسة في ملف تعريف الارتباط (cookie) أو قاعدة البيانات، أو كليهما. انتقل إلى قسم [إدارة الجلسة](#session-management) لمعرفة المزيد.

> **نصائح:**
>
> - المثال أعلاه مفصل لأنه يفصل خطوات المصادقة لأغراض تعليمية. هذا يسلط الضوء على أن تنفيذ حل آمن خاص بك يمكن أن يصبح معقدًا بسرعة. فكر في استخدام [مكتبة مصادقة](#auth-libraries) لتبسيط العملية.
> - لتحسين تجربة المستخدم، قد ترغب في التحقق من تكرار البريد الإلكتروني أو اسم المستخدم في وقت مبكر من عملية التسجيل. على سبيل المثال، أثناء كتابة المستخدم لاسم المستخدم أو عند فقدان حقل الإدخال للتركيز. يمكن أن يساعد ذلك في منع عمليات إرسال النماذج غير الضرورية وتقديم ملاحظات فورية للمستخدم. يمكنك التحكم في تكرار هذه الفحوصات باستخدام مكتبات مثل [use-debounce](https://www.npmjs.com/package/use-debounce).

</AppOnly>

<PagesOnly>

إليك خطوات تنفيذ نموذج تسجيل و/أو تسجيل الدخول:

١. يقدم المستخدم بيانات الاعتماد الخاصة به من خلال نموذج.
٢. يرسل النموذج طلبًا يتم معالجته بواسطة مسار API.
٣. عند التحقق الناجح، تكتمل العملية، مما يشير إلى نجاح مصادقة المستخدم.
٤. إذا فشل التحقق، يتم عرض رسالة خطأ.

ضع في اعتبارك نموذج تسجيل الدخول حيث يمكن للمستخدمين إدخال بيانات الاعتماد الخاصة بهم:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // معالجة الأخطاء
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="البريد الإلكتروني" required />
      <input type="password" name="password" placeholder="كلمة المرور" required />
      <button type="submit">تسجيل الدخول</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // معالجة الأخطاء
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="البريد الإلكتروني" required />
      <input type="password" name="password" placeholder="كلمة المرور" required />
      <button type="submit">تسجيل الدخول</button>
    </form>
  )
}
```

يحتوي النموذج أعلاه على حقلين إدخال لجمع البريد الإلكتروني وكلمة المرور للمستخدم. عند الإرسال، يتم تشغيل وظيفة ترسل طلب POST إلى مسار API (`/api/auth/login`).

يمكنك بعد ذلك استدعاء واجهة برمجة التطبيقات الخاصة بمزود المصادقة في مسار API لمعالجة المصادقة:

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'بيانات الاعتماد غير صالحة.' })
    } else {
      res.status(500).json({ error: 'حدث خطأ ما.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'بيانات الاعتماد غير صالحة.' })
    } else {
      res.status(500).json({ error: 'حدث خطأ ما.' })
    }
  }
}
```

</PagesOnly>

## إدارة الجلسة

تضمن إدارة الجلسة الحفاظ على حالة مصادقة المستخدم عبر الطلبات. وهي تشمل إنشاء وتخزين وتحديث وحذف الجلسات أو الرموز (tokens).

هناك نوعان من الجلسات:

١. [**بدون حالة (Stateless)**](#stateless-sessions): يتم تخزين بيانات الجلسة (أو الرمز) في ملفات تعريف الارتباط (cookies) للمتصفح. يتم إرسال ملف تعريف الارتباط مع كل طلب، مما يسمح بالتحقق من الجلسة على الخادم. هذه الطريقة أبسط، ولكن يمكن أن تكون أقل أمانًا إذا لم يتم تنفيذها بشكل صحيح.
٢. [**قاعدة البيانات (Database)**](#database-sessions): يتم تخزين بيانات الجلسة في قاعدة بيانات، مع تلقي متصفح المستخدم فقط لمعرف الجلسة المشفر. هذه الطريقة أكثر أمانًا، ولكن يمكن أن تكون معقدة وتستخدم موارد أكثر على الخادم.

> **من الجيد معرفة:** بينما يمكنك استخدام أي من الطريقتين، أو كليهما، نوصي باستخدام مكتبة إدارة جلسات مثل [iron-session](https://github.com/vvo/iron-session) أو [Jose](https://github.com/panva/jose).

### الجلسات بدون حالة (Stateless)

<AppOnly>

لإنشاء وإدارة الجلسات بدون حالة، هناك بعض الخطوات التي تحتاج إلى اتباعها:

١. إنشاء مفتاح سري، والذي سيتم استخدامه لتوقيع جلسة العمل الخاصة بك، وتخزينه كـ [متغير بيئي](/docs/app/guides/environment-variables).
٢. كتابة منطق لتشفير/فك تشفير بيانات الجلسة باستخدام مكتبة إدارة الجلسات.
٣. إدارة ملفات تعريف الارتباط باستخدام واجهة برمجة التطبيقات [`cookies`](/docs/app/api-reference/functions/cookies) الخاصة بـ Next.js.

بالإضافة إلى ما سبق، ضع في اعتبارك إضافة وظيفة [لتحديث (أو تجديد)](#updating-or-refreshing-sessions) الجلسة عندما يعود المستخدم إلى التطبيق، و[حذف](#deleting-the-session) الجلسة عندما يقوم المستخدم بتسجيل الخروج.

> **من الجيد معرفة:** تحقق مما إذا كانت [مكتبة المصادقة](#auth-libraries) الخاصة بك تتضمن إدارة الجلسات.

#### ١. إنشاء مفتاح سري

هناك بعض الطرق التي يمكنك من خلالها إنشاء مفتاح سري لتوقيع جلسة العمل الخاصة بك. على سبيل المثال، يمكنك اختيار استخدام أمر `openssl` في طرفيتك:

```bash filename="terminal"
openssl rand -base64 32
```

ينشئ هذا الأمر سلسلة عشوائية مكونة من 32 حرفًا يمكنك استخدامها كمفتاح سري وتخزينها في [ملف المتغيرات البيئية](/docs/app/guides/environment-variables):

```bash filename=".env"
SESSION_SECRET=your_secret_key
```

يمكنك بعد ذلك الرجوع إلى هذا المفتاح في منطق إدارة الجلسة:

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### ٢. تشفير وفك تشفير الجلسات

بعد ذلك، يمكنك استخدام [مكتبة إدارة الجلسات](#session-management-libraries) المفضلة لديك لتشفير وفك تشفير الجلسات. متابعة من المثال السابق، سنستخدم [Jose](https://www.npmjs.com/package/jose) (متوافق مع [Edge Runtime](/docs/app/api-reference/edge)) وحزمة [`server-only`](https://www.npmjs.com/package/server-only) الخاصة بـ React لضمان تنفيذ منطق إدارة الجلسة فقط على الخادم.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('فشل التحقق من الجلسة')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('فشل التحقق من الجلسة')
  }
}
```

> **نصائح:**
>
> - يجب أن يحتوي الحمولة (payload) على **الحد الأدنى** من بيانات المستخدم الفريدة التي سيتم استخدامها في الطلبات اللاحقة، مثل معرف المستخدم، الدور، إلخ. لا ينبغي أن تحتوي على معلومات تعريف شخصية مثل رقم الهاتف، عنوان البريد الإلكتروني، معلومات بطاقة الائتمان، إلخ، أو بيانات حساسة مثل كلمات المرور.

#### ٣. تعيين ملفات تعريف الارتباط (خيارات موصى بها)

لتخزين الجلسة في ملف تعريف ارتباط، استخدم واجهة برمجة التطبيقات [`cookies`](/docs/app/api-reference/functions/cookies) الخاصة بـ Next.js. يجب تعيين ملف تعريف الارتباط على الخادم، ويتضمن الخيارات الموصى بها:

- **HttpOnly**: يمنع JavaScript من الوصول إلى ملف تعريف الارتباط من جانب العميل.
- **Secure**: استخدم https لإرسال ملف تعريف الارتباط.
- **SameSite**: حدد ما إذا كان يمكن إرسال ملف تعريف الارتباط مع طلبات cross-site.
- **Max-Age أو Expires**: احذف ملف تعريف الارتباط بعد فترة معينة.
- **Path**: حدد مسار URL لملف تعريف الارتباط.

يرجى الرجوع إلى [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) لمزيد من المعلومات حول كل من هذه الخيارات.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

بالعودة إلى إجراء الخادم الخاص بك، يمكنك استدعاء الدالة `createSession()`، واستخدام واجهة برمجة التطبيقات [`redirect()`](/docs/app/guides/redirecting) لتوجيه المستخدم إلى الصفحة المناسبة:

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // الخطوات السابقة:
  // 1. التحقق من حقول النموذج
  // 2. تحضير البيانات للإدراج في قاعدة البيانات
  // 3. إدراج المستخدم في قاعدة البيانات أو استدعاء واجهة برمجة التطبيقات لمكتبة المصادقة

  // الخطوات الحالية:
  // 4. إنشاء جلسة المستخدم
  await createSession(user.id)
  // 5. توجيه المستخدم
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // الخطوات السابقة:
  // 1. التحقق من حقول النموذج
  // 2. تحضير البيانات للإدراج في قاعدة البيانات
  // 3. إدراج المستخدم في قاعدة البيانات أو استدعاء واجهة برمجة التطبيقات لمكتبة المصادقة

  // الخطوات الحالية:
  // 4. إنشاء جلسة المستخدم
  await createSession(user.id)
  // 5. توجيه المستخدم
  redirect('/profile')
}
```

> **نصائح:**
>
> - **يجب تعيين ملفات تعريف الارتباط على الخادم** لمنع العبث من جانب العميل.
> - 🎥 شاهد: تعرف على المزيد حول الجلسات بدون حالة والمصادقة مع Next.js → [YouTube (11 دقيقة)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### تحديث (أو تجديد) الجلسات

يمكنك أيضًا تمديد وقت انتهاء صلاحية الجلسة. هذا مفيد لإبقاء المستخدم مسجل الدخول بعد عودته إلى التطبيق. على سبيل المثال:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **نصيحة:** تحقق مما إذا كانت مكتبة المصادقة الخاصة بك تدعم رموز التحديث (refresh tokens)، والتي يمكن استخدامها لتمديد جلسة المستخدم.

#### حذف الجلسة

لحذف الجلسة، يمكنك حذف ملف تعريف الارتباط (cookie):

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

ثم يمكنك إعادة استخدام دالة `deleteSession()` في تطبيقك، على سبيل المثال عند تسجيل الخروج:

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### تعيين وحذف ملفات تعريف الارتباط

يمكنك استخدام [مسارات API](/docs/pages/building-your-application/routing/api-routes) لتعيين الجلسة كملف تعريف ارتباط على الخادم:

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // أسبوع واحد
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'تم تعيين ملف تعريف الارتباط بنجاح!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // أسبوع واحد
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'تم تعيين ملف تعريف الارتباط بنجاح!' })
}
```

</PagesOnly>

### جلسات قاعدة البيانات

لإنشاء وإدارة جلسات قاعدة البيانات، ستحتاج إلى اتباع هذه الخطوات:

1. إنشاء جدول في قاعدة البيانات لتخزين بيانات الجلسة (أو التحقق مما إذا كانت مكتبة المصادقة الخاصة بك تتعامل مع هذا).
2. تنفيذ وظائف لإدراج وتحديث وحذف الجلسات
3. تشفير معرّف الجلسة قبل تخزينه في متصفح المستخدم، والتأكد من تزامن قاعدة البيانات وملف تعريف الارتباط (هذا اختياري، ولكنه موصى به للتحقق المتفائل من المصادقة في [الوسيط](#optimistic-checks-with-middleware-optional)).

<AppOnly>

على سبيل المثال:

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. إنشاء جلسة في قاعدة البيانات
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // إرجاع معرّف الجلسة
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. تشفير معرّف الجلسة
  const session = await encrypt({ sessionId, expiresAt })

  // 3. تخزين الجلسة في ملفات تعريف الارتباط للتحقق المتفائل من المصادقة
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. إنشاء جلسة في قاعدة البيانات
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // إرجاع معرّف الجلسة
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. تشفير معرّف الجلسة
  const session = await encrypt({ sessionId, expiresAt })

  // 3. تخزين الجلسة في ملفات تعريف الارتباط للتحقق المتفائل من المصادقة
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **نصائح**:
>
> - للوصول الأسرع، يمكنك التفكير في إضافة تخزين مؤقت على الخادم لمدة الجلسة. يمكنك أيضًا الاحتفاظ ببيانات الجلسة في قاعدة البيانات الرئيسية، وجمع طلبات البيانات لتقليل عدد الاستعلامات.
> - يمكنك اختيار استخدام جلسات قاعدة البيانات لحالات استخدام أكثر تقدمًا، مثل تتبع آخر مرة قام فيها المستخدم بتسجيل الدخول، أو عدد الأجهزة النشطة، أو منح المستخدمين القدرة على تسجيل الخروج من جميع الأجهزة.

بعد تنفيذ إدارة الجلسات، ستحتاج إلى إضافة منطق التفويض للتحكم فيما يمكن للمستخدمين الوصول إليه والقيام به داخل تطبيقك. تابع إلى قسم [التفويض](#authorization) لمعرفة المزيد.

</AppOnly>

<PagesOnly>

**إنشاء جلسة على الخادم**:

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'خطأ في الخادم الداخلي' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'خطأ في الخادم الداخلي' })
  }
}
```

</PagesOnly>

## التفويض

بعد مصادقة المستخدم وإنشاء جلسة، يمكنك تنفيذ التفويض للتحكم فيما يمكن للمستخدم الوصول إليه والقيام به داخل تطبيقك.

هناك نوعان رئيسيان من عمليات التحقق من التفويض:

1. **المتفائل**: يتحقق مما إذا كان المستخدم مخولاً للوصول إلى مسار أو تنفيذ إجراء باستخدام بيانات الجلسة المخزنة في ملف تعريف الارتباط. هذه الفحوصات مفيدة للعمليات السريعة، مثل إظهار/إخفاء عناصر واجهة المستخدم أو إعادة توجيه المستخدمين بناءً على الأذونات أو الأدوار.
2. **الآمن**: يتحقق مما إذا كان المستخدم مخولاً للوصول إلى مسار أو تنفيذ إجراء باستخدام بيانات الجلسة المخزنة في قاعدة البيانات. هذه الفحوصات أكثر أمانًا وتستخدم للعمليات التي تتطلب الوصول إلى بيانات حساسة أو إجراءات.

لكلا الحالتين، نوصي بما يلي:

- إنشاء [طبقة وصول البيانات](#creating-a-data-access-layer-dal) لمركزية منطق التفويض
- استخدام [كائنات نقل البيانات (DTO)](#using-data-transfer-objects-dto) لإرجاع البيانات الضرورية فقط
- استخدام [الوسيط](#optimistic-checks-with-middleware-optional) اختياريًا لإجراء فحوصات متفائلة.

### فحوصات متفائلة باستخدام الوسيط (اختياري)

هناك بعض الحالات التي قد ترغب في استخدام [الوسيط](/docs/app/building-your-application/routing/middleware) وإعادة توجيه المستخدمين بناءً على الأذونات:

- لإجراء فحوصات متفائلة. نظرًا لأن الوسيط يعمل على كل مسار، فهو طريقة جيدة لمركزية منطق إعادة التوجيه وتصفية المستخدمين غير المصرح لهم مسبقًا.
- لحماية المسارات الثابتة التي تشارك البيانات بين المستخدمين (مثل المحتوى خلف جدار الدفع).

ومع ذلك، نظرًا لأن الوسيط يعمل على كل مسار، بما في ذلك المسارات [المحملة مسبقًا](/docs/app/getting-started/linking-and-navigating#prefetching)، فمن المهم قراءة الجلسة فقط من ملف تعريف الارتباط (فحوصات متفائلة)، وتجنب فحوصات قاعدة البيانات لمنع مشكلات الأداء.

على سبيل المثال:

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. تحديد المسارات المحمية والعامة
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. التحقق مما إذا كان المسار الحالي محميًا أو عامًا
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. فك تشفير الجلسة من ملف تعريف الارتباط
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. إعادة التوجيه إلى /login إذا لم يكن المستخدم مصادقًا عليه
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. إعادة التوجيه إلى /dashboard إذا كان المستخدم مصادقًا عليه
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// المسارات التي لا يجب أن يعمل عليها الوسيط
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. تحديد المسارات المحمية والعامة
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. التحقق مما إذا كان المسار الحالي محميًا أو عامًا
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. فك تشفير الجلسة من ملف تعريف الارتباط
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. إعادة التوجيه إلى /login إذا لم يكن المستخدم مصادقًا عليه
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. إعادة التوجيه إلى /dashboard إذا كان المستخدم مصادقًا عليه
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// المسارات التي لا يجب أن يعمل عليها الوسيط
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

بينما يمكن أن يكون الوسيط مفيدًا للفحوصات الأولية، لا يجب أن يكون خط دفاعك الوحيد في حماية بياناتك. يجب إجراء غالبية فحوصات الأمان بالقرب من مصدر البيانات قدر الإمكان، راجع [طبقة وصول البيانات](#creating-a-data-access-layer-dal) لمزيد من المعلومات.

> **نصائح**:
>
> - في الوسيط، يمكنك أيضًا قراءة ملفات تعريف الارتباط باستخدام `req.cookies.get('session').value`.
> - يستخدم الوسيط [وقت تشغيل الحافة](/docs/app/api-reference/edge)، تحقق مما إذا كانت مكتبة المصادقة ومكتبة إدارة الجلسات متوافقة.
> - يمكنك استخدام خاصية `matcher` في الوسيط لتحديد المسارات التي يجب أن يعمل عليها الوسيط. ومع ذلك، للمصادقة، يوصى بأن يعمل الوسيط على جميع المسارات.

<AppOnly>

### إنشاء طبقة وصول البيانات (DAL)

نوصي بإنشاء DAL لمركزية طلبات البيانات ومنطق التفويض.

يجب أن تتضمن DAL دالة تتحقق من جلسة المستخدم أثناء تفاعله مع تطبيقك. على الأقل، يجب أن تتحقق الدالة مما إذا كانت الجلسة صالحة، ثم تقوم بإعادة التوجيه أو إرجاع معلومات المستخدم اللازمة لإجراء طلبات إضافية.

على سبيل المثال، قم بإنشاء ملف منفصل لـ DAL يتضمن دالة `verifySession()`. ثم استخدم واجهة برمجة التطبيقات [cache](https://react.dev/reference/react/cache) من React لحفظ قيمة الإرجاع للدالة أثناء تمرير عرض React:

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

يمكنك بعد ذلك استدعاء دالة `verifySession()` في طلبات البيانات، وإجراءات الخادم، ومعالجات المسار:

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // إرجاع الأعمدة التي تحتاجها صراحة بدلاً من كائن المستخدم بالكامل
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('فشل في جلب المستخدم')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // إرجاع الأعمدة التي تحتاجها صراحة بدلاً من كائن المستخدم بالكامل
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('فشل في جلب المستخدم')
    return null
  }
})
```

> **نصيحة**:
>
> - يمكن استخدام DAL لحماية البيانات التي يتم جلبها في وقت الطلب. ومع ذلك، بالنسبة للمسارات الثابتة التي تشارك البيانات بين المستخدمين، سيتم جلب البيانات في وقت البناء وليس في وقت الطلب. استخدم [الوسيط](#optimistic-checks-with-middleware-optional) لحماية المسارات الثابتة.
> - للفحوصات الآمنة، يمكنك التحقق مما إذا كانت الجلسة صالحة عن طريق مقارنة معرّف الجلسة مع قاعدة البيانات الخاصة بك. استخدم دالة [cache](https://react.dev/reference/react/cache) من React لتجنب الطلبات المكررة غير الضرورية إلى قاعدة البيانات أثناء تمرير العرض.
> - قد ترغب في توحيد طلبات البيانات ذات الصلة في فئة JavaScript تقوم بتشغيل `verifySession()` قبل أي طرق.

### استخدام كائنات نقل البيانات (DTO)

عند استرجاع البيانات، يُنصح بإرجاع البيانات الضرورية فقط التي سيتم استخدامها في تطبيقك، وليس الكائنات الكاملة. على سبيل المثال، إذا كنت تسترجع بيانات المستخدم، فقد ترجع فقط معرف المستخدم واسمه، بدلاً من كائن المستخدم الكامل الذي قد يحتوي على كلمات المرور وأرقام الهواتف، إلخ.

ومع ذلك، إذا لم يكن لديك تحكم في بنية البيانات المُرجعة، أو كنت تعمل ضمن فريق حيث تريد تجنب تمرير كائنات كاملة إلى العميل، يمكنك استخدام استراتيجيات مثل تحديد الحقول الآمنة للعرض على العميل.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Return specific columns here
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Or return only what's specific to the query here
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Return specific columns here
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // Or return only what's specific to the query here
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

من خلال تركيز طلبات البيانات ومنطق التفويض في طبقة الوصول إلى البيانات (DAL) واستخدام كائنات نقل البيانات (DTOs)، يمكنك ضمان أن جميع طلبات البيانات آمنة ومتسقة، مما يسهل الصيانة والتدقيق والتصحيح مع توسع تطبيقك.

> **معلومة مفيدة**:
>
> - هناك عدة طرق مختلفة لتحديد كائن نقل البيانات (DTO)، بدءًا من استخدام `toJSON()`، إلى دوال فردية مثل المثال أعلاه، أو فئات جافاسكريبت. نظرًا لأن هذه أنماط جافاسكريبت وليست ميزة في React أو Next.js، ننصح بإجراء بعض البحث للعثور على النمط الأنسب لتطبيقك.
> - تعلم المزيد عن أفضل ممارسات الأمان في [مقال الأمان في Next.js](/blog/security-nextjs-server-components-actions).

### مكونات الخادم (Server Components)

فحص التفويض في [مكونات الخادم](/docs/app/getting-started/server-and-client-components) مفيد للوصول القائم على الأدوار. على سبيل المثال، لعرض المكونات بشكل مشروط بناءً على دور المستخدم:

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // Assuming 'role' is part of the session object

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

في المثال، نستخدم الدالة `verifySession()` من طبقة الوصول إلى البيانات (DAL) للتحقق من أدوار 'admin' و'user' والأدوار غير المصرح بها. يضمن هذا النمط تفاعل كل مستخدم فقط مع المكونات المناسبة لدوره.

### التخطيطات وفحوصات التفويض

بسبب [التصيير الجزئي (Partial Rendering)](/docs/app/getting-started/linking-and-navigating#client-side-transitions)، كن حذرًا عند إجراء الفحوصات في [التخطيطات (Layouts)](/docs/app/api-reference/file-conventions/layout) لأنها لا تُعيد التصيير أثناء التنقل، مما يعني أن جلسة المستخدم لن يتم التحقق منها في كل تغيير للمسار.

بدلاً من ذلك، يجب إجراء الفحوصات بالقرب من مصدر البيانات أو المكون الذي سيتم عرضه بشكل مشروط.

على سبيل المثال، ضع في الاعتبار تخطيطًا مشتركًا يسترجع بيانات المستخدم ويعرض صورة المستخدم في شريط التنقل. بدلاً من إجراء فحص التفويض في التخطيط، يجب استرجاع بيانات المستخدم (`getUser()`) في التخطيط وإجراء فحص التفويض في طبقة الوصول إلى البيانات (DAL).

هذا يضمن أنه في أي مكان يتم فيه استدعاء `getUser()` داخل تطبيقك، يتم إجراء فحص التفويض، ويمنع المطورين من نسيان التحقق من أن المستخدم مصرح له بالوصول إلى البيانات.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Get user ID from session and fetch data
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Get user ID from session and fetch data
})
```

> **معلومة مفيدة:**
>
> - النمط الشائع في التطبيقات ذات الصفحة الواحدة (SPAs) هو إرجاع `null` في تخطيط أو مكون رئيسي إذا لم يكن المستخدم مصرحًا له. **لا يُنصح بهذا النمط** لأن تطبيقات Next.js لديها نقاط دخول متعددة، مما لن يمنع أجزاء المسار المتداخلة وإجراءات الخادم (Server Actions) من الوصول.

### إجراءات الخادم (Server Actions)

عامل [إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) بنفس اعتبارات الأمان مثل نقاط نهاية واجهة برمجة التطبيقات (API) الموجهة للجمهور، وتحقق مما إذا كان المستخدم مسموحًا له بتنفيذ التغيير.

في المثال أدناه، نتحقق من دور المستخدم قبل السماح بتنفيذ الإجراء:

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Return early if user is not authorized to perform the action
  if (userRole !== 'admin') {
    return null
  }

  // Proceed with the action for authorized users
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Return early if user is not authorized to perform the action
  if (userRole !== 'admin') {
    return null
  }

  // Proceed with the action for authorized users
}
```

### معالجات المسار (Route Handlers)

عامل [معالجات المسار](/docs/app/building-your-application/routing/route-handlers) بنفس اعتبارات الأمان مثل نقاط نهاية واجهة برمجة التطبيقات (API) الموجهة للجمهور، وتحقق مما إذا كان المستخدم مسموحًا له بالوصول إلى معالج المسار.

على سبيل المثال:

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // User authentication and role verification
  const session = await verifySession()

  // Check if the user is authenticated
  if (!session) {
    // User is not authenticated
    return new Response(null, { status: 401 })
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    // User is authenticated but does not have the right permissions
    return new Response(null, { status: 403 })
  }

  // Continue for authorized users
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // User authentication and role verification
  const session = await verifySession()

  // Check if the user is authenticated
  if (!session) {
    // User is not authenticated
    return new Response(null, { status: 401 })
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    // User is authenticated but does not have the right permissions
    return new Response(null, { status: 403 })
  }

  // Continue for authorized users
}
```

يوضح المثال أعلاه معالج مسار بفحص أمان من مستويين. أولاً يتحقق من وجود جلسة نشطة، ثم يتحقق مما إذا كان المستخدم المسجل دخوله هو 'admin'.

## موفرو السياق (Context Providers)

استخدام موفري السياق للتفويض يعمل بسبب [التداخل (interleaving)](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). ومع ذلك، فإن `context` في React غير مدعوم في مكونات الخادم، مما يجعلها قابلة للتطبيق فقط على مكونات العميل.

هذا يعمل، ولكن أي مكونات خادم فرعية سيتم تصييرها على الخادم أولاً، ولن يكون لديها وصول إلى بيانات الجلسة من موفر السياق:

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

إذا كانت بيانات الجلسة مطلوبة في مكونات العميل (مثل جلب البيانات من جانب العميل)، استخدم واجهة برمجة التطبيقات [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) في React لمنع بيانات الجلسة الحساسة من التعرض للعميل.

</AppOnly>

<PagesOnly>

### إنشاء طبقة الوصول إلى البيانات (DAL)

#### حماية مسارات واجهة برمجة التطبيقات (API Routes)

مسارات واجهة برمجة التطبيقات في Next.js ضرورية للتعامل مع منطق الخادم وإدارة البيانات. من الضروري تأمين هذه المسارات لضمان أن المستخدمين المصرح لهم فقط يمكنهم الوصول إلى وظائف محددة. يتضمن هذا عادةً التحقق من حالة مصادقة المستخدم وأذوناته القائمة على الأدوار.

إليك مثالًا لتأمين مسار واجهة برمجة التطبيقات:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Check if the user is authenticated
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Proceed with the route for authorized users
  // ... implementation of the API Route
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Check if the user is authenticated
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // Check if the user has the 'admin' role
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Proceed with the route for authorized users
  // ... implementation of the API Route
}
```

يوضح هذا المثال مسار واجهة برمجة التطبيقات بفحص أمان من مستويين للمصادقة والتفويض. أولاً يتحقق من وجود جلسة نشطة، ثم يتحقق مما إذا كان المستخدم المسجل دخوله هو 'admin'. يضمن هذا النهج وصولاً آمنًا، مقصورًا على المستخدمين المصادق عليهم والمصرح لهم، مع الحفاظ على أمان قوي لمعالجة الطلبات.

</PagesOnly>

## موارد

الآن بعد أن تعلمت عن المصادقة في Next.js، إليك مكتبات وموارد متوافقة مع Next.js لمساعدتك في تنفيذ المصادقة الآمنة وإدارة الجلسات:

### مكتبات المصادقة

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### مكتبات إدارة الجلسات

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## قراءة إضافية

لمواصلة التعلم عن المصادقة والأمان، تحقق من الموارد التالية:

- [كيف تفكر في الأمان في Next.js](/blog/security-nextjs-server-components-actions)
- [فهم هجمات XSS](https://vercel.com/guides/understanding-xss-attacks)
- [فهم هجمات CSRF](https://vercel.com/guides/understanding-csrf-attacks)
- [كتاب كوبنهاجن](https://thecopenhagenbook.com/)
