---
source-updated-at: 2025-05-19T22:31:51.000Z
translation-updated-at: 2025-06-02T19:59:51.126Z
title: كيفية بناء تطبيقات الصفحة الواحدة باستخدام Next.js
nav_title: تطبيقات الصفحة الواحدة (SPAs)
description: يدعم Next.js بشكل كامل بناء تطبيقات الصفحة الواحدة (SPAs).
---

يدعم Next.js بشكل كامل بناء تطبيقات الصفحة الواحدة (SPAs).

يشمل ذلك انتقالات سريعة بين المسارات مع الجلب المسبق (prefetching)، جلب البيانات من جانب العميل، استخدام واجهات برمجة المتصفح، التكامل مع مكتبات الجهات الخارجية للعميل، إنشاء مسارات ثابتة، والمزيد.

إذا كان لديك تطبيق SPA موجود، يمكنك الانتقال إلى Next.js دون إجراء تغييرات كبيرة على الكود الخاص بك. ثم يسمح لك Next.js بإضافة ميزات الخادم تدريجياً حسب الحاجة.

## ما هو تطبيق الصفحة الواحدة (SPA)؟

تعريف SPA يختلف. سنعرِّف "SPA الصارم" على النحو التالي:

- **التصيير من جانب العميل (CSR)**: يتم تقديم التطبيق بواسطة ملف HTML واحد (مثل `index.html`). يتم التعامل مع كل مسار، انتقال بين الصفحات، وجلب للبيانات بواسطة JavaScript في المتصفح.
- **لا يوجد إعادة تحميل كاملة للصفحة**: بدلاً من طلب مستند جديد لكل مسار، يتلاعب JavaScript من جانب العميل بـ DOM الصفحة الحالية ويجلب البيانات حسب الحاجة.

غالباً ما تتطلب تطبيقات SPA الصارمة كميات كبيرة من JavaScript لتحميلها قبل أن تصبح الصفحة قابلة للتفاعل. علاوة على ذلك، يمكن أن يكون تدفق البيانات من العميل صعباً في الإدارة. بناء تطبيقات SPA باستخدام Next.js يمكن أن يعالج هذه المشكلات.

## لماذا تستخدم Next.js لتطبيقات SPA؟

يمكن لـ Next.js تقسيم حزم JavaScript تلقائياً، وإنشاء نقاط دخول HTML متعددة لمسارات مختلفة. هذا يتجنب تحميل أكواد JavaScript غير الضرورية من جانب العميل، مما يقلل حجم الحزمة ويسمح بتحميل أسرع للصفحات.

مكون [`next/link`](/docs/app/api-reference/components/link) يقوم تلقائياً [بجلب المسارات مسبقاً](/docs/app/api-reference/components/link#prefetch)، مما يمنحك انتقالات سريعة بين الصفحات مثل تطبيق SPA الصارم، ولكن مع ميزة الحفاظ على حالة توجيه التطبيق في عنوان URL للمشاركة والربط.

يمكن أن يبدأ Next.js كموقع ثابت أو حتى كتطبيق SPA صارم حيث يتم تصيير كل شيء من جانب العميل. إذا نما مشروعك، يسمح لك Next.js بإضافة ميزات الخادم تدريجياً (مثل [مكونات خادم React](/docs/app/getting-started/server-and-client-components)، [إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)، والمزيد) حسب الحاجة.

## أمثلة

لنستكشف الأنماط الشائعة المستخدمة في بناء تطبيقات SPA وكيف يحلها Next.js.

### استخدام `use` من React داخل موفر السياق (Context Provider)

نوصي بجلب البيانات في مكون رئيسي (أو تخطيط)، وإرجاع الـ Promise، ثم فك القيمة في مكون العميل باستخدام [خطاف `use` من React](https://react.dev/reference/react/use).

يمكن لـ Next.js بدء جلب البيانات مبكراً على الخادم. في هذا المثال، هذا هو التخطيط الجذري - نقطة الدخول إلى تطبيقك. يمكن للخادم البدء فوراً في بث استجابة إلى العميل.

عن طريق "رفع" جلب البيانات إلى التخطيط الجذري، يبدأ Next.js الطلبات المحددة على الخادم مبكراً قبل أي مكونات أخرى في تطبيقك. هذا يلغي تدفقات البيانات من العميل ويمنع حدوث جولات متعددة بين العميل والخادم. يمكن أن يحسن الأداء بشكل كبير، حيث يكون خادمك أقرب (ويفضل أن يكون في نفس الموقع) إلى قاعدة البيانات الخاصة بك.

على سبيل المثال، قم بتحديث التخطيط الجذري الخاص بك لاستدعاء الـ Promise، ولكن لا تنتظره.

```tsx filename="app/layout.tsx" switcher
import { UserProvider } from './user-provider'
import { getUser } from './user' // دالة من جانب الخادم

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  let userPromise = getUser() // لا تنتظر هنا

  return (
    <html lang="en">
      <body>
        <UserProvider userPromise={userPromise}>{children}</UserProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { UserProvider } from './user-provider'
import { getUser } from './user' // دالة من جانب الخادم

export default function RootLayout({ children }) {
  let userPromise = getUser() // لا تنتظر هنا

  return (
    <html lang="en">
      <body>
        <UserProvider userPromise={userPromise}>{children}</UserProvider>
      </body>
    </html>
  )
}
```

بينما يمكنك [تأجيل وإرسال Promise واحد](/docs/app/getting-started/fetching-data#streaming-data-with-the-use-hook) كخاصية إلى مكون العميل، نرى عادةً هذا النمط مقترناً بموفر سياق React. هذا يمكّن الوصول الأسهل من مكونات العميل باستخدام خطاف React مخصص.

يمكنك إعادة توجيه Promise إلى موفر سياق React:

```ts filename="app/user-provider.ts" switcher
'use client';

import { createContext, useContext, ReactNode } from 'react';

type User = any;
type UserContextType = {
  userPromise: Promise<User | null>;
};

const UserContext = createContext<UserContextType | null>(null);

export function useUser(): UserContextType {
  let context = useContext(UserContext);
  if (context === null) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}

export function UserProvider({
  children,
  userPromise
}: {
  children: ReactNode;
  userPromise: Promise<User | null>;
}) {
  return (
    <UserContext.Provider value={{ userPromise }}>
      {children}
    </UserContext.Provider>
  );
}
```

```js filename="app/user-provider.js" switcher
'use client'

import { createContext, useContext, ReactNode } from 'react'

const UserContext = createContext(null)

export function useUser() {
  let context = useContext(UserContext)
  if (context === null) {
    throw new Error('useUser must be used within a UserProvider')
  }
  return context
}

export function UserProvider({ children, userPromise }) {
  return (
    <UserContext.Provider value={{ userPromise }}>
      {children}
    </UserContext.Provider>
  )
}
```

أخيراً، يمكنك استدعاء الخطاف المخصص `useUser()` في أي مكون عميل وفك Promise:

```tsx filename="app/profile.tsx" switcher
'use client'

import { use } from 'react'
import { useUser } from './user-provider'

export function Profile() {
  const { userPromise } = useUser()
  const user = use(userPromise)

  return '...'
}
```

```jsx filename="app/profile.js" switcher
'use client'

import { use } from 'react'
import { useUser } from './user-provider'

export function Profile() {
  const { userPromise } = useUser()
  const user = use(userPromise)

  return '...'
}
```

سيتم تعليق المكون الذي يستهلك الـ Promise (مثل `Profile` أعلاه). هذا يمكّن الترطيب الجزئي. يمكنك رؤية HTML المدفوع والمصمم مسبقاً قبل انتهاء تحميل JavaScript.

### تطبيقات SPA مع SWR

[SWR](https://swr.vercel.app) هي مكتبة React شائعة لجلب البيانات.

مع SWR 2.3.0 (و React 19+)، يمكنك تبني ميزات الخادم تدريجياً إلى جانب كود جلب البيانات الحالي المعتمد على SWR من جانب العميل. هذا تجريد لنمط `use()` أعلاه. هذا يعني أنه يمكنك نقل جلب البيانات بين العميل والخادم، أو استخدام كليهما:

- **العميل فقط:** `useSWR(key, fetcher)`
- **الخادم فقط:** `useSWR(key)` + بيانات مقدمة من RSC
- **مختلط:** `useSWR(key, fetcher)` + بيانات مقدمة من RSC

على سبيل المثال، قم بلف تطبيقك بـ `<SWRConfig>` و `fallback`:

```tsx filename="app/layout.tsx" switcher
import { SWRConfig } from 'swr'
import { getUser } from './user' // دالة من جانب الخادم

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <SWRConfig
      value={{
        fallback: {
          // لا ننتظر getUser() هنا
          // فقط المكونات التي تقرأ هذه البيانات سيتم تعليقها
          '/api/user': getUser(),
        },
      }}
    >
      {children}
    </SWRConfig>
  )
}
```

```js filename="app/layout.js" switcher
import { SWRConfig } from 'swr'
import { getUser } from './user' // دالة من جانب الخادم

export default function RootLayout({ children }) {
  return (
    <SWRConfig
      value={{
        fallback: {
          // لا ننتظر getUser() هنا
          // فقط المكونات التي تقرأ هذه البيانات سيتم تعليقها
          '/api/user': getUser(),
        },
      }}
    >
      {children}
    </SWRConfig>
  )
}
```

نظراً لأن هذا مكون خادم، يمكن لـ `getUser()` قراءة ملفات تعريف الارتباط (cookies) أو الرؤوس (headers) أو التحدث إلى قاعدة البيانات الخاصة بك بأمان. لا حاجة إلى نقطة نهاية API منفصلة. يمكن لمكونات العميل أسفل `<SWRConfig>` استدعاء `useSWR()` بنفس المفتاح لاسترداد بيانات المستخدم. لا يتطلب كود المكون مع `useSWR` **أي تغييرات** من حل جلب البيانات الحالي من جانب العميل.

```tsx filename="app/profile.tsx" switcher
'use client'

import useSWR from 'swr'

export function Profile() {
  const fetcher = (url) => fetch(url).then((res) => res.json())
  // نفس نمط SWR الذي تعرفه بالفعل
  const { data, error } = useSWR('/api/user', fetcher)

  return '...'
}
```

```jsx filename="app/profile.js" switcher
'use client'

import useSWR from 'swr'

export function Profile() {
  const fetcher = (url) => fetch(url).then((res) => res.json())
  // نفس نمط SWR الذي تعرفه بالفعل
  const { data, error } = useSWR('/api/user', fetcher)

  return '...'
}
```

يمكن تصيير بيانات `fallback` مسبقاً وتضمينها في استجابة HTML الأولية، ثم قراءتها فوراً في المكونات الفرعية باستخدام `useSWR`. لا تزال عمليات الاستطلاع، إعادة التحقق، والتخزين المؤقت لـ SWR تعمل **من جانب العميل فقط**، لذا فهي تحافظ على كل التفاعلية التي تعتمد عليها في تطبيق SPA.

نظراً لأن بيانات `fallback` الأولية يتم التعامل معها تلقائياً بواسطة Next.js، يمكنك الآن حذف أي منطق شرطي كان مطلوباً سابقاً للتحقق مما إذا كانت `data` `undefined`. عند تحميل البيانات، سيتم تعليق أقرب حدود `<Suspense>`.

|                      | SWR                 | RSC                 | RSC + SWR           |
| -------------------- | ------------------- | ------------------- | ------------------- |
| بيانات SSR           | <Cross size={18} /> | <Check size={18} /> | <Check size={18} /> |
| البث أثناء SSR       | <Cross size={18} /> | <Check size={18} /> | <Check size={18} /> |
| إزالة تكرار الطلبات  | <Check size={18} /> | <Check size={18} /> | <Check size={18} /> |
| ميزات جانب العميل    | <Check size={18} /> | <Cross size={18} /> | <Check size={18} /> |

### تطبيقات SPA مع React Query

يمكنك استخدام React Query مع Next.js على كل من العميل والخادم. هذا يمكّنك من بناء تطبيقات SPA صارمة، وكذلك الاستفادة من ميزات الخادم في Next.js مع React Query.

تعلم المزيد في [توثيق React Query](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr).

### تصيير المكونات فقط في المتصفح

يتم [تصيير مكونات العميل مسبقاً](https://github.com/reactwg/server-components/discussions/4) أثناء `next build`. إذا كنت تريد تعطيل التصيير المسبق لمكون العميل وتحميله فقط في بيئة المتصفح، يمكنك استخدام [`next/dynamic`](/docs/app/guides/lazy-loading#nextdynamic):

```jsx
import dynamic from 'next/dynamic'

const ClientOnlyComponent = dynamic(() => import('./component'), {
  ssr: false,
})
```

يمكن أن يكون هذا مفيداً لمكتبات الجهات الخارجية التي تعتمد على واجهات برمجة المتصفح مثل `window` أو `document`. يمكنك أيضاً إضافة `useEffect` يتحقق من وجود هذه الواجهات، وإذا لم تكن موجودة، إرجاع `null` أو حالة تحميل سيتم تصييرها مسبقاً.

### التوجيه السطحي (Shallow Routing) من جانب العميل

إذا كنت تنتقل من تطبيق SPA صارم مثل [Create React App](/docs/app/guides/migrating/from-create-react-app) أو [Vite](/docs/app/guides/migrating/from-vite)، قد يكون لديك كود موجود يقوم بالتوجيه السطحي لتحديث حالة عنوان URL. يمكن أن يكون هذا مفيداً للانتقالات اليدوية بين المشاهدات في تطبيقك _بدون_ استخدام توجيه نظام الملفات الافتراضي لـ Next.js.

يسمح لك Next.js باستخدام الطرق الأصلية [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) و [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) لتحديث سجل المتصفح دون إعادة تحميل الصفحة.

تكامل استدعاءات `pushState` و `replaceState` مع موجه Next.js، مما يسمح لك بالمزامنة مع [`usePathname`](/docs/app/api-reference/functions/use-pathname) و [`useSearchParams`](/docs/app/api-reference/functions/use-search-params).

```tsx fileName="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const urlSearchParams = new URLSearchParams(searchParams.toString())
    urlSearchParams.set('sort', sortOrder)
    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>ترتيب تصاعدي</button>
      <button onClick={() => updateSorting('desc')}>ترتيب تنازلي</button>
    </>
  )
}
```

```jsx fileName="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const urlSearchParams = new URLSearchParams(searchParams.toString())
    urlSearchParams.set('sort', sortOrder)
    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>ترتيب تصاعدي</button>
      <button onClick={() => updateSorting('desc')}>ترتيب تنازلي</button>
    </>
  )
}
```

تعلم المزيد حول كيفية عمل [التوجيه والتنقل](/docs/app/building-your-application/routing/linking-and-navigating#how-routing-and-navigation-works) في Next.js.

### استخدام إجراءات الخادم في مكونات العميل

يمكنك تبني إجراءات الخادم تدريجياً مع الاستمرار في استخدام مكونات العميل. هذا يسمح لك بإزالة الكود المتكرر لاستدعاء نقطة نهاية API، واستخدام ميزات React مثل `useActionState` للتعامل مع حالات التحميل والأخطاء.

على سبيل المثال، قم بإنشاء أول إجراء خادم:

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {}
```

يمكنك استيراد واستخدام إجراء خادم من العميل، مشابهًا لاستدعاء دالة JavaScript. لا تحتاج إلى إنشاء نقطة نهاية API يدوياً:

```tsx filename="app/button.tsx" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>إنشاء</button>
}
```

```jsx filename="app/button.js" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>إنشاء</button>
}
```

تعلم المزيد حول [تعديل البيانات باستخدام إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations).

## التصدير الثابت (اختياري)

يدعم Next.js أيضاً إنشاء [موقع ثابت](/docs/app/guides/static-exports) بالكامل. هذا له بعض المزايا مقارنة بتطبيقات SPA الصارمة:

- **تقسيم الكود تلقائياً**: بدلاً من إرسال ملف `index.html` واحد، سينشئ Next.js ملف HTML لكل مسار، بحيث يحصل زوارك على المحتوى بشكل أسرع دون انتظار حزمة JavaScript من جانب العميل.
- **تحسين تجربة المستخدم**: بدلاً من هيكل بسيط لجميع المسارات، تحصل على صفحات مكتملة التصيير لكل مسار. عندما ينتقل المستخدمون من جانب العميل، تظل الانتقالات فورية تشبه تطبيق SPA.

لتمكين التصدير الثابت، قم بتحديث التكوين الخاص بك:

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  output: 'export',
}

export default nextConfig
```

بعد تشغيل `next build`، سينشئ Next.js مجلد `out` مع أصول HTML/CSS/JS لتطبيقك.

> **ملاحظة:** لا يتم دعم ميزات خادم Next.js مع التصدير الثابت. [تعلم المزيد](/docs/app/guides/static-exports#unsupported-features).

## نقل المشاريع الحالية إلى Next.js

يمكنك الانتقال تدريجياً إلى Next.js باتباع أدلتنا:

- [الانتقال من Create React App](/docs/app/guides/migrating/from-create-react-app)
- [الانتقال من Vite](/docs/app/guides/migrating/from-vite)

إذا كنت تستخدم بالفعل تطبيق SPA مع موجه الصفحات، يمكنك تعلم كيفية [تبني موجه التطبيق تدريجياً](/docs/app/guides/migrating/app-router-migration).