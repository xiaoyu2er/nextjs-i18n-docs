---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:16:06.717Z
title: Link
description: تمكين التنقل السريع من جانب العميل باستخدام مكون `next/link` المدمج.
---

{/* يتم مشاركة محتوى هذا المستند بين موجه التطبيق وموجه الصفحات. يمكنك استخدام مكون `<PagesOnly>المحتوى</PagesOnly>` لإضافة محتوى خاص بموجه الصفحات. أي محتوى مشترك لا يجب أن يكون مغلفًا بمكون. */}

`<Link>` هو مكون React يمتد عنصر HTML `<a>` لتوفير [الجلب المسبق](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) والتنقل من جانب العميل بين المسارات. إنها الطريقة الأساسية للتنقل بين المسارات في Next.js.

الاستخدام الأساسي:

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</PagesOnly>

## المرجع

يمكن تمرير الخصائص التالية إلى مكون `<Link>`:

<PagesOnly>

| الخاصية                          | مثال                     | النوع              | مطلوب |
| ------------------------------- | ------------------------ | ------------------ | ----- |
| [`href`](#href-required)        | `href="/dashboard"`      | String أو Object   | نعم   |
| [`replace`](#replace)           | `replace={false}`        | Boolean            | -     |
| [`scroll`](#scroll)             | `scroll={false}`         | Boolean            | -     |
| [`prefetch`](#prefetch)         | `prefetch={false}`       | Boolean            | -     |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}`  | Boolean            | -     |
| [`passHref`](#passhref)         | `passHref={true}`        | Boolean            | -     |
| [`shallow`](#shallow)           | `shallow={false}`        | Boolean            | -     |
| [`locale`](#locale)             | `locale="fr"`            | String أو Boolean  | -     |
| [`onNavigate`](#onnavigate)     | `onNavigate={(e) => {}}` | Function           | -     |

</PagesOnly>

<AppOnly>

| الخاصية                      | مثال                     | النوع             | مطلوب |
| --------------------------- | ------------------------ | ----------------- | ----- |
| [`href`](#href-required)    | `href="/dashboard"`      | String أو Object  | نعم   |
| [`replace`](#replace)       | `replace={false}`        | Boolean           | -     |
| [`scroll`](#scroll)         | `scroll={false}`         | Boolean           | -     |
| [`prefetch`](#prefetch)     | `prefetch={false}`       | Boolean أو null   | -     |
| [`onNavigate`](#onnavigate) | `onNavigate={(e) => {}}` | Function          | -     |

</AppOnly>

> **معلومة جيدة**: يمكن إضافة سمات وسم `<a>` مثل `className` أو `target="_blank"` إلى `<Link>` كخصائص وسيتم تمريرها إلى عنصر `<a>` الأساسي.

### `href` (مطلوب)

المسار أو URL للانتقال إليه.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

// الانتقال إلى /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

// الانتقال إلى /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

// الانتقال إلى /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

// الانتقال إلى /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</PagesOnly>

### `replace`

**القيمة الافتراضية `false`.** عندما تكون `true`، سيستبدل `next/link` حالة التاريخ الحالية بدلاً من إضافة URL جديد إلى [مكدس تاريخ المتصفح](https://developer.mozilla.org/docs/Web/API/History_API).

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `scroll`

**القيمة الافتراضية `true`.** سلوك التمرير الافتراضي لـ `<Link>` في Next.js **هو الحفاظ على موضع التمرير**، مشابه لكيفية تعامل المتصفحات مع التنقل للخلف وللأمام. عند الانتقال إلى [صفحة](/docs/app/api-reference/file-conventions/page) جديدة، سيظل موضع التمرير كما هو طالما أن الصفحة مرئية في نافذة العرض. ومع ذلك، إذا لم تكن الصفحة مرئية في نافذة العرض، فسوف يقوم Next.js بالتمرير إلى أعلى أول عنصر صفحة.

عندما تكون `scroll = {false}`، لن يحاول Next.js التمرير إلى أول عنصر صفحة.

> **معلومة جيدة**: يتحقق Next.js من `scroll: false` قبل إدارة سلوك التمرير. إذا كان التمرير ممكّنًا، فإنه يحدد عقدة DOM ذات الصلة بالتنقل ويتفحص كل عنصر من المستوى الأعلى. يتم تخطي جميع العناصر غير القابلة للتمرير وتلك التي لا تحتوي على HTML مقدم، وهذا يشمل العناصر ذات الموضع الثابت أو المثبت، والعناصر غير المرئية مثل تلك المحسوبة باستخدام `getBoundingClientRect`. ثم يستمر Next.js عبر العناصر الشقيقة حتى يحدد عنصرًا قابلًا للتمرير مرئيًا في نافذة العرض.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `prefetch`

<AppOnly>

يحدث الجلب المسبق عندما يدخل مكون `<Link />` نافذة عرض المستخدم (في البداية أو عبر التمرير). يقوم Next.js بجلب وتحميل المسار المرتبط (المشار إليه بواسطة `href`) وبياناته في الخلفية لتحسين أداء التنقل من جانب العميل. إذا انتهت صلاحية البيانات التي تم جلبها مسبقًا بحلول الوقت الذي يحوم فيه المستخدم فوق `<Link />`، فسيحاول Next.js جلبها مرة أخرى. **الجلب المسبق ممكّن فقط في بيئة الإنتاج**.

يمكن تمرير القيم التالية إلى خاصية `prefetch`:

- **`null` (افتراضي)**: يعتمد سلوك الجلب المسبق على ما إذا كان المسار ثابتًا أو ديناميكيًا. بالنسبة للمسارات الثابتة، سيتم جلب المسار بالكامل مسبقًا (بما في ذلك جميع بياناته). بالنسبة للمسارات الديناميكية، سيتم جلب الجزء من المسار حتى أقرب مقطع به حد [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- `true`: سيتم جلب المسار بالكامل مسبقًا لكل من المسارات الثابتة والديناميكية.
- `false`: لن يحدث الجلب المسبق أبدًا سواء عند الدخول إلى نافذة العرض أو عند التحويم.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

يحدث الجلب المسبق عندما يدخل مكون `<Link />` نافذة عرض المستخدم (في البداية أو عبر التمرير). يقوم Next.js بجلب وتحميل المسار المرتبط (المشار إليه بواسطة `href`) والبيانات في الخلفية لتحسين أداء التنقل من جانب العميل. **الجلب المسبق ممكّن فقط في بيئة الإنتاج**.

يمكن تمرير القيم التالية إلى خاصية `prefetch`:

- **`true` (افتراضي)**: سيتم جلب المسار بالكامل وبياناته مسبقًا.
- `false`: لن يحدث الجلب المسبق عند الدخول إلى نافذة العرض، ولكن سيحدث عند التحويم. إذا كنت تريد إزالة الجلب تمامًا عند التحويم أيضًا، ففكر في استخدام وسم `<a>` أو [التبني التدريجي](/docs/app/guides/migrating/app-router-migration) لموجه التطبيق، الذي يمكّن تعطيل الجلب المسبق عند التحويم أيضًا.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

### `legacyBehavior`

> **تحذير**: سيتم إزالة خاصية `legacyBehavior` في Next.js v16. لتبني سلوك `<Link>` الجديد، قم بإزالة أي وسوم `<a>` تستخدم كأطفال لـ `<Link>`. يتوفر [أداة تعديل الشفرة](/docs/app/guides/upgrading/codemods#new-link) لمساعدتك في ترقية قاعدة الكود الخاصة بك تلقائيًا.

منذ الإصدار 13، لم يعد عنصر `<a>` مطلوبًا كطفل لمكون `<Link>`. إذا كنت لا تزال بحاجة إلى السلوك القديم لأسباب التوافق، يمكنك إضافة خاصية `legacyBehavior`.

> **معلومة جيدة**: عندما لا يتم تعيين `legacyBehavior` إلى `true`، يمكن تمرير جميع خصائص [وسم الربط](https://developer.mozilla.org/docs/Web/HTML/Element/a) إلى `next/link` أيضًا مثل `className`، `onClick`، إلخ.

### `passHref`

يجبر `Link` على إرسال خاصية `href` إلى طفله. القيمة الافتراضية هي `false`. راجع مثال [تمرير مكون وظيفي](#nesting-a-functional-component) لمزيد من المعلومات.

### `shallow`

تحديث مسار الصفحة الحالية دون إعادة تشغيل [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) أو [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props) أو [`getInitialProps`](/docs/pages/api-reference/functions/get-initial-props). القيمة الافتراضية هي `false`.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

### `locale`

يتم إضافة اللغة النشطة تلقائيًا. تسمح `locale` بتوفير لغة مختلفة. عندما تكون `false`، يجب أن يتضمن `href` اللغة حيث يتم تعطيل السلوك الافتراضي.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* السلوك الافتراضي: يتم إضافة اللغة */}
      <Link href="/dashboard">Dashboard (مع اللغة)</Link>

      {/* تعطيل إضافة اللغة */}
      <Link href="/dashboard" locale={false}>
        Dashboard (بدون اللغة)
      </Link>

      {/* تحديد لغة مختلفة */}
      <Link href="/dashboard" locale="fr">
        Dashboard (بالفرنسية)
      </Link>
    </>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* السلوك الافتراضي: يتم إضافة اللغة */}
      <Link href="/dashboard">Dashboard (مع اللغة)</Link>

      {/* تعطيل إضافة اللغة */}
      <Link href="/dashboard" locale={false}>
        Dashboard (بدون اللغة)
      </Link>

      {/* تحديد لغة مختلفة */}
      <Link href="/dashboard" locale="fr">
        Dashboard (بالفرنسية)
      </Link>
    </>
  )
}
```

</PagesOnly>

### `onNavigate`

معالج حدث يتم استدعاؤه أثناء التنقل من جانب العميل. يتلقى المعالج كائن حدث يتضمن طريقة `preventDefault()`، مما يسمح لك بإلغاء التنقل إذا لزم الأمر.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // يتم التنفيذ فقط أثناء التنقل SPA
        console.log('جارٍ التنقل...')

        // إلغاء التنقل اختياريًا
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // يتم التنفيذ فقط أثناء التنقل SPA
        console.log('جارٍ التنقل...')

        // إلغاء التنقل اختياريًا
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

> **معلومة جيدة**: بينما قد يبدو `onClick` و `onNavigate` متشابهين، فإنهما يخدمان أغراضًا مختلفة. يتم تنفيذ `onClick` لجميع أحداث النقر، بينما يعمل `onNavigate` فقط أثناء التنقل من جانب العميل. بعض الاختلافات الرئيسية:
>
> - عند استخدام مفاتيح التعديل (`Ctrl`/`Cmd` + النقر)، يتم تنفيذ `onClick` ولكن لا يتم تنفيذ `onNavigate` حيث يمنع Next.js التنقل الافتراضي للألسنة الجديدة.
> - لن تؤدي عناوين URL الخارجية إلى تشغيل `onNavigate` لأنها مخصصة فقط للتنقل من جانب العميل والتنقل من نفس المصدر.
> - ستكون الروابط ذات السمة `download` متوافقة مع `onClick` ولكن ليس مع `onNavigate` لأن المتصفح سيعامل عنوان URL المرتبط كتنزيل.

## أمثلة

توضح الأمثلة التالية كيفية استخدام مكون `<Link>` في سيناريوهات مختلفة.

<AppOnly>

### الربط مع المقاطع الديناميكية

عند الربط مع [مقاطع ديناميكية](/docs/app/api-reference/file-conventions/dynamic-routes)، يمكنك استخدام [القوالب الحرفية والاستيفاء](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals) لإنشاء قائمة من الروابط. على سبيل المثال، لإنشاء قائمة من منشورات المدونة:

```tsx filename="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

### التحقق من الروابط النشطة

يمكنك استخدام [`usePathname()`](/docs/app/api-reference/functions/use-pathname) لتحديد ما إذا كان الرابط نشطًا. على سبيل المثال، لإضافة فئة إلى الرابط النشط، يمكنك التحقق مما إذا كان `pathname` الحالي يتطابق مع `href` الخاص بالرابط:

```tsx filename="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

```jsx filename="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

### التمرير إلى `id`

إذا كنت ترغب في التمرير إلى `id` معين عند التنقل، يمكنك إضافة رابط `#` إلى عنوان URL الخاص بك أو تمرير رابط الهاش إلى خاصية `href`. هذا ممكن لأن `<Link>` يتم عرضه كعنصر `<a>`.

```jsx
<Link href="/dashboard#settings">Settings</Link>

// Output
<a href="/dashboard#settings">Settings</a>
```

> **معلومة مفيدة**:
>
> - سيقوم Next.js بالتمرير إلى [الصفحة](/docs/app/api-reference/file-conventions/page) إذا لم تكن مرئية في نافذة العرض عند التنقل.

</AppOnly>

### الربط إلى أجزاء المسار الديناميكية

بالنسبة [لأجزاء المسار الديناميكية](/docs/app/api-reference/file-conventions/dynamic-routes)، يمكن أن يكون استخدام القوالب الحرفية مفيدًا لإنشاء مسار الرابط.

<PagesOnly>

على سبيل المثال، يمكنك إنشاء قائمة من الروابط إلى المسار الديناميكي `pages/blog/[slug].js`

```tsx filename="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</PagesOnly>

<AppOnly>

على سبيل المثال، يمكنك إنشاء قائمة من الروابط إلى المسار الديناميكي `app/blog/[slug]/page.js`:

```tsx filename="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</AppOnly>

### إذا كان العنصر الفرعي مكونًا مخصصًا يغلف علامة `<a>`

<AppOnly>

إذا كان العنصر الفرعي لـ `Link` هو مكون مخصص يغلف علامة `<a>`، فيجب عليك إضافة `passHref` إلى `Link`. هذا ضروري إذا كنت تستخدم مكتبات مثل [styled-components](https://styled-components.com/). بدون هذا، لن تحتوي علامة `<a>` على سمة `href`، مما يؤثر على إمكانية الوصول إلى موقعك وقد يؤثر على تحسين محركات البحث (SEO). إذا كنت تستخدم [ESLint](/docs/pages/api-reference/config/eslint)، فهناك قاعدة مدمجة `next/link-passhref` لضمان الاستخدام الصحيح لـ `passHref`.

</AppOnly>

<PagesOnly>

إذا كان العنصر الفرعي لـ `Link` هو مكون مخصص يغلف علامة `<a>`، فيجب عليك إضافة `passHref` إلى `Link`. هذا ضروري إذا كنت تستخدم مكتبات مثل [styled-components](https://styled-components.com/). بدون هذا، لن تحتوي علامة `<a>` على سمة `href`، مما يؤثر على إمكانية الوصول إلى موقعك وقد يؤثر على تحسين محركات البحث (SEO). إذا كنت تستخدم [ESLint](/docs/pages/api-reference/config/eslint)، فهناك قاعدة مدمجة `next/link-passhref` لضمان الاستخدام الصحيح لـ `passHref`.

</PagesOnly>

```tsx filename="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// This creates a custom component that wraps an <a> tag
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

```jsx filename="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// This creates a custom component that wraps an <a> tag
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

- إذا كنت تستخدم ميزة JSX pragma الخاصة بـ [emotion](https://emotion.sh/) (`@jsx jsx`)، فيجب عليك استخدام `passHref` حتى إذا كنت تستخدم علامة `<a>` مباشرة.
- يجب أن يدعم المكون خاصية `onClick` لتنشيط التنقل بشكل صحيح.

### تداخل مكون وظيفي

إذا كان العنصر الفرعي لـ `Link` هو مكون وظيفي، بالإضافة إلى استخدام `passHref` و `legacyBehavior`، يجب عليك تغليف المكون بـ [`React.forwardRef`](https://react.dev/reference/react/forwardRef):

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Define the props type for MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Use React.ForwardRefRenderFunction to properly type the forwarded ref
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Use React.forwardRef to wrap the component
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href`, and `ref` need to be passed to the DOM element
// for proper handling
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Add a display name for the component (useful for debugging)
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Define the props type for MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Use React.ForwardRefRenderFunction to properly type the forwarded ref
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Use React.forwardRef to wrap the component
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href`, and `ref` need to be passed to the DOM element
// for proper handling
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Add a display name for the component (useful for debugging)
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

### تمرير كائن URL

يمكن لـ `Link` أيضًا استقبال كائن URL وسيقوم تلقائيًا بتنسيقه لإنشاء سلسلة URL:

```tsx filename="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

يحتوي المثال أعلاه على رابط إلى:

- مسار محدد مسبقًا: `/about?name=test`
- [مسار ديناميكي](/docs/app/api-reference/file-conventions/dynamic-routes): `/blog/my-post`

يمكنك استخدام كل خاصية كما هو موضح في [توثيق وحدة Node.js URL](https://nodejs.org/api/url.html#url_url_strings_and_url_objects).

</PagesOnly>

### استبدال URL بدلاً من الدفع

السلوك الافتراضي لمكون `Link` هو `دفع` عنوان URL جديد إلى مكدس `history`. يمكنك استخدام خاصية `replace` لمنع إضافة إدخال جديد، كما في المثال التالي:

<AppOnly>

```tsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</PagesOnly>

### تعطيل التمرير إلى أعلى الصفحة

<AppOnly>

السلوك الافتراضي للتمرير لـ `<Link>` في Next.js **هو الحفاظ على موضع التمرير**، مشابه لكيفية تعامل المتصفحات مع التنقل للخلف وللأمام. عند التنقل إلى [صفحة](/docs/app/api-reference/file-conventions/page) جديدة، سيبقى موضع التمرير كما هو طالما أن الصفحة مرئية في نافذة العرض.

ومع ذلك، إذا لم تكن الصفحة مرئية في نافذة العرض، فسوف يقوم Next.js بالتمرير إلى أعلى عنصر الصفحة الأول. إذا كنت ترغب في تعطيل هذا السلوك، يمكنك تمرير `scroll={false}` إلى مكون `<Link>`، أو `scroll: false` إلى `router.push()` أو `router.replace()`.

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

استخدام `router.push()` أو `router.replace()`:

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

السلوك الافتراضي لـ `Link` هو التمرير إلى أعلى الصفحة. عندما يكون هناك هاش محدد، سوف يمرر إلى المعرف المحدد، مثل علامة `<a>` العادية. لمنع التمرير إلى الأعلى / الهاش، يمكن إضافة `scroll={false}` إلى `Link`:

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Disables scrolling to the top
    </Link>
  )
}
```

</PagesOnly>

### جلب الروابط مسبقًا في Middleware

من الشائع استخدام [Middleware](/docs/app/building-your-application/routing/middleware) للمصادقة أو أغراض أخرى تتضمن إعادة توجيه المستخدم إلى صفحة مختلفة. لكي يعمل مكون `<Link />` بشكل صحيح في جلب الروابط مسبقًا مع عمليات إعادة الكتابة عبر Middleware، تحتاج إلى إخبار Next.js بكل من عنوان URL المعروض وعنوان URL المطلوب جلبها مسبقًا. هذا مطلوب لتجنب طلبات غير ضرورية إلى middleware لمعرفة المسار الصحيح الذي يجب جلبها مسبقًا.

على سبيل المثال، إذا كنت تريد تقديم مسار `/dashboard` الذي يحتوي على واجهات للمستخدمين المصادق عليهم والزوار، يمكنك إضافة ما يلي في Middleware الخاص بك لإعادة توجيه المستخدم إلى الصفحة الصحيحة:

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

في هذه الحالة، سترغب في استخدام الكود التالي في مكون `<Link />` الخاص بك:

<AppOnly>

```tsx filename="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

> **معلومة مفيدة**: إذا كنت تستخدم [المسارات الديناميكية (Dynamic Routes)](/docs/app/api-reference/file-conventions/dynamic-routes)، فستحتاج إلى تكييف خاصيتي `as` و `href`. على سبيل المثال، إذا كان لديك مسار ديناميكي مثل `/dashboard/authed/[user]` تريد عرضه بشكل مختلف عبر middleware، سوف تكتب: `<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>`.

</PagesOnly>

### منع التنقل

يمكنك استخدام الخاصية `onNavigate` لمنع التنقل عند استيفاء شروط معينة، مثل وجود تغييرات غير محفوظة في نموذج. عندما تحتاج إلى منع التنقل عبر عدة مكونات في تطبيقك (مثل منع التنقل من أي رابط أثناء تحرير نموذج)، يوفر React Context طريقة نظيفة لمشاركة حالة المنع هذه. أولاً، قم بإنشاء سياق لتتبع حالة منع التنقل:

```tsx filename="app/contexts/navigation-blocker.tsx" switcher
'use client'

import { createContext, useState, useContext } from 'react'

interface NavigationBlockerContextType {
  isBlocked: boolean
  setIsBlocked: (isBlocked: boolean) => void
}

export const NavigationBlockerContext =
  createContext<NavigationBlockerContextType>({
    isBlocked: false,
    setIsBlocked: () => {},
  })

export function NavigationBlockerProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

```jsx filename="app/contexts/navigation-blocker.js" switcher
'use client'

import { createContext, useState, useContext } from 'react'

export const NavigationBlockerContext = createContext({
  isBlocked: false,
  setIsBlocked: () => {},
})

export function NavigationBlockerProvider({ children }) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

قم بإنشاء مكون نموذج يستخدم السياق:

```tsx filename="app/components/form.tsx" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

```jsx filename="app/components/form.js" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

قم بإنشاء مكون رابط مخصص يمنع التنقل:

```tsx filename="app/components/custom-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

interface CustomLinkProps extends React.ComponentProps<typeof Link> {
  children: React.ReactNode
}

export function CustomLink({ children, ...props }: CustomLinkProps) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('You have unsaved changes. Leave anyway?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

```jsx filename="app/components/custom-link.js" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

export function CustomLink({ children, ...props }) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('You have unsaved changes. Leave anyway?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

قم بإنشاء مكون تنقل:

```tsx filename="app/components/nav.tsx" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

```jsx filename="app/components/nav.js" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

أخيرًا، قم بتغليف تطبيقك بـ `NavigationBlockerProvider` في التخطيط الجذري واستخدم المكونات في صفحتك:

```tsx filename="app/layout.tsx" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

ثم استخدم مكونات `Nav` و `Form` في صفحتك:

```tsx filename="app/page.tsx" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

عندما يحاول المستخدم التنقل بعيدًا باستخدام `CustomLink` بينما يحتوي النموذج على تغييرات غير محفوظة، سيتم مطالبتهم بالتأكيد قبل المغادرة.

## سجل الإصدارات

| الإصدار   | التغييرات                                                                                                                                                                      |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.3.0` | إضافة واجهة برمجة التطبيقات `onNavigate`                                                                                                                                                         |
| `v13.0.0` | لم يعد يتطلب علامة `<a>` فرعية. يتم توفير [أداة تحويل الكود (codemod)](/docs/app/guides/upgrading/codemods#remove-a-tags-from-link-components) لتحديث قاعدة الكود الخاصة بك تلقائيًا. |
| `v10.0.0` | يتم حل خاصية `href` التي تشير إلى مسار ديناميكي تلقائيًا ولم تعد تتطلب خاصية `as`.                                                                      |
| `v8.0.0`  | تحسين أداء الجلب المسبق.                                                                                                                                            |
| `v1.0.0`  | تم تقديم `next/link`.                                                                                                                                                      |
