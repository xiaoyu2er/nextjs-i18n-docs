---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:04:21.427Z
title: التخزين المؤقت في Next.js
nav_title: التخزين المؤقت
description: نظرة عامة على آليات التخزين المؤقت في Next.js.
---

يحسن Next.js أداء تطبيقك ويقلل التكاليف من خلال تخزين أعمال التصيير وطلبات البيانات مؤقتًا. توفر هذه الصفحة نظرة متعمقة على آليات التخزين المؤقت في Next.js، وواجهات برمجة التطبيقات (APIs) التي يمكنك استخدامها لتكوينها، وكيفية تفاعلها مع بعضها البعض.

> **معلومة مفيدة**: هذه الصفحة تساعدك على فهم كيفية عمل Next.js تحت الغطاء ولكنها **ليست** معرفة أساسية لتكون منتجًا مع Next.js. يتم تحديد معظم استدلالات التخزين المؤقت في Next.js من خلال استخدامك لواجهات برمجة التطبيقات ولديها إعدادات افتراضية لأفضل أداء مع تكوين صفري أو أدنى. إذا كنت تريد الانتقال مباشرة إلى الأمثلة، [ابدأ من هنا](/docs/app/getting-started/fetching-data).

## نظرة عامة

فيما يلي نظرة عامة عالية المستوى على آليات التخزين المؤقت المختلفة والغرض منها:

| الآلية                                   | ماذا تفعل                  | أين    | الغرض                                         | المدة                        |
| ------------------------------------------- | -------------------------- | ------ | ----------------------------------------------- | ------------------------------- |
| [تخزين الطلبات مؤقتًا](#request-memoization) | قيم إرجاع الدوال | الخادم | إعادة استخدام البيانات في شجرة مكونات React           | دورة حياة الطلب           |
| [ذاكرة التخزين المؤقت للبيانات](#data-cache)                   | البيانات                       | الخادم | تخزين البيانات عبر طلبات المستخدم والنشرات | دائمة (يمكن إعادة التحقق منها) |
| [ذاكرة التخزين المؤقت الكاملة للطريق](#full-route-cache)       | HTML وحمولة RSC       | الخادم | تقليل تكلفة التصيير وتحسين الأداء   | دائمة (يمكن إعادة التحقق منها) |
| [ذاكرة التخزين المؤقت للموجه (على جانب العميل)](#client-side-router-cache)   | حمولة RSC                | العميل | تقليل طلبات الخادم أثناء التنقل            | جلسة المستخدم أو زمنية      |

بشكل افتراضي، سيخزن Next.js أكبر قدر ممكن لتحسين الأداء وتقليل التكلفة. هذا يعني أن المسارات يتم **تصييرها بشكل ثابت** وطلبات البيانات يتم **تخزينها مؤقتًا** ما لم تختار عدم ذلك. يوضح الرسم البياني أدناه سلوك التخزين المؤقت الافتراضي: عندما يتم تصيير مسار بشكل ثابت في وقت البناء وعند زيارة مسار ثابت لأول مرة.

<Image
  alt="رسم بياني يوضح سلوك التخزين المؤقت الافتراضي في Next.js للآليات الأربع، مع HIT و MISS و SET في وقت البناء وعند زيارة المسار لأول مرة."
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

يتغير سلوك التخزين المؤقت اعتمادًا على ما إذا كان المسار يتم تصييره بشكل ثابت أو ديناميكي، وما إذا كانت البيانات مخزنة مؤقتًا أو غير مخزنة، وما إذا كان الطلب جزءًا من زيارة أولية أو تنقل لاحق. اعتمادًا على حالة الاستخدام الخاصة بك، يمكنك تكوين سلوك التخزين المؤقت للمسارات الفردية وطلبات البيانات.

## تخزين الطلبات مؤقتًا

يمتد Next.js لواجهة برمجة التطبيقات [`fetch`](#fetch) لتخزين الطلبات التي لها نفس URL والخيارات تلقائيًا **مؤقتًا**. هذا يعني أنه يمكنك استدعاء دالة fetch لنفس البيانات في أماكن متعددة في شجرة مكونات React مع تنفيذها مرة واحدة فقط.

<Image
  alt="طلبات Fetch المكررة"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

على سبيل المثال، إذا كنت بحاجة إلى استخدام نفس البيانات عبر مسار (مثل في Layout و Page ومكونات متعددة)، لا يتعين عليك جلب البيانات في أعلى الشجرة وإعادة توجيه الخصائص بين المكونات. بدلاً من ذلك، يمكنك جلب البيانات في المكونات التي تحتاجها دون القلق بشأن الآثار المترتبة على الأداء لإنشاء طلبات متعددة عبر الشبكة لنفس البيانات.

```tsx filename="app/example.tsx" switcher
async function getItem() {
  // يتم تخزين دالة `fetch` تلقائيًا مؤقتًا والنتيجة
  // يتم تخزينها مؤقتًا
  const res = await fetch('https://.../item/1')
  return res.json()
}

// يتم استدعاء هذه الدالة مرتين، ولكن يتم تنفيذها فقط في المرة الأولى
const item = await getItem() // cache MISS

// يمكن أن يكون الاستدعاء الثاني في أي مكان في مسارك
const item = await getItem() // cache HIT
```

```jsx filename="app/example.js" switcher
async function getItem() {
  // يتم تخزين دالة `fetch` تلقائيًا مؤقتًا والنتيجة
  // يتم تخزينها مؤقتًا
  const res = await fetch('https://.../item/1')
  return res.json()
}

// يتم استدعاء هذه الدالة مرتين، ولكن يتم تنفيذها فقط في المرة الأولى
const item = await getItem() // cache MISS

// يمكن أن يكون الاستدعاء الثاني في أي مكان في مسارك
const item = await getItem() // cache HIT
```

**كيف يعمل تخزين الطلبات مؤقتًا**

<Image
  alt="رسم بياني يوضح كيفية عمل تخزين fetch مؤقتًا أثناء تصيير React."
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- أثناء تصيير مسار، في المرة الأولى التي يتم فيها استدعاء طلب معين، لن تكون نتيجته في الذاكرة وسيكون cache `MISS`.
- لذلك، سيتم تنفيذ الدالة، وسيتم جلب البيانات من المصدر الخارجي، وسيتم تخزين النتيجة في الذاكرة.
- سيتم اعتبار الاستدعاءات اللاحقة للطلب في نفس تمرير التصيير cache `HIT`، وسيتم إرجاع البيانات من الذاكرة دون تنفيذ الدالة.
- بمجرد اكتمال تصيير المسار وتمرير التصيير، يتم "إعادة تعيين" الذاكرة ومسح جميع إدخالات تخزين الطلبات مؤقتًا.

> **معلومة مفيدة**:
>
> - تخزين الطلبات مؤقتًا هو ميزة React وليست ميزة Next.js. يتم تضمينها هنا لإظهار كيفية تفاعلها مع آليات التخزين المؤقت الأخرى.
> - ينطبق التخزين المؤقت فقط على طريقة `GET` في طلبات `fetch`.
> - ينطبق التخزين المؤقت فقط على شجرة مكونات React، وهذا يعني:
>   - ينطبق على طلبات `fetch` في `generateMetadata` و `generateStaticParams` و Layouts و Pages ومكونات الخادم الأخرى.
>   - لا ينطبق على طلبات `fetch` في Route Handlers لأنها ليست جزءًا من شجرة مكونات React.
> - للحالات التي لا يكون فيها `fetch` مناسبًا (مثل بعض عملاء قواعد البيانات أو عملاء CMS أو عملاء GraphQL)، يمكنك استخدام [دالة `cache` في React](#react-cache-function) لتخزين الدوال مؤقتًا.

### المدة

يستمر التخزين المؤقت طوال عمر طلب الخادم حتى تكتمل شجرة مكونات React في التصيير.

### إعادة التحقق

نظرًا لأن التخزين المؤقت لا يتم مشاركته عبر طلبات الخادم وينطبق فقط أثناء التصيير، فلا حاجة لإعادة التحقق منه.

### عدم التخزين المؤقت

ينطبق التخزين المؤقت فقط على طريقة `GET` في طلبات `fetch`، ولا يتم تخزين الطرق الأخرى مثل `POST` و `DELETE` مؤقتًا. هذا السلوك الافتراضي هو تحسين React ولا نوصي بعدم استخدامه.

لإدارة الطلبات الفردية، يمكنك استخدام خاصية [`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal) من [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController). ومع ذلك، لن يؤدي هذا إلى عدم تخزين الطلبات مؤقتًا، بل سيؤدي إلى إلغاء الطلبات الجارية.

```js filename="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## ذاكرة التخزين المؤقت للبيانات

يحتوي Next.js على ذاكرة تخزين مؤقت مدمجة للبيانات تحافظ على نتيجة جلب البيانات عبر **طلبات الخادم** الواردة و**النشرات**. هذا ممكن لأن Next.js يمتد لواجهة برمجة التطبيقات `fetch` الأصلية للسماح لكل طلب على الخادم بتعيين دلالات التخزين المؤقت الخاصة به.

> **معلومة مفيدة**: في المتصفح، يشير خيار `cache` لـ `fetch` إلى كيفية تفاعل الطلب مع ذاكرة التخزين المؤقت HTTP للمتصفح، في Next.js، يشير خيار `cache` إلى كيفية تفاعل طلب جانب الخادم مع ذاكرة التخزين المؤقت للبيانات على الخادم.

يمكنك استخدام خيارات [`cache`](#fetch-optionscache) و [`next.revalidate`](#fetch-optionsnextrevalidate) لـ `fetch` لتكوين سلوك التخزين المؤقت.

**كيف تعمل ذاكرة التخزين المؤقت للبيانات**

<Image
  alt="رسم بياني يوضح كيفية تفاعل طلبات fetch المخزنة وغير المخزنة مع ذاكرة التخزين المؤقت للبيانات. يتم تخزين الطلبات المخزنة في ذاكرة التخزين المؤقت للبيانات، وتخزين الطلبات غير المخزنة من مصدر البيانات، وعدم تخزينها في ذاكرة التخزين المؤقت للبيانات، وتخزينها مؤقتًا."
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- في المرة الأولى التي يتم فيها استدعاء طلب `fetch` مع خيار `'force-cache'` أثناء التصيير، يتحقق Next.js من ذاكرة التخزين المؤقت للبيانات للحصول على استجابة مخزنة.
- إذا تم العثور على استجابة مخزنة، يتم إرجاعها على الفور و[تخزينها مؤقتًا](#request-memoization).
- إذا لم يتم العثور على استجابة مخزنة، يتم إجراء الطلب إلى مصدر البيانات، يتم تخزين النتيجة في ذاكرة التخزين المؤقت للبيانات، وتخزينها مؤقتًا.
- بالنسبة للبيانات غير المخزنة (مثل عدم تعريف خيار `cache` أو استخدام `{ cache: 'no-store' }`)، يتم دائمًا جلب النتيجة من مصدر البيانات، وتخزينها مؤقتًا.
- سواء كانت البيانات مخزنة أو غير مخزنة، يتم دائمًا تخزين الطلبات مؤقتًا لتجنب إنشاء طلبات مكررة لنفس البيانات أثناء تمرير تصيير React.

> **الاختلافات بين ذاكرة التخزين المؤقت للبيانات وتخزين الطلبات مؤقتًا**
>
> بينما تساعد كلتا آليتي التخزين المؤقت في تحسين الأداء من خلال إعادة استخدام البيانات المخزنة مؤقتًا، فإن ذاكرة التخزين المؤقت للبيانات دائمة عبر الطلبات الواردة والنشرات، بينما يستمر التخزين المؤقت فقط طوال عمر الطلب.

### المدة

ذاكرة التخزين المؤقت للبيانات دائمة عبر الطلبات الواردة والنشرات ما لم تقم بإعادة التحقق أو عدم التخزين المؤقت.

### إعادة التحقق

يمكن إعادة التحقق من البيانات المخزنة مؤقتًا بطريقتين، باستخدام:

- **إعادة التحقق الزمنية**: إعادة التحقق من البيانات بعد مرور فترة زمنية معينة وإجراء طلب جديد. هذا مفيد للبيانات التي تتغير بشكل غير متكرر ولا تكون الحداثة حرجة.
- **إعادة التحقق عند الطلب:** إعادة التحقق من البيانات بناءً على حدث (مثل إرسال نموذج). يمكن أن تستخدم إعادة التحقق عند الطلب نهجًا يعتمد على العلامات أو المسار لإعادة التحقق من مجموعات البيانات دفعة واحدة. هذا مفيد عندما تريد التأكد من عرض أحدث البيانات في أقرب وقت ممكن (مثل عند تحديث المحتوى من نظام إدارة المحتوى الخاص بك).

#### إعادة التحقق الزمنية

لإعادة التحقق من البيانات على فترات زمنية، يمكنك استخدام خيار `next.revalidate` لـ `fetch` لتعيين عمر ذاكرة التخزين المؤقت للمورد (بالثواني).

```js
// إعادة التحقق على الأكثر كل ساعة
fetch('https://...', { next: { revalidate: 3600 } })
```

بدلاً من ذلك، يمكنك استخدام [خيارات تكوين مقطع المسار](#segment-config-options) لتكوين جميع طلبات `fetch` في مقطع أو للحالات التي لا يمكنك فيها استخدام `fetch`.

**كيف تعمل إعادة التحقق الزمنية**

<Image
  alt="رسم بياني يوضح كيفية عمل إعادة التحقق الزمنية، بعد فترة إعادة التحقق، يتم إرجاع البيانات القديمة للطلب الأول، ثم يتم إعادة التحقق من البيانات."
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- في المرة الأولى التي يتم فيها استدعاء طلب fetch مع `revalidate`، سيتم جلب البيانات من مصدر البيانات الخارجي وتخزينها في ذاكرة التخزين المؤقت للبيانات.
- أي طلبات يتم استدعاؤها خلال الإطار الزمني المحدد (مثل 60 ثانية) سترجع البيانات المخزنة.
- بعد الإطار الزمني، سيظل الطلب التالي يرجع البيانات المخزنة (القديمة الآن).
  - سيؤدي Next.js إلى إعادة التحقق من البيانات في الخلفية.
  - بمجرد جلب البيانات بنجاح، سيحدث Next.js ذاكرة التخزين المؤقت للبيانات بالبيانات الجديدة.
  - إذا فشلت إعادة التحقق في الخلفية، سيتم الاحتفاظ بالبيانات السابقة دون تغيير.

هذا مشابه لسلوك [**stale-while-revalidate**](https://web.dev/articles/stale-while-revalidate).

#### إعادة التحقق عند الطلب

يمكن إعادة التحقق من البيانات عند الطلب حسب المسار ([`revalidatePath`](#revalidatepath)) أو حسب علامة التخزين المؤقت ([`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)).

**كيف تعمل إعادة التحقق عند الطلب**

<Image
  alt="رسم بياني يوضح كيفية عمل إعادة التحقق عند الطلب، يتم تحديث ذاكرة التخزين المؤقت للبيانات بالبيانات الجديدة بعد طلب إعادة التحقق."
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- في المرة الأولى التي يتم فيها استدعاء طلب `fetch`، سيتم جلب البيانات من مصدر البيانات الخارجي وتخزينها في ذاكرة التخزين المؤقت للبيانات.
- عند تشغيل إعادة التحقق عند الطلب، سيتم مسح إدخالات التخزين المؤقت المناسبة من الذاكرة.
  - هذا يختلف عن إعادة التحقق الزمنية، التي تحتفظ بالبيانات القديمة في الذاكرة حتى يتم جلب البيانات الجديدة.
- في المرة التالية التي يتم فيها إجراء طلب، سيكون cache `MISS` مرة أخرى، وسيتم جلب البيانات من مصدر البيانات الخارجي وتخزينها في ذاكرة التخزين المؤقت للبيانات.

### عدم التخزين المؤقت

إذا كنت لا تريد تخزين استجابة `fetch` مؤقتًا، يمكنك القيام بما يلي:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## ذاكرة التخزين المؤقت الكاملة للطريق

> **مصطلحات ذات صلة**:
>
> قد ترى مصطلحات **التحسين الثابت التلقائي** أو **توليد الموقع الثابت** أو **التصيير الثابت** تُستخدم بالتبادل للإشارة إلى عملية تصيير وتخزين مسارات تطبيقك في وقت البناء.

يقوم Next.js تلقائيًا بتصيير وتخزين المسارات مؤقتًا في وقت البناء. هذا تحسين يسمح لك بتقديم المسار المخزن مؤقتًا بدلاً من التصيير على الخادم لكل طلب، مما يؤدي إلى تحميل أسرع للصفحات.

لفهم كيفية عمل ذاكرة التخزين المؤقت الكاملة للطريق، من المفيد النظر إلى كيفية تعامل React مع التصيير، وكيف يقوم Next.js بتخزين النتيجة:

### 1. تصيير React على الخادم

على الخادم، يستخدم Next.js واجهات برمجة تطبيقات React لتنسيق التصيير. يتم تقسيم عمل التصيير إلى أجزاء: حسب مقاطع المسار الفردية وحدود Suspense.

يتم تصيير كل جزء في خطوتين:

1. يقوم React بتصيير مكونات الخادم إلى تنسيق بيانات خاص مُحسّن للبث، يُسمى **React Server Component Payload**.
2. يستخدم Next.js React Server Component Payload وتعليمات JavaScript لمكونات العميل لتصيير **HTML** على الخادم.

هذا يعني أننا لسنا مضطرين للانتظار حتى يكتمل كل شيء قبل تخزين العمل أو إرسال استجابة. بدلاً من ذلك، يمكننا بث استجابة أثناء اكتمال العمل.

> **ما هو React Server Component Payload؟**
>
> React Server Component Payload هو تمثيل ثنائي مضغوط لشجرة مكونات خادم React المصيرة. يتم استخدامه بواسطة React على العميل لتحديث DOM للمتصفح. يحتوي React Server Component Payload على:
>
> - نتيجة تصيير مكونات الخادم
> - عناصر نائبة لمكان تصيير مكونات العميل ومراجع لملفات JavaScript الخاصة بها
> - أي خصائص تم تمريرها من مكون خادم إلى مكون عميل
>
> لمعرفة المزيد، راجع وثائق [مكونات الخادم](/docs/app/getting-started/server-and-client-components).

### 2. تخزين Next.js على الخادم (ذاكرة التخزين المؤقت الكاملة للطريق)

<Image
  alt="السلوك الافتراضي لذاكرة التخزين المؤقت الكاملة للطريق، يوضح كيفية تخزين React Server Component Payload و HTML على الخادم للمسارات المصيرة بشكل ثابت."
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

السلوك الافتراضي لـ Next.js هو تخزين نتيجة التصيير (React Server Component Payload و HTML) لمسار على الخادم. ينطبق هذا على المسارات المصيرة بشكل ثابت في وقت البناء، أو أثناء إعادة التحقق.

### 3. ترطيب React والمصالحة على العميل

في وقت الطلب، على العميل:

1. يتم استخدام HTML لعرض معاينة أولية سريعة غير تفاعلية لمكونات العميل والخادم.
2. يتم استخدام React Server Components Payload لمصالحة أشجار مكونات العميل والخادم المصيرة، وتحديث DOM.
3. يتم استخدام تعليمات JavaScript [لترطيب](https://react.dev/reference/react-dom/client/hydrateRoot) مكونات العميل وجعل التطبيق تفاعليًا.

### 4. تخزين Next.js على العميل (ذاكرة التخزين المؤقت للموجه)

يتم تخزين React Server Component Payload في ذاكرة التخزين المؤقت للموجه على جانب العميل - وهي ذاكرة تخزين مؤقت منفصلة في الذاكرة، مقسمة حسب مقاطع المسار الفردية. تُستخدم ذاكرة التخزين المؤقت للموجه لتحسين تجربة التنقل من خلال تخزين المسارات التي تمت زيارتها مسبقًا وجلب المسارات المستقبلية مسبقًا.

### 5. التنقلات اللاحقة

في التنقلات اللاحقة أو أثناء الجلب المسبق، سيتحقق Next.js مما إذا كان React Server Components Payload مخزنًا في ذاكرة التخزين المؤقت للموجه. إذا كان الأمر كذلك، فسيتم تخطي إرسال طلب جديد إلى الخادم.

إذا لم تكن مقاطع المسار في الذاكرة المؤقتة، فسوف يقوم Next.js بجلب React Server Components Payload من الخادم، وملء ذاكرة التخزين المؤقت للموجه على العميل.

### التصيير الثابت والديناميكي

ما إذا كان المسار مخزنًا مؤقتًا أم لا أثناء وقت البناء يعتمد على ما إذا كان يتم تصييره بشكل ثابت أو ديناميكي. يتم تخزين المسارات الثابتة مؤقتًا افتراضيًا، بينما يتم تصيير المسارات الديناميكية عند وقت الطلب ولا يتم تخزينها مؤقتًا.

يوضح هذا الرسم البياني الفرق بين المسارات المصيرة بشكل ثابت وديناميكي، مع البيانات المخزنة مؤقتًا وغير المخزنة:

<Image
  alt="كيف يؤثر التصيير الثابت والديناميكي على ذاكرة التخزين المؤقت الكاملة للمسار. يتم تخزين المسارات الثابتة مؤقتًا في وقت البناء أو بعد إعادة التحقق من البيانات، بينما لا يتم تخزين المسارات الديناميكية مؤقتًا أبدًا"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

تعلم المزيد حول [التصيير الثابت والديناميكي](/docs/app/getting-started/partial-prerendering#static-rendering).

### المدة الزمنية

افتراضيًا، تكون ذاكرة التخزين المؤقت الكاملة للمسار دائمة. هذا يعني أن ناتج التصيير يتم تخزينه مؤقتًا عبر طلبات المستخدم.

### الإبطال

هناك طريقتان يمكنك من خلالهما إبطال ذاكرة التخزين المؤقت الكاملة للمسار:

- **[إعادة التحقق من البيانات](/docs/app/deep-dive/caching#revalidating)**: إعادة التحقق من [ذاكرة التخزين المؤقت للبيانات](#data-cache) سيقوم بدوره بإبطال ذاكرة التخزين المؤقت للموجه عن طريق إعادة تصيير المكونات على الخادم وتخزين ناتج التصيير الجديد مؤقتًا.
- **إعادة النشر**: على عكس ذاكرة التخزين المؤقت للبيانات التي تظل عبر عمليات النشر، يتم مسح ذاكرة التخزين المؤقت الكاملة للمسار عند عمليات النشر الجديدة.

### الانسحاب

يمكنك الانسحاب من ذاكرة التخزين المؤقت الكاملة للمسار، أو بعبارة أخرى، تصيير المكونات ديناميكيًا لكل طلب وارد، عن طريق:

- **استخدام [واجهات برمجة التطبيقات الديناميكية](#dynamic-apis)**: سيؤدي هذا إلى انسحاب المسار من ذاكرة التخزين المؤقت الكاملة للمسار وتصييره ديناميكيًا عند وقت الطلب. لا يزال يمكن استخدام ذاكرة التخزين المؤقت للبيانات.
- **استخدام خيارات تكوين قطعة المسار `dynamic = 'force-dynamic'` أو `revalidate = 0`**: سيؤدي هذا إلى تخطي ذاكرة التخزين المؤقت الكاملة للمسار وذاكرة التخزين المؤقت للبيانات. مما يعني أنه سيتم تصيير المكونات وجلب البيانات في كل طلب وارد إلى الخادم. ستظل ذاكرة التخزين المؤقت للموجه سارية لأنها ذاكرة تخزين مؤقت على جانب العميل.
- **الانسحاب من [ذاكرة التخزين المؤقت للبيانات](#data-cache)**: إذا كان للمسار طلب `fetch` غير مخزن مؤقتًا، فسيؤدي هذا إلى انسحاب المسار من ذاكرة التخزين المؤقت الكاملة للمسار. سيتم جلب البيانات لطلب `fetch` المحدد لكل طلب وارد. سيظل تخزين طلبات `fetch` الأخرى التي لا تنسحب من التخزين المؤقت في ذاكرة التخزين المؤقت للبيانات. وهذا يسمح بمزيج من البيانات المخزنة وغير المخزنة مؤقتًا.

## ذاكرة التخزين المؤقت للموجه على جانب العميل

يحتوي Next.js على ذاكرة تخزين مؤقت للموجه على جانب العميل في الذاكرة تقوم بتخزين حمولة RSC لقطع المسار، مقسمة حسب التخطيطات وحالات التحميل والصفحات.

عندما يتنقل المستخدم بين المسارات، يقوم Next.js بتخزين قطع المسار التي تمت زيارتها [والتجهيز المسبق](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) للمسارات التي من المحتمل أن يتنقل إليها المستخدم. يؤدي هذا إلى التنقل الفوري للخلف/الأمام، وعدم الحاجة إلى إعادة تحميل الصفحة بالكامل بين عمليات التنقل، والحفاظ على حالة React وحالة المتصفح.

مع ذاكرة التخزين المؤقت للموجه:

- **التخطيطات** يتم تخزينها وإعادة استخدامها عند التنقل ([التصيير الجزئي](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)).
- **حالات التحميل** يتم تخزينها وإعادة استخدامها عند التنقل لـ[حالات التحميل الفورية](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- **الصفحات** لا يتم تخزينها مؤقتًا افتراضيًا، ولكن يتم إعادة استخدامها أثناء التنقل للخلف والأمام في المتصفح. يمكنك تمكين التخزين المؤقت لقطع الصفحة باستخدام خيار التكوين التجريبي [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes).

{/* TODO: تحديث الرسم البياني لتطابق سلوك الإصدار 15 */}

> **من الجيد معرفة:** هذه الذاكرة المؤقتة تنطبق تحديدًا على Next.js ومكونات الخادم، وهي مختلفة عن [bfcache](https://web.dev/bfcache/) للمتصفح، على الرغم من أن لها نتيجة مماثلة.

### المدة الزمنية

يتم تخزين الذاكرة المؤقتة في الذاكرة المؤقتة للمتصفح. هناك عاملان يحددان مدة بقاء ذاكرة التخزين المؤقت للموجه:

- **الجلسة**: تظل الذاكرة المؤقتة عبر التنقل. ومع ذلك، يتم مسحها عند تحديث الصفحة.
- **فترة الإبطال التلقائي**: يتم إبطال ذاكرة التخزين المؤقت للتخطيطات وحالات التحميل تلقائيًا بعد وقت محدد. تعتمد المدة على كيفية [التجهيز المسبق](/docs/app/api-reference/components/link#prefetch) للمورد، وما إذا كان المورد قد تم [توليده بشكل ثابت](/docs/app/getting-started/partial-prerendering#static-rendering):
  - **التجهيز المسبق الافتراضي** (`prefetch={null}` أو غير محدد): غير مخزن للصفحات الديناميكية، 5 دقائق للصفحات الثابتة.
  - **التجهيز المسبق الكامل** (`prefetch={true}` أو `router.prefetch`): 5 دقائق لكل من الصفحات الثابتة والديناميكية.

بينما يؤدي تحديث الصفحة إلى مسح **جميع** القطع المخزنة مؤقتًا، فإن فترة الإبطال التلقائي تؤثر فقط على القطعة الفردية من وقت التجهيز المسبق لها.

> **من الجيد معرفة**: يمكن استخدام خيار التكوين التجريبي [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) لضبط أوقات الإبطال التلقائي المذكورة أعلاه.

### الإبطال

هناك طريقتان يمكنك من خلالهما إبطال ذاكرة التخزين المؤقت للموجه:

- في **إجراء الخادم**:
  - إعادة التحقق من البيانات عند الطلب حسب المسار باستخدام ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)) أو حسب علامة التخزين المؤقت باستخدام ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))
  - استخدام [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie) أو [`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies) يبطل ذاكرة التخزين المؤقت للموجه لمنع المسارات التي تستخدم ملفات تعريف الارتباط من أن تصبح قديمة (مثل المصادقة).
- استدعاء [`router.refresh`](/docs/app/api-reference/functions/use-router) سيبطل ذاكرة التخزين المؤقت للموجه ويجعل طلبًا جديدًا إلى الخادم للمسار الحالي.

### الانسحاب

اعتبارًا من Next.js 15، يتم انسحاب قطع الصفحة افتراضيًا.

> **من الجيد معرفة:** يمكنك أيضًا الانسحاب من [التجهيز المسبق](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) عن طريق تعيين خاصية `prefetch` لمكون `<Link>` على `false`.

## تفاعلات التخزين المؤقت

عند تكوين آليات التخزين المؤقت المختلفة، من المهم فهم كيفية تفاعلها مع بعضها البعض:

### ذاكرة التخزين المؤقت للبيانات وذاكرة التخزين المؤقت الكاملة للمسار

- إعادة التحقق أو الانسحاب من ذاكرة التخزين المؤقت للبيانات **سوف** يبطل ذاكرة التخزين المؤقت الكاملة للمسار، حيث يعتمد ناتج التصيير على البيانات.
- إبطال أو الانسحاب من ذاكرة التخزين المؤقت الكاملة للمسار **لا يؤثر** على ذاكرة التخزين المؤقت للبيانات. يمكنك تصيير مسار ديناميكي يحتوي على بيانات مخزنة وغير مخزنة مؤقتًا. هذا مفيد عندما تستخدم معظم صفحتك بيانات مخزنة مؤقتًا، ولكن لديك بعض المكونات التي تعتمد على بيانات تحتاج إلى جلبها عند وقت الطلب. يمكنك التصيير ديناميكيًا دون القلق بشأن تأثير الأداء لإعادة جلب جميع البيانات.

### ذاكرة التخزين المؤقت للبيانات وذاكرة التخزين المؤقت للموجه على جانب العميل

- لإبطال ذاكرة التخزين المؤقت للبيانات وذاكرة الموجه على الفور، يمكنك استخدام [`revalidatePath`](#revalidatepath) أو [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag) في [إجراء الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
- إعادة التحقق من ذاكرة التخزين المؤقت للبيانات في [معالج المسار](/docs/app/building-your-application/routing/route-handlers) **لن يبطل** ذاكرة التخزين المؤقت للموجه على الفور لأن معالج المسار غير مرتب بمسار محدد. هذا يعني أن ذاكرة التخزين المؤقت للموجه ستستمر في تقديم الحمولة السابقة حتى تحديث قوي، أو انتهاء فترة الإبطال التلقائي.

## واجهات برمجة التطبيقات

يوضح الجدول التالي نظرة عامة على كيفية تأثير واجهات برمجة التطبيقات المختلفة لـ Next.js على التخزين المؤقت:

| الواجهة البرمجية                                                                     | ذاكرة الموجه               | الذاكرة الكاملة للمسار      | ذاكرة البيانات            | ذاكرة React |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | تخزين                      |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | تخزين                      |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | إعادة التحقق                 |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | تخزين                 | تخزين       |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | تخزين أو انسحاب      |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | إعادة التحقق            | إعادة التحقق            |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | تخزين                 | تخزين                 |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | إعادة التحقق (إجراء الخادم) | إعادة التحقق            | إعادة التحقق            |             |
| [`revalidatePath`](#revalidatepath)                                     | إعادة التحقق (إجراء الخادم) | إعادة التحقق            | إعادة التحقق            |             |
| [`const revalidate`](#segment-config-options)                           |                            | إعادة التحقق أو انسحاب | إعادة التحقق أو انسحاب |             |
| [`const dynamic`](#segment-config-options)                              |                            | تخزين أو انسحاب      | تخزين أو انسحاب      |             |
| [`cookies`](#cookies)                                                   | إعادة التحقق (إجراء الخادم) | انسحاب               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | انسحاب               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | تخزين                 |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | تخزين       |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | تخزين                 |             |

### `<Link>`

افتراضيًا، يقوم مكون `<Link>` تلقائيًا بالتجهيز المسبق للمسارات من ذاكرة التخزين المؤقت الكاملة للمسار وإضافة حمولة مكون خادم React إلى ذاكرة التخزين المؤقت للموجه.

لتعطيل التجهيز المسبق، يمكنك تعيين خاصية `prefetch` على `false`. ولكن هذا لن يتخطى التخزين المؤقت بشكل دائم، سيتم تخزين قطعة المسار على جانب العميل عندما يزور المستخدم المسار.

تعلم المزيد حول [مكون `<Link>`](/docs/app/api-reference/components/link).

### `router.prefetch`

يمكن استخدام خيار `prefetch` لـ `useRouter` للتجهيز المسبق لمسار يدويًا. هذا يضيف حمولة مكون خادم React إلى ذاكرة التخزين المؤقت للموجه.

راجع مرجع [واجهة برمجة التطبيقات لـ `useRouter`](/docs/app/api-reference/functions/use-router).

### `router.refresh`

يمكن استخدام خيار `refresh` لـ `useRouter` لتحديث مسار يدويًا. هذا يمسح ذاكرة التخزين المؤقت للموجه بالكامل، ويجعل طلبًا جديدًا إلى الخادم للمسار الحالي. لا يؤثر `refresh` على ذاكرة التخزين المؤقت للبيانات أو الذاكرة الكاملة للمسار.

سيتم التوفيق بين نتيجة التصيير على جانب العميل مع الحفاظ على حالة React وحالة المتصفح.

راجع مرجع [واجهة برمجة التطبيقات لـ `useRouter`](/docs/app/api-reference/functions/use-router).

### `fetch`

البيانات التي يتم إرجاعها من `fetch` **لا** يتم تخزينها تلقائيًا في ذاكرة التخزين المؤقت للبيانات.

سلوك التخزين المؤقت الافتراضي لـ `fetch` (على سبيل المثال، عندما لا يتم تحديد خيار `cache`) يساوي تعيين خيار `cache` على `no-store`:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

راجع [مرجع واجهة برمجة التطبيقات لـ `fetch`](/docs/app/api-reference/functions/fetch) لمزيد من الخيارات.

### `fetch options.cache`

يمكنك اختيار تخزين `fetch` فردي مؤقتًا عن طريق تعيين خيار `cache` على `force-cache`:

```jsx
// اختيار التخزين المؤقت
fetch(`https://...`, { cache: 'force-cache' })
```

راجع [مرجع واجهة برمجة التطبيقات لـ `fetch`](/docs/app/api-reference/functions/fetch) لمزيد من الخيارات.

### `fetch options.next.revalidate`

يمكنك استخدام خيار `next.revalidate` لـ `fetch` لتعيين فترة إعادة التحقق (بالثواني) لطلب `fetch` فردي. سيؤدي هذا إلى إعادة التحقق من ذاكرة التخزين المؤقت للبيانات، مما سيؤدي بدوره إلى إعادة التحقق من ذاكرة التخزين المؤقت الكاملة للمسار. سيتم جلب بيانات جديدة، وسيتم إعادة تصيير المكونات على الخادم.

```jsx
// إعادة التحقق على الأكثر بعد ساعة واحدة
fetch(`https://...`, { next: { revalidate: 3600 } })
```

راجع [مرجع واجهة برمجة التطبيقات لـ `fetch`](/docs/app/api-reference/functions/fetch) لمزيد من الخيارات.

### `fetch options.next.tags` و `revalidateTag`

يحتوي Next.js على نظام وضع علامات على التخزين المؤقت للتحكم الدقيق في تخزين البيانات وإعادة التحقق منها.

1. عند استخدام `fetch` أو [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)، لديك خيار وضع علامة على إدخالات التخزين المؤقت بواحدة أو أكثر من العلامات.
2. ثم، يمكنك استدعاء `revalidateTag` لمسح إدخالات التخزين المؤقت المرتبطة بهذه العلامة.

على سبيل المثال، يمكنك تعيين علامة عند جلب البيانات:

```jsx
// تخزين البيانات بعلامة
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

ثم، استدعاء `revalidateTag` بعلامة لمسح إدخال التخزين المؤقت:

```jsx
// إعادة التحقق من الإدخالات بعلامة محددة
revalidateTag('a')
```

هناك مكانان يمكنك استخدام `revalidateTag` فيهما، اعتمادًا على ما تحاول تحقيقه:

1. [معالجات المسار](/docs/app/building-your-application/routing/route-handlers) - لإعادة التحقق من البيانات استجابةً لحدث طرف ثالث (مثل webhook). لن يؤدي هذا إلى إبطال ذاكرة التخزين المؤقت للموجه على الفور لأن معالج المسار غير مرتب بمسار محدد.
2. [إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - لإعادة التحقق من البيانات بعد إجراء مستخدم (مثل تقديم نموذج). سيؤدي هذا إلى إبطال ذاكرة التخزين المؤقت للموجه للمسار المرتبط.

### `revalidatePath`

يسمح لك `revalidatePath` بإعادة التحقق من البيانات يدويًا **و** إعادة تصيير قطع المسار أسفل مسار محدد في عملية واحدة. يؤدي استدعاء طريقة `revalidatePath` إلى إعادة التحقق من ذاكرة التخزين المؤقت للبيانات، مما يؤدي بدوره إلى إبطال ذاكرة التخزين المؤقت الكاملة للمسار.

```jsx
revalidatePath('/')
```

هناك مكانان يمكنك استخدام `revalidatePath` فيهما، اعتمادًا على ما تحاول تحقيقه:

1. [معالجات المسار](/docs/app/building-your-application/routing/route-handlers) - لإعادة التحقق من البيانات استجابةً لحدث طرف ثالث (مثل webhook).
2. [إجراءات الخادم](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - لإعادة التحقق من البيانات بعد تفاعل المستخدم (مثل تقديم نموذج، النقر على زر).

راجع [مرجع واجهة برمجة التطبيقات لـ `revalidatePath`](/docs/app/api-reference/functions/revalidatePath) لمزيد من المعلومات.

> **`revalidatePath`** مقابل **`router.refresh`**:
>
> يؤدي استدعاء `router.refresh` إلى مسح ذاكرة التخزين المؤقت للموجه، وإعادة تصيير قطع المسار على الخادم دون إبطال ذاكرة التخزين المؤقت للبيانات أو الذاكرة الكاملة للمسار.
>
> الفرق هو أن `revalidatePath` يمسح ذاكرة التخزين المؤقت للبيانات والذاكرة الكاملة للمسار، بينما `router.refresh()` لا يغير ذاكرة التخزين المؤقت للبيانات والذاكرة الكاملة للمسار، لأنها واجهة برمجة تطبيقات على جانب العميل.

### واجهات برمجة التطبيقات الديناميكية

تعتمد واجهات برمجة التطبيقات الديناميكية مثل `cookies` و `headers`، وخاصية `searchParams` في الصفحات على معلومات الطلب الوارد أثناء التشغيل. يؤدي استخدامها إلى انسحاب المسار من ذاكرة التخزين المؤقت الكاملة للمسار، بمعنى آخر، سيتم تصيير المسار ديناميكيًا.

#### `cookies`

يؤدي استخدام `cookies.set` أو `cookies.delete` في إجراء خادم إلى إبطال ذاكرة التخزين المؤقت للموجه لمنع المسارات التي تستخدم ملفات تعريف الارتباط من أن تصبح قديمة (مثل عكس تغييرات المصادقة).

راجع [مرجع واجهة برمجة التطبيقات لـ `cookies`](/docs/app/api-reference/functions/cookies).

### خيارات تكوين القطاع (Segment Config Options)

يمكن استخدام خيارات تكوين قطاع المسار (Route Segment Config) لتجاوز الإعدادات الافتراضية لقطاع المسار أو عندما لا تتمكن من استخدام واجهة برمجة التطبيقات `fetch` (مثل عميل قاعدة البيانات أو مكتبات الطرف الثالث).

ستؤدي خيارات تكوين قطاع المسار التالية إلى إلغاء اختيار ذاكرة التخزين المؤقت الكاملة للمسار (Full Route Cache):

- `const dynamic = 'force-dynamic'`

سيؤدي خيار التكوين هذا إلى إلغاء اختيار جميع عمليات الجلب من ذاكرة التخزين المؤقت للبيانات (أي `no-store`):

- `const fetchCache = 'default-no-store'`

راجع [`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache) لمعرفة المزيد من الخيارات المتقدمة.

راجع وثائق [تكوين قطاع المسار](/docs/app/api-reference/file-conventions/route-segment-config) لمزيد من الخيارات.

### `generateStaticParams`

بالنسبة لـ [الأجزاء الديناميكية](/docs/app/api-reference/file-conventions/dynamic-routes) (مثل `app/blog/[slug]/page.js`)، يتم تخزين المسارات المقدمة من `generateStaticParams` في ذاكرة التخزين المؤقت الكاملة للمسار (Full Route Cache) أثناء وقت البناء. في وقت الطلب، سيخزن Next.js أيضًا المسارات التي لم تكن معروفة أثناء البناء عند زيارتها لأول مرة.

لتصيير جميع المسارات بشكل ثابت أثناء وقت البناء، قم بتوفير القائمة الكاملة للمسارات لـ `generateStaticParams`:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

لتصيير مجموعة فرعية من المسارات بشكل ثابت أثناء وقت البناء، والباقي عند زيارتها لأول مرة أثناء وقت التشغيل، قم بإرجاع قائمة جزئية من المسارات:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // تصيير أول 10 منشورات أثناء وقت البناء
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

لتصيير جميع المسارات بشكل ثابت عند زيارتها لأول مرة، قم بإرجاع مصفوفة فارغة (لن يتم تصيير أي مسارات أثناء وقت البناء) أو استخدم [`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic):

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **معلومة مفيدة:** يجب عليك إرجاع مصفوفة من `generateStaticParams`، حتى لو كانت فارغة. وإلا، سيتم تصيير المسار بشكل ديناميكي.

```jsx filename="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

لتعطيل التخزين المؤقت في وقت الطلب، أضف خيار `export const dynamicParams = false` في قطاع المسار. عند استخدام خيار التكوين هذا، سيتم تقديم المسارات المقدمة من `generateStaticParams` فقط، وسيؤدي المسارات الأخرى إلى خطأ 404 أو تطابق (في حالة [مسارات catch-all](/docs/app/api-reference/file-conventions/dynamic-routes#catch-all-segments)).

### دالة `cache` في React

تتيح لك دالة `cache` في React تخزين القيمة المرجعة للدالة مؤقتًا، مما يسمح لك باستدعاء نفس الدالة عدة مرات مع تنفيذها مرة واحدة فقط.

نظرًا لأن طلبات `fetch` يتم تخزينها مؤقتًا تلقائيًا، لا تحتاج إلى تغليفها في دالة `cache` في React. ومع ذلك، يمكنك استخدام `cache` لتخزين طلبات البيانات يدويًا للحالات التي لا تكون فيها واجهة برمجة التطبيقات `fetch` مناسبة. على سبيل المثال، بعض عملاء قواعد البيانات، أو عملاء نظام إدارة المحتوى (CMS)، أو عملاء GraphQL.

```ts filename="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

```js filename="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
