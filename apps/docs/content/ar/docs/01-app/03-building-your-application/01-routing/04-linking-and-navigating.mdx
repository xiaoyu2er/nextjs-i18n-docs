---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:12:10.880Z
title: الربط والتنقل
description: تعرف على كيفية عمل التنقل في Next.js، وكيفية استخدام مكون Link وربط `useRouter`.
related:
  links:
    - app/deep-dive/caching
    - app/api-reference/config/typescript
---

هناك أربع طرق للتنقل بين المسارات في Next.js:

- استخدام [مكون `<Link>`](#link-component)
- استخدام [ربط `useRouter`](#userouter-hook) ([مكونات العميل](/docs/app/getting-started/server-and-client-components))
- استخدام [دالة `redirect`](#redirect-function) ([مكونات الخادم](/docs/app/getting-started/server-and-client-components))
- استخدام [واجهة History الأصلية](#using-the-native-history-api)

ستغطي هذه الصفحة كيفية استخدام كل من هذه الخيارات، والتعمق في كيفية عمل التنقل.

## مكون `<Link>`

`<Link>` هو مكون مدمج يمتد علامة HTML `<a>` لتوفير [الجلب المسبق](#2-prefetching) والتنقل من جانب العميل بين المسارات. إنها الطريقة الأساسية والموصى بها للتنقل بين المسارات في Next.js.

يمكنك استخدامه عن طريق استيراده من `next/link`، وتمرير خاصية `href` إلى المكون:

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">لوحة التحكم</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">لوحة التحكم</Link>
}
```

هناك خصائص اختيارية أخرى يمكنك تمريرها إلى `<Link>`. راجع [مرجع API](/docs/app/api-reference/components/link) للمزيد.

## ربط `useRouter()`

يسمح لك ربط `useRouter` بتغيير المسارات برمجيًا من [مكونات العميل](/docs/app/getting-started/server-and-client-components).

```tsx filename="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      لوحة التحكم
    </button>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      لوحة التحكم
    </button>
  )
}
```

للحصول على قائمة كاملة بطرق `useRouter`، راجع [مرجع API](/docs/app/api-reference/functions/use-router).

> **التوصية:** استخدم مكون `<Link>` للتنقل بين المسارات ما لم يكن لديك متطلب محدد لاستخدام `useRouter`.

## دالة `redirect`

بالنسبة لـ [مكونات الخادم](/docs/app/getting-started/server-and-client-components)، استخدم دالة `redirect` بدلاً من ذلك.

```tsx filename="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

```jsx filename="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

> **معلومة مفيدة**:
>
> - تُرجع `redirect` رمز حالة 307 (إعادة توجيه مؤقت) افتراضيًا. عند استخدامها في إجراء خادم، تُرجع 303 (انظر آخر)، والذي يُستخدم عادةً لإعادة التوجيه إلى صفحة نجاح نتيجة لطلب POST.
> - تُطلق `redirect` خطأ داخليًا لذا يجب استدعاؤها خارج كتل `try/catch`.
> - يمكن استدعاء `redirect` في مكونات العميل أثناء عملية التصيير ولكن ليس في معالج الأحداث. يمكنك استخدام [ربط `useRouter`](#userouter-hook) بدلاً من ذلك.
> - تقبل `redirect` أيضًا عناوين URL المطلقة ويمكن استخدامها لإعادة التوجيه إلى روابط خارجية.
> - إذا كنت ترغب في إعادة التوجيه قبل عملية التصيير، استخدم [`next.config.js`](/docs/app/guides/redirecting#redirects-in-nextconfigjs) أو [الوسيط](/docs/app/guides/redirecting#nextresponseredirect-in-middleware).

راجع [مرجع API لـ `redirect`](/docs/app/api-reference/functions/redirect) للمزيد من المعلومات.

## استخدام واجهة History الأصلية

يسمح لك Next.js باستخدام الطرق الأصلية [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) و [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) لتحديث مكدس تاريخ المتصفح دون إعادة تحميل الصفحة.

تتكامل استدعاءات `pushState` و `replaceState` مع موجه Next.js، مما يسمح لك بالمزامنة مع [`usePathname`](/docs/app/api-reference/functions/use-pathname) و [`useSearchParams`](/docs/app/api-reference/functions/use-search-params).

### `window.history.pushState`

استخدمه لإضافة إدخال جديد إلى مكدس تاريخ المتصفح. يمكن للمستخدم التنقل للخلف إلى الحالة السابقة. على سبيل المثال، لفرز قائمة المنتجات:

```tsx fileName="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>فرز تصاعدي</button>
      <button onClick={() => updateSorting('desc')}>فرز تنازلي</button>
    </>
  )
}
```

```jsx fileName="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>فرز تصاعدي</button>
      <button onClick={() => updateSorting('desc')}>فرز تنازلي</button>
    </>
  )
}
```

### `window.history.replaceState`

استخدمه لاستبدال الإدخال الحالي في مكدس تاريخ المتصفح. لا يمكن للمستخدم التنقل للخلف إلى الحالة السابقة. على سبيل المثال، لتبديل لغة التطبيق:

```tsx fileName="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // مثال: '/en/about' أو '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>الإنجليزية</button>
      <button onClick={() => switchLocale('fr')}>الفرنسية</button>
    </>
  )
}
```

```jsx fileName="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // مثال: '/en/about' أو '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>الإنجليزية</button>
      <button onClick={() => switchLocale('fr')}>الفرنسية</button>
    </>
  )
}
```

## كيف يعمل التوجيه والتنقل

يستخدم موجه التطبيق نهجًا هجينًا للتوجيه والتنقل. على الخادم، يتم [تقسيم الكود](#1-code-splitting) تلقائيًا حسب مقاطع المسار. وعلى العميل، يقوم Next.js [بجلب مسبق](#2-prefetching) و[تخزين مؤقت](#3-caching) لمقاطع المسار. هذا يعني أنه عندما ينتقل المستخدم إلى مسار جديد، لا يعيد المتصفح تحميل الصفحة، ويعاد تصيير فقط مقاطع المسار التي تتغير - مما يحسن تجربة التنقل والأداء.

### 1. تقسيم الكود

يسمح لك تقسيم الكود بتقسيم كود التطبيق إلى حزم أصغر ليتم تنزيلها وتنفيذها بواسطة المتصفح. هذا يقلل من كمية البيانات المنقولة ووقت التنفيذ لكل طلب، مما يؤدي إلى تحسين الأداء.

تسمح لك [مكونات الخادم](/docs/app/getting-started/server-and-client-components) بتقسيم كود التطبيق تلقائيًا حسب مقاطع المسار. هذا يعني أنه يتم تحميل الكود المطلوب فقط للمسار الحالي عند التنقل.

### 2. الجلب المسبق

الجلب المسبق هو طريقة لتحميل مسار مسبقًا في الخلفية قبل أن يزوره المستخدم.

هناك طريقتان لجلب المسارات مسبقًا في Next.js:

- **مكون `<Link>`**: يتم جلب المسارات مسبقًا تلقائيًا عندما تصبح مرئية في نافذة عرض المستخدم. يحدث الجلب المسبق عند تحميل الصفحة لأول مرة أو عندما تظهر في العرض من خلال التمرير.
- **`router.prefetch()`**: يمكن استخدام ربط `useRouter` لجلب المسارات مسبقًا برمجيًا.

يختلف سلوك الجلب المسبق الافتراضي لـ `<Link>` (أي عندما تكون خاصية `prefetch` غير محددة أو مضبوطة على `null`) اعتمادًا على استخدامك لـ [`loading.js`](/docs/app/api-reference/file-conventions/loading). يتم جلب التخطيط المشترك فقط، أسفل "شجرة" المكونات المصيرية حتى ملف `loading.js` الأول، وتخزينه مؤقتًا لمدة `30s`. هذا يقلل من تكلفة جلب مسار ديناميكي كامل، ويعني أنه يمكنك عرض [حالة تحميل فورية](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) لردود فعل مرئية أفضل للمستخدمين.

يمكنك تعطيل الجلب المسبق عن طريق ضبط خاصية `prefetch` على `false`. بدلاً من ذلك، يمكنك جلب بيانات الصفحة الكاملة مسبقًا خارج حدود التحميل عن طريق ضبط خاصية `prefetch` على `true`.

راجع [مرجع API لـ `<Link>`](/docs/app/api-reference/components/link) للمزيد من المعلومات.

> **معلومة مفيدة**:
>
> - لا يتم تمكين الجلب المسبق في وضع التطوير، فقط في الإنتاج.

### 3. التخزين المؤقت

يحتوي Next.js على **تخزين مؤقت من جانب العميل في الذاكرة** يسمى [تخزين مؤقت للموجه](/docs/app/deep-dive/caching#client-side-router-cache). بينما يتنقل المستخدمون في التطبيق، يتم تخزين حمولة مكون خادم React لمقاطع المسار [المجموعة مسبقًا](#2-prefetching) والمسارات التي تمت زيارتها في التخزين المؤقت.

هذا يعني عند التنقل، يتم إعادة استخدام التخزين المؤقت قدر الإمكان، بدلاً من إجراء طلب جديد إلى الخادم - مما يحسن الأداء عن طريق تقليل عدد الطلبات والبيانات المنقولة.

تعرف على المزيد حول كيفية عمل [تخزين مؤقت للموجه](/docs/app/deep-dive/caching#client-side-router-cache) وكيفية تكوينه.

### 4. التصيير الجزئي

يعني التصيير الجزئي أنه يتم إعادة تصيير فقط مقاطع المسار التي تتغير عند التنقل على العميل، ويتم الحفاظ على أي مقاطع مشتركة.

على سبيل المثال، عند التنقل بين مسارين شقيقين، `/dashboard/settings` و `/dashboard/analytics`، سيتم إلغاء تحميل صفحة `settings`، وسيتم تحميل صفحة `analytics` بحالة جديدة، وسيتم الحفاظ على تخطيط `dashboard` المشترك. هذا السلوك موجود أيضًا بين مسارين على نفس المقطع الديناميكي مثل `/blog/[slug]/page` والتنقل من `/blog/first` إلى `/blog/second`.

<Image
  alt="كيف يعمل التصيير الجزئي"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

بدون التصيير الجزئي، سيؤدي كل تنقل إلى إعادة تصيير الصفحة الكاملة على العميل. يؤدي تصيير المقطع الذي يتغير فقط إلى تقليل كمية البيانات المنقولة ووقت التنفيذ، مما يؤدي إلى تحسين الأداء.

### 5. التنقل الناعم

يقوم المتصفحات بتنفيذ "تنقل صعب" عند التنقل بين الصفحات. يمكّن موجه تطبيق Next.js "التنقل الناعم" بين الصفحات، مما يضمن إعادة تصيير فقط مقاطع المسار التي تغيرت (تصيير جزئي). هذا يمكّن من الحفاظ على حالة React للعميل أثناء التنقل.

### 6. التنقل للخلف وللأمام

افتراضيًا، ستحافظ Next.js على موضع التمرير للتنقل للخلف وللأمام، وإعادة استخدام مقاطع المسار في [تخزين مؤقت للموجه](/docs/app/deep-dive/caching#client-side-router-cache).

### 7. التوجيه بين `pages/` و `app/`

عند الترحيل التدريجي من `pages/` إلى `app/`، سيتعامل موجه Next.js تلقائيًا مع التنقل الصلب بين الاثنين. للكشف عن الانتقالات من `pages/` إلى `app/`، هناك مرشح موجه عميل يستخدم التحقق الاحتمالي لمسارات التطبيق، مما قد يؤدي في بعض الأحيان إلى نتائج إيجابية خاطئة. افتراضيًا، يجب أن تكون مثل هذه الحالات نادرة جدًا، حيث نقوم بتكوين احتمالية النتيجة الإيجابية الخاطئة لتكون 0.01%. يمكن تخصيص هذه الاحتمالية عبر خيار `experimental.clientRouterFilterAllowedRate` في `next.config.js`. من المهم ملاحظة أن خفض معدل النتائج الإيجابية الخاطئة سيزيد من حجم المرشح الذي تم إنشاؤه في حزمة العميل.

بدلاً من ذلك، إذا كنت تفضل تعطيل هذه المعالجة تمامًا وإدارة التوجيه بين `pages/` و `app/` يدويًا، يمكنك ضبط `experimental.clientRouterFilter` على false في `next.config.js`. عند تعطيل هذه الميزة، لن يتم التنقل بشكل صحيح افتراضيًا إلى أي مسارات ديناميكية في الصفحات التي تتداخل مع مسارات التطبيق.