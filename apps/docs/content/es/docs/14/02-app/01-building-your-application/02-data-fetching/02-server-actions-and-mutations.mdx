---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:05:41.882Z
title: Acciones de servidor (Server Actions) y mutaciones
nav_title: Acciones de servidor y mutaciones
description: Aprende a manejar env√≠os de formularios y mutaciones de datos con Next.js.
related:
  description: Aprende a configurar Acciones de Servidor en Next.js
  links:
    - app/api-reference/next-config-js/serverActions
---

Las Acciones de Servidor (Server Actions) son **funciones as√≠ncronas** que se ejecutan en el servidor. Pueden usarse en Componentes de Servidor y Cliente para manejar env√≠os de formularios y mutaciones de datos en aplicaciones Next.js.

> **üé• Ver:** Aprende m√°s sobre formularios y mutaciones con Acciones de Servidor ‚Üí [YouTube (10 minutos)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## Convenci√≥n

Una Acci√≥n de Servidor puede definirse con la directiva [`"use server"`](https://react.dev/reference/react/use-server) de React. Puedes colocar la directiva al inicio de una funci√≥n `async` para marcarla como Acci√≥n de Servidor, o al inicio de un archivo separado para marcar todas sus exportaciones como Acciones de Servidor.

### Componentes de Servidor

Los Componentes de Servidor pueden usar la directiva `"use server"` a nivel de funci√≥n o m√≥dulo. Para definir una Acci√≥n de Servidor inline, agrega `"use server"` al inicio del cuerpo de la funci√≥n:

```tsx filename="app/page.tsx" switcher
// Componente de Servidor
export default function Page() {
  // Acci√≥n de Servidor
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

```jsx filename="app/page.jsx" switcher
// Componente de Servidor
export default function Page() {
  // Acci√≥n de Servidor
  async function create() {
    'use server'

    // ...
  }

  return (
    // ...
  )
}
```

### Componentes de Cliente

Los Componentes de Cliente solo pueden importar acciones que usen la directiva `"use server"` a nivel de m√≥dulo.

Para llamar una Acci√≥n de Servidor en un Componente de Cliente, crea un nuevo archivo y agrega la directiva `"use server"` al inicio. Todas las funciones dentro del archivo ser√°n marcadas como Acciones de Servidor que pueden reutilizarse en Componentes de Cliente y Servidor:

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {
  // ...
}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {
  // ...
}
```

```tsx filename="app/ui/button.tsx" switcher
import { create } from '@/app/actions'

export function Button() {
  return (
    // ...
  )
}
```

```jsx filename="app/ui/button.js" switcher
import { create } from '@/app/actions'

export function Button() {
  return (
    // ...
  )
}
```

Tambi√©n puedes pasar una Acci√≥n de Servidor a un Componente de Cliente como prop:

```jsx
<ClientComponent updateItem={updateItem} />
```

```jsx filename="app/client-component.jsx"
'use client'

export default function ClientComponent({ updateItem }) {
  return <form action={updateItem}>{/* ... */}</form>
}
```

## Comportamiento

- Las Acciones de Servidor pueden invocarse usando el atributo `action` en un elemento [`<form>`](#formularios):
  - Los Componentes de Servidor soportan mejora progresiva por defecto, lo que significa que el formulario se enviar√° incluso si JavaScript no se ha cargado o est√° deshabilitado.
  - En Componentes de Cliente, los formularios que invocan Acciones de Servidor encolar√°n los env√≠os si JavaScript no est√° cargado a√∫n, priorizando la hidrataci√≥n del cliente.
  - Despu√©s de la hidrataci√≥n, el navegador no se recarga al enviar el formulario.
- Las Acciones de Servidor no est√°n limitadas a `<form>` y pueden invocarse desde manejadores de eventos, `useEffect`, bibliotecas de terceros y otros elementos como `<button>`.
- Las Acciones de Servidor se integran con la arquitectura de [cach√© y revalidaci√≥n](/docs/app/building-your-application/caching) de Next.js. Cuando se invoca una acci√≥n, Next.js puede devolver tanto la UI actualizada como nuevos datos en un solo viaje al servidor.
- Internamente, las acciones usan el m√©todo `POST`, y solo este m√©todo HTTP puede invocarlas.
- Los argumentos y valores de retorno de las Acciones de Servidor deben ser serializables por React. Consulta la documentaci√≥n de React para ver una lista de [argumentos y valores serializables](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values).
- Las Acciones de Servidor son funciones. Esto significa que pueden reutilizarse en cualquier parte de tu aplicaci√≥n.
- Las Acciones de Servidor heredan el [entorno de ejecuci√≥n](/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes) de la p√°gina o layout donde se usan.
- Las Acciones de Servidor heredan la [Configuraci√≥n del Segmento de Ruta](/docs/app/api-reference/file-conventions/route-segment-config) de la p√°gina o layout donde se usan, incluyendo campos como `maxDuration`.

## Ejemplos

### Formularios

React extiende el elemento HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) para permitir invocar Acciones de Servidor con la prop `action`.

Cuando se invoca en un formulario, la acci√≥n recibe autom√°ticamente el objeto [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData). No necesitas usar `useState` de React para manejar campos, en su lugar puedes extraer los datos usando los [m√©todos nativos de `FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods):

```tsx filename="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // mutar datos
    // revalidar cach√©
  }

  return <form action={createInvoice}>...</form>
}
```

```jsx filename="app/invoices/page.jsx" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // mutar datos
    // revalidar cach√©
  }

  return <form action={createInvoice}>...</form>
}
```

> **Nota importante:**
>
> - Ejemplo: [Formulario con Estados de Carga y Error](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - Al trabajar con formularios que tienen muchos campos, puedes considerar usar el m√©todo [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) con [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) de JavaScript. Por ejemplo: `const rawFormData = Object.fromEntries(formData)`. Ten en cuenta que el `formData` incluir√° propiedades adicionales `$ACTION_`.
> - Consulta la documentaci√≥n de [React `<form>`](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action) para aprender m√°s.

#### Pasando argumentos adicionales

Puedes pasar argumentos adicionales a una Acci√≥n de Servidor usando el m√©todo `bind` de JavaScript.

```tsx filename="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Actualizar Nombre</button>
    </form>
  )
}
```

```jsx filename="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Actualizar Nombre</button>
    </form>
  )
}
```

La Acci√≥n de Servidor recibir√° el argumento `userId`, adem√°s de los datos del formulario:

```js filename="app/actions.js"
'use server'

export async function updateUser(userId, formData) {
  // ...
}
```

> **Nota importante:**
>
> - Una alternativa es pasar argumentos como campos ocultos en el formulario (ej. `<input type="hidden" name="userId" value={userId} />`). Sin embargo, el valor ser√° parte del HTML renderizado y no estar√° codificado.
> - `.bind` funciona tanto en Componentes de Servidor como de Cliente. Tambi√©n soporta mejora progresiva.

#### Estados pendientes

Puedes usar el hook [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) de React para mostrar un estado pendiente mientras se env√≠a el formulario.

- `useFormStatus` devuelve el estado para un `<form>` espec√≠fico, por lo que **debe definirse como hijo del elemento `<form>`**.
- `useFormStatus` es un hook de React y por lo tanto debe usarse en un Componente de Cliente.

```tsx filename="app/submit-button.tsx" switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" disabled={pending}>
      Agregar
    </button>
  )
}
```

```jsx filename="app/submit-button.jsx" switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button type="submit" disabled={pending}>
      Agregar
    </button>
  )
}
```

`<SubmitButton />` puede luego anidarse en cualquier formulario:

```tsx filename="app/page.tsx" switcher
import { SubmitButton } from '@/app/submit-button'
import { createItem } from '@/app/actions'

// Componente de Servidor
export default async function Home() {
  return (
    <form action={createItem}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

```jsx filename="app/page.jsx" switcher
import { SubmitButton } from '@/app/submit-button'
import { createItem } from '@/app/actions'

// Componente de Servidor
export default async function Home() {
  return (
    <form action={createItem}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

#### Validaci√≥n en servidor y manejo de errores

Recomendamos usar validaci√≥n HTML como `required` y `type="email"` para validaci√≥n b√°sica en cliente.

Para validaci√≥n m√°s avanzada en servidor, puedes usar una biblioteca como [zod](https://zod.dev/) para validar los campos del formulario antes de mutar los datos:

```tsx filename="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Email inv√°lido',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // Retornar temprano si los datos son inv√°lidos
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Mutar datos
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: 'Email inv√°lido',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // Retornar temprano si los datos son inv√°lidos
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Mutar datos
}
```

Una vez validados los campos en el servidor, puedes retornar un objeto serializable en tu acci√≥n y usar el hook [`useFormState`](https://react.dev/reference/react-dom/hooks/useFormState) de React para mostrar un mensaje al usuario.

- Al pasar la acci√≥n a `useFormState`, la firma de la funci√≥n cambia para recibir un nuevo par√°metro `prevState` o `initialState` como primer argumento.
- `useFormState` es un hook de React y por lo tanto debe usarse en un Componente de Cliente.

```tsx filename="app/actions.ts" switcher
'use server'

export async function createUser(prevState: any, formData: FormData) {
  // ...
  return {
    message: 'Por favor ingresa un email v√°lido',
  }
}
```

```jsx filename="app/actions.js" switcher
'use server'

export async function createUser(prevState, formData) {
  // ...
  return {
    message: 'Por favor ingresa un email v√°lido',
  }
}
```

Luego, puedes pasar tu acci√≥n al hook `useFormState` y usar el `state` devuelto para mostrar un mensaje de error.

```tsx filename="app/ui/signup.tsx" switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
      <button>Registrarse</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" switcher
'use client'

import { useFormState } from 'react-dom'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction] = useFormState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
      <button>Registrarse</button>
    </form>
  )
}
```

> **Nota importante:**
>
> - Antes de mutar datos, siempre debes asegurarte de que el usuario est√© autorizado para realizar la acci√≥n. Ver [Autenticaci√≥n y Autorizaci√≥n](#autenticaci√≥n-y-autorizaci√≥n).

#### Actualizaciones optimistas

Puedes usar el hook [`useOptimistic`](https://react.dev/reference/react/useOptimistic) de React para actualizar la UI de manera optimista antes de que la Acci√≥n de Servidor termine, en lugar de esperar la respuesta:

```tsx filename="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  return (
    <div>
      {optimisticMessages.map((m, k) => (
        <div key={k}>{m.message}</div>
      ))}
      <form
        action={async (formData: FormData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Enviar</button>
      </form>
    </div>
  )
}
```

```jsx filename="app/page.jsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form
        action={async (formData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Enviar</button>
      </form>
    </div>
  )
}
```

#### Elementos anidados

Puedes invocar una Acci√≥n de Servidor en elementos anidados dentro de `<form>` como `<button>`, `<input type="submit">` y `<input type="image">`. Estos elementos aceptan la prop `formAction` o [manejadores de eventos](#manejadores-de-eventos).

Esto es √∫til cuando quieres llamar m√∫ltiples acciones de servidor dentro de un formulario. Por ejemplo, puedes crear un elemento `<button>` espec√≠fico para guardar un borrador de publicaci√≥n adem√°s de publicarlo. Consulta la documentaci√≥n de [React `<form>`](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types) para m√°s informaci√≥n.

#### Env√≠o program√°tico de formularios

Puede activar el env√≠o de un formulario utilizando el m√©todo [`requestSubmit()`](https://developer.mozilla.org/es/docs/Web/API/HTMLFormElement/requestSubmit). Por ejemplo, cuando el usuario presiona `‚åò` + `Enter`, puede escuchar el evento `onKeyDown`:

```tsx filename="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

```jsx filename="app/entry.jsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

Esto activar√° el env√≠o del ancestro `<form>` m√°s cercano, lo que invocar√° la Acci√≥n del Servidor (Server Action).

### Elementos que no son formularios

Aunque es com√∫n usar Acciones del Servidor dentro de elementos `<form>`, tambi√©n se pueden invocar desde otras partes de su c√≥digo, como manejadores de eventos y `useEffect`.

#### Manejadores de eventos

Puede invocar una Acci√≥n del Servidor desde manejadores de eventos como `onClick`. Por ejemplo, para incrementar un contador de "me gusta":

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total de "Me gusta": {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Me gusta
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total de "Me gusta": {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Me gusta
      </button>
    </>
  )
}
```

Para mejorar la experiencia del usuario, recomendamos usar otras APIs de React como [`useOptimistic`](https://react.dev/reference/react/useOptimistic) y [`useTransition`](https://react.dev/reference/react/useTransition) para actualizar la interfaz de usuario antes de que la Acci√≥n del Servidor termine de ejecutarse en el servidor, o para mostrar un estado de carga.

Tambi√©n puede agregar manejadores de eventos a elementos de formulario, por ejemplo, para guardar un campo de formulario `onChange`:

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publicar</button>
    </form>
  )
}
```

Para casos como este, donde se pueden activar m√∫ltiples eventos en r√°pida sucesi√≥n, recomendamos **debouncing** para evitar invocaciones innecesarias de Acciones del Servidor.

#### `useEffect`

Puede usar el hook de React [`useEffect`](https://react.dev/reference/react/useEffect) para invocar una Acci√≥n del Servidor cuando el componente se monta o cambia una dependencia. Esto es √∫til para mutaciones que dependen de eventos globales o que necesitan activarse autom√°ticamente. Por ejemplo, `onKeyDown` para atajos de teclado, un hook de observador de intersecci√≥n para scroll infinito, o cuando el componente se monta para actualizar un contador de visitas:

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total de visitas: {views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)

  useEffect(() => {
    const updateViews = async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    }

    updateViews()
  }, [])

  return <p>Total de visitas: {views}</p>
}
```

Recuerde considerar el [comportamiento y advertencias](https://react.dev/reference/react/useEffect#caveats) de `useEffect`.

### Manejo de errores

Cuando se lanza un error, ser√° capturado por el l√≠mite [`error.js`](/docs/app/building-your-application/routing/error-handling) m√°s cercano o `<Suspense>` en el cliente. Recomendamos usar `try/catch` para devolver errores que puedan ser manejados por su interfaz de usuario.

Por ejemplo, su Acci√≥n del Servidor podr√≠a manejar errores al crear un nuevo elemento devolviendo un mensaje:

```ts filename="app/actions.ts" switcher
'use server'

export async function createTodo(prevState: any, formData: FormData) {
  try {
    // Mutar datos
  } catch (e) {
    throw new Error('Error al crear la tarea')
  }
}
```

```js filename="app/actions.js" switcher
'use server'

export async function createTodo(prevState, formData) {
  try {
    // Mutar datos
  } catch (e) {
    throw new Error('Error al crear la tarea')
  }
}
```

> **Nota importante:**
>
> - Adem√°s de lanzar el error, tambi√©n puede devolver un objeto para ser manejado por `useFormState`. Consulte [Validaci√≥n y manejo de errores en el servidor](#server-side-validation-and-error-handling).

### Revalidaci√≥n de datos

Puede revalidar la [Cach√© de Next.js](/docs/app/building-your-application/caching) dentro de sus Acciones del Servidor con la API [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath):

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

O invalidar una obtenci√≥n de datos espec√≠fica con una etiqueta de cach√© usando [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag):

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### Redireccionamiento

Si desea redirigir al usuario a una ruta diferente despu√©s de completar una Acci√≥n del Servidor, puede usar la API [`redirect`](/docs/app/api-reference/functions/redirect). `redirect` debe llamarse fuera del bloque `try/catch`:

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Actualizar posts en cach√©
  redirect(`/post/${id}`) // Navegar a la p√°gina del nuevo post
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Actualizar posts en cach√©
  redirect(`/post/${id}`) // Navegar a la p√°gina del nuevo post
}
```

### Cookies

Puede `obtener`, `establecer` y `eliminar` cookies dentro de una Acci√≥n del Servidor usando la API [`cookies`](/docs/app/api-reference/functions/cookies):

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Obtener cookie
  const value = cookies().get('name')?.value

  // Establecer cookie
  cookies().set('name', 'Delba')

  // Eliminar cookie
  cookies().delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Obtener cookie
  const value = cookies().get('name')?.value

  // Establecer cookie
  cookies().set('name', 'Delba')

  // Eliminar cookie
  cookies().delete('name')
}
```

Consulte [ejemplos adicionales](/docs/app/api-reference/functions/cookies#deleting-cookies) para eliminar cookies desde Acciones del Servidor.

## Seguridad

### Autenticaci√≥n y autorizaci√≥n

Debe tratar las Acciones del Servidor como lo har√≠a con puntos finales de API p√∫blicos y asegurarse de que el usuario est√© autorizado para realizar la acci√≥n. Por ejemplo:

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('Debes iniciar sesi√≥n para realizar esta acci√≥n')
  }

  // ...
}
```

### Cierres y encriptaci√≥n

Definir una Acci√≥n del Servidor dentro de un componente crea un [cierre](https://developer.mozilla.org/es/docs/Web/JavaScript/Closures) donde la acci√≥n tiene acceso al alcance de la funci√≥n externa. Por ejemplo, la acci√≥n `publish` tiene acceso a la variable `publishVersion`:

```tsx filename="app/page.tsx" switcher
export default function Page() {
  const publishVersion = await getLatestVersion();

  async function publish(formData: FormData) {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('La versi√≥n ha cambiado desde que se presion√≥ publicar');
    }
    ...
  }

  return <button action={publish}>Publicar</button>;
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('La versi√≥n ha cambiado desde que se presion√≥ publicar');
    }
    ...
  }

  return <button action={publish}>Publicar</button>;
}
```

Los cierres son √∫tiles cuando necesita capturar una _instant√°nea_ de datos (por ejemplo, `publishVersion`) en el momento de la representaci√≥n para que pueda usarse m√°s tarde cuando se invoque la acci√≥n.

Sin embargo, para que esto suceda, las variables capturadas se env√≠an al cliente y de vuelta al servidor cuando se invoca la acci√≥n. Para evitar que los datos sensibles se expongan al cliente, Next.js encripta autom√°ticamente las variables cerradas. Se genera una nueva clave privada para cada acci√≥n cada vez que se construye una aplicaci√≥n Next.js. Esto significa que las acciones solo se pueden invocar para una compilaci√≥n espec√≠fica.

> **Nota importante:** No recomendamos confiar √∫nicamente en la encriptaci√≥n para evitar que los valores sensibles se expongan en el cliente. En su lugar, debe usar las [APIs de taint de React](/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client) para evitar proactivamente que datos espec√≠ficos se env√≠en al cliente.

### Sobrescribir claves de encriptaci√≥n (avanzado)

Cuando aloja su aplicaci√≥n Next.js en m√∫ltiples servidores, cada instancia del servidor puede terminar con una clave de encriptaci√≥n diferente, lo que puede llevar a inconsistencias.

Para mitigar esto, puede sobrescribir la clave de encriptaci√≥n usando la variable de entorno `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY`. Especificar esta variable asegura que sus claves de encriptaci√≥n sean persistentes entre compilaciones y que todas las instancias del servidor usen la misma clave.

Este es un caso de uso avanzado donde el comportamiento de encriptaci√≥n consistente en m√∫ltiples implementaciones es cr√≠tico para su aplicaci√≥n. Debe considerar pr√°cticas de seguridad est√°ndar como la rotaci√≥n de claves y la firma.

> **Nota importante:** Las aplicaciones Next.js implementadas en Vercel manejan esto autom√°ticamente.

### Or√≠genes permitidos (avanzado)

Dado que las Acciones del Servidor se pueden invocar en un elemento `<form>`, esto las expone a [ataques CSRF](https://developer.mozilla.org/es/docs/Glossary/CSRF).

Internamente, las Acciones del Servidor usan el m√©todo `POST`, y solo se permite este m√©todo HTTP para invocarlas. Esto evita la mayor√≠a de las vulnerabilidades CSRF en navegadores modernos, especialmente con las [cookies SameSite](https://web.dev/articles/samesite-cookies-explained) siendo el valor predeterminado.

Como protecci√≥n adicional, las Acciones del Servidor en Next.js tambi√©n comparan la [cabecera Origin](https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Origin) con la [cabecera Host](https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Host) (o `X-Forwarded-Host`). Si no coinciden, la solicitud se abortar√°. En otras palabras, las Acciones del Servidor solo se pueden invocar en el mismo host que la p√°gina que las aloja.

Para aplicaciones grandes que usan proxies inversos o arquitecturas de backend multicapa (donde la API del servidor difiere del dominio de producci√≥n), se recomienda usar la opci√≥n de configuraci√≥n [`serverActions.allowedOrigins`](/docs/app/api-reference/next-config-js/serverActions) para especificar una lista de or√≠genes seguros. La opci√≥n acepta un array de strings.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

Aprenda m√°s sobre [Seguridad y Acciones del Servidor](https://nextjs.org/blog/security-nextjs-server-components-actions).

## Recursos adicionales

Para m√°s informaci√≥n sobre Acciones del Servidor, consulte los siguientes documentos de React:

- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useFormState`](https://react.dev/reference/react-dom/hooks/useFormState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
