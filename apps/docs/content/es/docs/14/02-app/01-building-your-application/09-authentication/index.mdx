---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T16:58:10.891Z
title: Autenticaci√≥n
description: Aprenda c√≥mo implementar autenticaci√≥n en Next.js, cubriendo mejores pr√°cticas, protecci√≥n de rutas, t√©cnicas de autorizaci√≥n y gesti√≥n de sesiones.
---

Para implementar autenticaci√≥n en Next.js, familiar√≠cese con tres conceptos fundamentales:

- **[Autenticaci√≥n](#autenticaci√≥n)** verifica si el usuario es quien dice ser. Requiere que el usuario demuestre su identidad con algo que posee, como un nombre de usuario y contrase√±a.
- **[Gesti√≥n de sesiones](#gesti√≥n-de-sesiones)** rastrea el estado del usuario (ej. conectado) a trav√©s de m√∫ltiples solicitudes.
- **[Autorizaci√≥n](#autorizaci√≥n)** decide qu√© partes de la aplicaci√≥n puede acceder el usuario.

Esta p√°gina demuestra c√≥mo usar las caracter√≠sticas de Next.js para implementar patrones comunes de autenticaci√≥n, autorizaci√≥n y gesti√≥n de sesiones, permiti√©ndole elegir las mejores soluciones seg√∫n las necesidades de su aplicaci√≥n.

## Autenticaci√≥n

La autenticaci√≥n verifica la identidad de un usuario. Esto ocurre cuando un usuario inicia sesi√≥n, ya sea con un nombre de usuario y contrase√±a o a trav√©s de un servicio como Google. Se trata de confirmar que los usuarios son realmente quienes dicen ser, protegiendo tanto los datos del usuario como la aplicaci√≥n de accesos no autorizados o actividades fraudulentas.

### Estrategias de autenticaci√≥n

Las aplicaciones web modernas com√∫nmente utilizan varias estrategias de autenticaci√≥n:

1. **OAuth/OpenID Connect (OIDC)**: Permiten acceso de terceros sin compartir credenciales de usuario. Ideales para inicios de sesi√≥n en redes sociales y soluciones de Single Sign-On (SSO). A√±aden una capa de identidad con OpenID Connect.
2. **Inicio de sesi√≥n basado en credenciales (Email + Contrase√±a)**: Una opci√≥n est√°ndar para aplicaciones web, donde los usuarios inician sesi√≥n con un correo electr√≥nico y contrase√±a. Familiar y f√°cil de implementar, requiere medidas de seguridad robustas contra amenazas como phishing.
3. **Autenticaci√≥n sin contrase√±a/basada en tokens**: Utiliza enlaces m√°gicos por correo electr√≥nico o c√≥digos de un solo uso por SMS para un acceso seguro sin contrase√±a. Popular por su conveniencia y mayor seguridad, este m√©todo ayuda a reducir la fatiga de contrase√±as. Su limitaci√≥n es la dependencia de la disponibilidad del correo electr√≥nico o tel√©fono del usuario.
4. **Passkeys/WebAuthn**: Utiliza credenciales criptogr√°ficas √∫nicas para cada sitio, ofreciendo alta seguridad contra phishing. Segura pero nueva, esta estratega puede ser dif√≠cil de implementar.

La selecci√≥n de una estrategia de autenticaci√≥n debe alinearse con los requisitos espec√≠ficos de su aplicaci√≥n, consideraciones de interfaz de usuario y objetivos de seguridad.

### Implementaci√≥n de autenticaci√≥n

En esta secci√≥n, exploraremos el proceso de agregar autenticaci√≥n b√°sica con correo electr√≥nico y contrase√±a a una aplicaci√≥n web. Si bien este m√©todo proporciona un nivel fundamental de seguridad, vale la pena considerar opciones m√°s avanzadas como OAuth o inicios de sesi√≥n sin contrase√±a para una mayor protecci√≥n contra amenazas de seguridad comunes. El flujo de autenticaci√≥n que discutiremos es el siguiente:

<PagesOnly>

1. El usuario env√≠a sus credenciales a trav√©s de un formulario de inicio de sesi√≥n.
2. El formulario env√≠a una solicitud que es manejada por una ruta de API.
3. Tras una verificaci√≥n exitosa, el proceso se completa, indicando la autenticaci√≥n exitosa del usuario.
4. Si la verificaci√≥n falla, se muestra un mensaje de error.

Considere un formulario de inicio de sesi√≥n donde los usuarios pueden ingresar sus credenciales:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

El formulario anterior tiene dos campos de entrada para capturar el correo electr√≥nico y la contrase√±a del usuario. Al enviarlo, activa una funci√≥n que env√≠a una solicitud POST a una ruta de API (`/api/auth/login`).

Luego puede llamar a la API de su Proveedor de Autenticaci√≥n en la ruta de API para manejar la autenticaci√≥n:

```ts filename="pages/api/auth/login.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inv√°lidas.' })
    } else {
      res.status(500).json({ error: 'Algo sali√≥ mal.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inv√°lidas.' })
    } else {
      res.status(500).json({ error: 'Algo sali√≥ mal.' })
    }
  }
}
```

</PagesOnly>

<AppOnly>

1. El usuario env√≠a sus credenciales a trav√©s de un formulario de inicio de sesi√≥n.
2. El formulario llama a una Acci√≥n de Servidor.
3. Tras una verificaci√≥n exitosa, el proceso se completa, indicando la autenticaci√≥n exitosa del usuario.
4. Si la verificaci√≥n falla, se muestra un mensaje de error.

Considere un formulario de inicio de sesi√≥n donde los usuarios pueden ingresar sus credenciales:

```tsx filename="app/login/page.tsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

El formulario anterior tiene dos campos de entrada para capturar el correo electr√≥nico y la contrase√±a del usuario. Al enviarlo, llama a la Acci√≥n de Servidor `authenticate`.

Luego puede llamar a la API de su Proveedor de Autenticaci√≥n en la Acci√≥n de Servidor para manejar la autenticaci√≥n:

```ts filename="app/lib/actions.ts" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState: unknown, formData: FormData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Credenciales inv√°lidas.'
        default:
          return 'Algo sali√≥ mal.'
      }
    }
    throw error
  }
}
```

```js filename="app/lib/actions.js" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState, formData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Credenciales inv√°lidas.'
        default:
          return 'Algo sali√≥ mal.'
      }
    }
    throw error
  }
}
```

</AppOnly>

En este c√≥digo, el m√©todo `signIn` verifica las credenciales contra los datos de usuario almacenados.
Despu√©s de que el proveedor de autenticaci√≥n procesa las credenciales, hay dos resultados posibles:

- **Autenticaci√≥n exitosa**: Este resultado implica que el inicio de sesi√≥n fue exitoso. Luego se pueden iniciar acciones adicionales, como acceder a rutas protegidas y obtener informaci√≥n del usuario.
- **Autenticaci√≥n fallida**: En casos donde las credenciales son incorrectas o se encuentra un error, la funci√≥n devuelve un mensaje de error correspondiente para indicar el fallo de autenticaci√≥n.

<AppOnly>

Finalmente, en su componente `login-form.tsx`, puede usar `useFormState` de React para llamar a la Acci√≥n de Servidor y manejar errores del formulario, y usar `useFormStatus` para manejar el estado pendiente del formulario:

```tsx filename="app/login/page.tsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Iniciar sesi√≥n
    </button>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Iniciar sesi√≥n
    </button>
  )
}
```

</AppOnly>

Para una configuraci√≥n de autenticaci√≥n m√°s optimizada en proyectos Next.js, especialmente cuando se ofrecen m√∫ltiples m√©todos de inicio de sesi√≥n, considere usar una [soluci√≥n de autenticaci√≥n](#ejemplos).

## Autorizaci√≥n

Una vez que un usuario est√° autenticado, deber√° asegurarse de que el usuario tenga permiso para visitar ciertas rutas y realizar operaciones como mutar datos con Acciones de Servidor y llamar a Manejadores de Ruta.

### Protecci√≥n de rutas con Middleware

[Middleware](/docs/app/building-your-application/routing/middleware) en Next.js le ayuda a controlar qui√©n puede acceder a diferentes partes de su sitio web. Esto es importante para mantener √°reas como el panel de usuario protegidas mientras que otras p√°ginas como las de marketing sean p√∫blicas. Se recomienda aplicar Middleware en todas las rutas y especificar exclusiones para acceso p√∫blico.

As√≠ es como puede implementar Middleware para autenticaci√≥n en Next.js:

#### Configuraci√≥n de Middleware:

- Cree un archivo `middleware.ts` o `.js` en el directorio ra√≠z de su proyecto.
- Incluya l√≥gica para autorizar el acceso de usuarios, como verificar tokens de autenticaci√≥n.

#### Definici√≥n de rutas protegidas:

- No todas las rutas requieren autorizaci√≥n. Use la opci√≥n `matcher` en su Middleware para especificar las rutas que no requieren verificaciones de autorizaci√≥n.

#### L√≥gica de Middleware:

- Escriba l√≥gica para verificar si un usuario est√° autenticado. Verifique roles o permisos de usuario para autorizaci√≥n de rutas.

#### Manejo de acceso no autorizado:

- Redirija usuarios no autorizados a una p√°gina de inicio de sesi√≥n o error seg√∫n corresponda.

Ejemplo de archivo Middleware:

```ts filename="middleware.ts" switcher
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
export function middleware(request) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Este ejemplo utiliza [`Response.redirect`](https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect_static) para manejar redirecciones temprano en el pipeline de solicitudes, haci√©ndolo eficiente y centralizando el control de acceso.

<AppOnly>

Para necesidades espec√≠ficas de redirecci√≥n, la funci√≥n `redirect` puede usarse en Componentes de Servidor, Manejadores de Ruta y Acciones de Servidor para proporcionar m√°s control. Esto es √∫til para navegaci√≥n basada en roles o escenarios sensibles al contexto.

```ts filename="app/page.tsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // L√≥gica para determinar si se necesita una redirecci√≥n
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // Defina otras rutas y l√≥gica
}
```

```js filename="app/page.jsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // L√≥gica para determinar si se necesita una redirecci√≥n
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // Defina otras rutas y l√≥gica
}
```

</AppOnly>

Despu√©s de una autenticaci√≥n exitosa, es importante gestionar la navegaci√≥n del usuario seg√∫n sus roles. Por ejemplo, un usuario administrador podr√≠a ser redirigido a un panel de administraci√≥n, mientras que un usuario regular es enviado a una p√°gina diferente. Esto es importante para experiencias espec√≠ficas por rol y navegaci√≥n condicional, como solicitar a los usuarios que completen su perfil si es necesario.

Al configurar la autorizaci√≥n, es importante asegurarse de que las principales verificaciones de seguridad ocurran donde su aplicaci√≥n accede o cambia datos. Si bien Middleware puede ser √∫til para la validaci√≥n inicial, no debe ser la √∫nica l√≠nea de defensa para proteger sus datos. La mayor parte de las verificaciones de seguridad deben realizarse en la Capa de Acceso a Datos (DAL).

<PagesOnly>

### Protecci√≥n de Rutas de API

Las Rutas de API en Next.js son esenciales para manejar l√≥gica del lado del servidor y gesti√≥n de datos. Es crucial proteger estas rutas para garantizar que solo usuarios autorizados puedan acceder a funcionalidades espec√≠ficas. Esto generalmente implica verificar el estado de autenticaci√≥n del usuario y sus permisos basados en roles.

Aqu√≠ hay un ejemplo de c√≥mo proteger una Ruta de API:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Verificar si el usuario est√° autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no est√° autenticado',
    })
    return
  }

  // Verificar si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Continuar con la ruta para usuarios autorizados
  // ... implementaci√≥n de la Ruta de API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Verificar si el usuario est√° autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no est√° autenticado',
    })
    return
  }

  // Verificar si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Continuar con la ruta para usuarios autorizados
  // ... implementaci√≥n de la Ruta de API
}
```

Este ejemplo demuestra una Ruta de API con una verificaci√≥n de seguridad de dos niveles para autenticaci√≥n y autorizaci√≥n. Primero verifica si hay una sesi√≥n activa y luego confirma si el usuario que inici√≥ sesi√≥n es un 'admin'. Este enfoque garantiza un acceso seguro, limitado a usuarios autenticados y autorizados, manteniendo una seguridad robusta para el procesamiento de solicitudes.

</PagesOnly>

<AppOnly>

Este enfoque, destacado en [este blog de seguridad](/blog/security-nextjs-server-components-actions), aboga por consolidar todo el acceso a datos dentro de una Capa de Acceso a Datos (DAL) dedicada. Esta estrategia asegura un acceso consistente a los datos, minimiza errores de autorizaci√≥n y simplifica el mantenimiento. Para garantizar una seguridad integral, considere las siguientes √°reas clave:

- Acciones del Servidor (Server Actions): Implemente verificaciones de seguridad en procesos del lado del servidor, especialmente para operaciones sensibles.
- Manejadores de Ruta (Route Handlers): Gestione solicitudes entrantes con medidas de seguridad para limitar el acceso solo a usuarios autorizados.
- Capa de Acceso a Datos (DAL): Interact√∫a directamente con la base de datos y es crucial para validar y autorizar transacciones de datos. Es vital realizar verificaciones cr√≠ticas dentro de la DAL para proteger los datos en su punto de interacci√≥n m√°s crucial‚Äîacceso o modificaci√≥n.

Para una gu√≠a detallada sobre c√≥mo proteger la DAL, incluyendo fragmentos de c√≥digo de ejemplo y pr√°cticas avanzadas de seguridad, consulte nuestra [secci√≥n de Capa de Acceso a Datos](/blog/security-nextjs-server-components-actions#data-access-layer) en la gu√≠a de seguridad.

### Protecci√≥n de Acciones del Servidor

Es importante tratar las [Acciones del Servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) con las mismas consideraciones de seguridad que los puntos finales de API p√∫blicos. Verificar la autorizaci√≥n del usuario para cada acci√≥n es crucial. Implemente verificaciones dentro de las Acciones del Servidor para determinar los permisos del usuario, como restringir ciertas acciones a usuarios administradores.

En el siguiente ejemplo, verificamos el rol del usuario antes de permitir que la acci√≥n contin√∫e:

```ts filename="app/lib/actions.ts" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // Verificar si el usuario est√° autorizado para realizar la acci√≥n
  if (userRole !== 'admin') {
    throw new Error('Acceso no autorizado: El usuario no tiene privilegios de administrador.')
  }

  // Continuar con la acci√≥n para usuarios autorizados
  // ... implementaci√≥n de la acci√≥n
}
```

```js filename="app/lib/actions.js" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // Verificar si el usuario est√° autorizado para realizar la acci√≥n
  if (userRole !== 'admin') {
    throw new Error('Acceso no autorizado: El usuario no tiene privilegios de administrador.')
  }

  // Continuar con la acci√≥n para usuarios autorizados
  // ... implementaci√≥n de la acci√≥n
}
```

### Protecci√≥n de Manejadores de Ruta

Los Manejadores de Ruta en Next.js juegan un papel vital en la gesti√≥n de solicitudes entrantes. Al igual que las Acciones del Servidor, deben protegerse para garantizar que solo usuarios autorizados puedan acceder a ciertas funcionalidades. Esto a menudo implica verificar el estado de autenticaci√≥n del usuario y sus permisos.

Aqu√≠ hay un ejemplo de c√≥mo proteger un Manejador de Ruta:

```ts filename="app/api/route.ts" switcher
export async function GET() {
  // Autenticaci√≥n del usuario y verificaci√≥n de rol
  const session = await getSession()

  // Verificar si el usuario est√° autenticado
  if (!session) {
    return new Response(null, { status: 401 }) // Usuario no autenticado
  }

  // Verificar si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // Usuario autenticado pero sin los permisos adecuados
  }

  // Obtenci√≥n de datos para usuarios autorizados
}
```

```js filename="app/api/route.js" switcher
export async function GET() {
  // Autenticaci√≥n del usuario y verificaci√≥n de rol
  const session = await getSession()

  // Verificar si el usuario est√° autenticado
  if (!session) {
    return new Response(null, { status: 401 }) // Usuario no autenticado
  }

  // Verificar si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // Usuario autenticado pero sin los permisos adecuados
  }

  // Obtenci√≥n de datos para usuarios autorizados
}
```

Este ejemplo demuestra un Manejador de Ruta con una verificaci√≥n de seguridad de dos niveles para autenticaci√≥n y autorizaci√≥n. Primero verifica si hay una sesi√≥n activa y luego confirma si el usuario que inici√≥ sesi√≥n es un 'admin'. Este enfoque garantiza un acceso seguro, limitado a usuarios autenticados y autorizados, manteniendo una seguridad robusta para el procesamiento de solicitudes.

### Autorizaci√≥n Usando Componentes del Servidor

Los [Componentes del Servidor](/docs/app/building-your-application/rendering/server-components) en Next.js est√°n dise√±ados para ejecuci√≥n del lado del servidor y ofrecen un entorno seguro para integrar l√≥gica compleja como la autorizaci√≥n. Permiten acceso directo a recursos del back-end, optimizando el rendimiento para tareas intensivas en datos y mejorando la seguridad para operaciones sensibles.

En los Componentes del Servidor, una pr√°ctica com√∫n es renderizar condicionalmente elementos de la interfaz de usuario basados en el rol del usuario. Este enfoque mejora la experiencia del usuario y la seguridad al garantizar que los usuarios solo accedan a contenido para el que est√°n autorizados.

**Ejemplo:**

```tsx filename="app/dashboard/page.tsx" switcher
export default async function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Asumiendo que 'role' es parte del objeto de sesi√≥n

  if (userRole === 'admin') {
    return <AdminDashboard /> // Componente para usuarios administradores
  } else if (userRole === 'user') {
    return <UserDashboard /> // Componente para usuarios regulares
  } else {
    return <AccessDenied /> // Componente mostrado para acceso no autorizado
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
export default function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Asumiendo que 'role' es parte del objeto de sesi√≥n

  if (userRole === 'admin') {
    return <AdminDashboard /> // Componente para usuarios administradores
  } else if (userRole === 'user') {
    return <UserDashboard /> // Componente para usuarios regulares
  } else {
    return <AccessDenied /> // Componente mostrado para acceso no autorizado
  }
}
```

En este ejemplo, el componente Dashboard renderiza diferentes interfaces de usuario para roles 'admin', 'user' y no autorizados. Este patr√≥n garantiza que cada usuario interact√∫e solo con componentes apropiados para su rol, mejorando tanto la seguridad como la experiencia del usuario.

</AppOnly>

### Mejores Pr√°cticas

- **Gesti√≥n Segura de Sesiones**: Priorice la seguridad de los datos de sesi√≥n para prevenir accesos no autorizados y brechas de datos. Use cifrado y pr√°cticas de almacenamiento seguro.
- **Gesti√≥n Din√°mica de Roles**: Utilice un sistema flexible para roles de usuario que permita ajustes f√°ciles en permisos y roles, evitando roles codificados.
- **Enfoque de Seguridad Primero**: En todos los aspectos de la l√≥gica de autorizaci√≥n, priorice la seguridad para proteger los datos del usuario y mantener la integridad de su aplicaci√≥n. Esto incluye pruebas exhaustivas y considerar posibles vulnerabilidades de seguridad.

## Gesti√≥n de Sesiones

La gesti√≥n de sesiones implica rastrear y administrar la interacci√≥n de un usuario con la aplicaci√≥n a lo largo del tiempo, asegurando que su estado autenticado se mantenga en diferentes partes de la aplicaci√≥n.

Esto evita la necesidad de m√∫ltiples inicios de sesi√≥n, mejorando tanto la seguridad como la conveniencia del usuario. Hay dos m√©todos principales utilizados para la gesti√≥n de sesiones: sesiones basadas en cookies y sesiones en base de datos.

### Sesiones Basadas en Cookies

> **üé• Ver:** Aprenda m√°s sobre sesiones basadas en cookies y autenticaci√≥n con Next.js ‚Üí [YouTube (11 minutos)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

Las sesiones basadas en cookies gestionan los datos del usuario almacenando informaci√≥n de sesi√≥n cifrada directamente en las cookies del navegador. Al iniciar sesi√≥n, estos datos cifrados se almacenan en la cookie. Cada solicitud posterior al servidor incluye esta cookie, minimizando la necesidad de consultas repetidas al servidor y mejorando la eficiencia del lado del cliente.

Sin embargo, este m√©todo requiere un cifrado cuidadoso para proteger datos sensibles, ya que las cookies son susceptibles a riesgos de seguridad del lado del cliente. Cifrar los datos de sesi√≥n en las cookies es clave para proteger la informaci√≥n del usuario de accesos no autorizados. Asegura que incluso si una cookie es robada, los datos dentro de ella permanezcan ilegibles.

Adem√°s, aunque las cookies individuales tienen un tama√±o limitado (t√≠picamente alrededor de 4KB), t√©cnicas como la divisi√≥n de cookies pueden superar esta limitaci√≥n dividiendo grandes conjuntos de datos de sesi√≥n en m√∫ltiples cookies.

Establecer una cookie en un proyecto de Next.js podr√≠a verse as√≠:

**Establecer una cookie en el servidor:**

<PagesOnly>

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: '¬°Cookie establecida exitosamente!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: '¬°Cookie establecida exitosamente!' })
}
```

</PagesOnly>

<AppOnly>

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Cifre sus datos de sesi√≥n
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  // Redirigir o manejar la respuesta despu√©s de establecer la cookie
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Cifre sus datos de sesi√≥n
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  // Redirigir o manejar la respuesta despu√©s de establecer la cookie
}
```

**Acceder a los datos de sesi√≥n almacenados en la cookie en un componente del servidor:**

```tsx filename="app/page.tsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

```jsx filename="app/page.jsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

</AppOnly>

### Sesiones en Base de Datos

La gesti√≥n de sesiones en base de datos implica almacenar datos de sesi√≥n en el servidor, con el navegador del usuario recibiendo solo un ID de sesi√≥n. Este ID referencia los datos de sesi√≥n almacenados del lado del servidor, sin contener los datos mismos. Este m√©todo mejora la seguridad, ya que mantiene los datos sensibles de sesi√≥n alejados del entorno del lado del cliente, reduciendo el riesgo de exposici√≥n a ataques del lado del cliente. Las sesiones en base de datos tambi√©n son m√°s escalables, acomodando necesidades mayores de almacenamiento de datos.

Sin embargo, este enfoque tiene sus compensaciones. Puede aumentar la sobrecarga de rendimiento debido a la necesidad de b√∫squedas en la base de datos en cada interacci√≥n del usuario. Estrategias como el almacenamiento en cach√© de datos de sesi√≥n pueden ayudar a mitigar esto. Adem√°s, la dependencia de la base de datos significa que la gesti√≥n de sesiones es tan confiable como el rendimiento y disponibilidad de la base de datos.

Aqu√≠ hay un ejemplo simplificado de implementaci√≥n de sesiones en base de datos en una aplicaci√≥n Next.js:

**Crear una Sesi√≥n en el Servidor**:

<PagesOnly>

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Error interno del servidor' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Error interno del servidor' })
  }
}
```

</PagesOnly>

<AppOnly>

```js
import db from './lib/db'

export async function createSession(user) {
  const sessionId = generateSessionId() // Generar un ID de sesi√≥n √∫nico
  await db.insertSession({ sessionId, userId: user.id, createdAt: new Date() })
  return sessionId
}
```

**Recuperar una Sesi√≥n en Middleware o L√≥gica del Lado del Servidor**:

```js
import { cookies } from 'next/headers'
import db from './lib/db'

export async function getSession() {
  const sessionId = cookies().get('sessionId')?.value
  return sessionId ? await db.findSession(sessionId) : null
}
```

</AppOnly>

### Selecci√≥n de Gesti√≥n de Sesiones en Next.js

La decisi√≥n entre sesiones basadas en cookies y sesiones en base de datos en Next.js depende de las necesidades de su aplicaci√≥n. Las sesiones basadas en cookies son m√°s simples y se adaptan mejor a aplicaciones peque√±as con menor carga en el servidor, pero pueden ofrecer menos seguridad. Las sesiones en base de datos, aunque m√°s complejas, proporcionan mejor seguridad y escalabilidad, siendo ideales para aplicaciones m√°s grandes y sensibles a los datos.

Con [soluciones de autenticaci√≥n](#ejemplos) como [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5), la gesti√≥n de sesiones se vuelve m√°s eficiente, ya sea utilizando cookies o almacenamiento en base de datos. Esta automatizaci√≥n simplifica el proceso de desarrollo, pero es importante comprender el m√©todo de gesti√≥n de sesiones utilizado por la soluci√≥n elegida. Aseg√∫rese de que se alinee con los requisitos de seguridad y rendimiento de su aplicaci√≥n.

Independientemente de su elecci√≥n, priorice la seguridad en su estrategia de gesti√≥n de sesiones. Para sesiones basadas en cookies, el uso de cookies seguras y HTTP-only es crucial para proteger los datos de sesi√≥n. Para sesiones en base de datos, las copias de seguridad regulares y el manejo seguro de los datos de sesi√≥n son esenciales. Implementar mecanismos de expiraci√≥n y limpieza de sesiones es vital en ambos enfoques para prevenir accesos no autorizados y mantener el rendimiento y la confiabilidad de la aplicaci√≥n.

## Ejemplos

A continuaci√≥n se presentan soluciones de autenticaci√≥n compatibles con Next.js. Consulte las gu√≠as de inicio r√°pido para aprender c√≥mo configurarlas en su aplicaci√≥n Next.js:

{/* TODO: Cambiar enlace a authjs.dev cuando la nueva documentaci√≥n est√© lista */}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Lucia](https://lucia-auth.com/getting-started/nextjs-app)
- [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [Iron Session](https://github.com/vvo/iron-session)

## Lecturas Adicionales

Para continuar aprendiendo sobre autenticaci√≥n y seguridad, consulte los siguientes recursos:

- [Entendiendo los Ataques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Entendiendo los Ataques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
