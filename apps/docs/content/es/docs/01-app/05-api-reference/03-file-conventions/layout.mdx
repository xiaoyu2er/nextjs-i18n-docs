---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:11:40.828Z
title: layout.js
description: Documentación de referencia para el archivo layout.js.
---

El archivo `layout` se utiliza para definir un diseño en tu aplicación Next.js.

```tsx filename="app/dashboard/layout.tsx" switcher
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default function DashboardLayout({ children }) {
  return <section>{children}</section>
}
```

Un **diseño raíz (root layout)** es el diseño de nivel superior en el directorio raíz `app`. Se utiliza para definir las etiquetas `<html>` y `<body>` y otros elementos de interfaz de usuario compartidos globalmente.

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

## Referencia

### Props

#### `children` (requerido)

Los componentes de diseño deben aceptar y utilizar una prop `children`. Durante el renderizado, `children` se completará con los segmentos de ruta que el diseño está envolviendo. Estos serán principalmente el componente de un [Layout](/docs/app/api-reference/file-conventions/page) hijo (si existe) o [Page](/docs/app/api-reference/file-conventions/page), pero también podrían ser otros archivos especiales como [Loading](/docs/app/building-your-application/routing/loading-ui-and-streaming) o [Error](/docs/app/getting-started/error-handling) cuando corresponda.

#### `params` (opcional)

Una promesa que se resuelve en un objeto que contiene los [parámetros de ruta dinámica](/docs/app/api-reference/file-conventions/dynamic-routes) desde el segmento raíz hasta ese diseño.

```tsx filename="app/dashboard/[team]/layout.tsx" switcher
export default async function Layout({
  params,
}: {
  params: Promise<{ team: string }>
}) {
  const { team } = await params
}
```

```jsx filename="app/dashboard/[team]/layout.js" switcher
export default async function Layout({ params }) {
  const { team } = await params
}
```

| Ruta de ejemplo               | URL            | `params`                           |
| ----------------------------- | -------------- | ---------------------------------- |
| `app/dashboard/[team]/layout.js`  | `/dashboard/1` | `Promise<{ team: '1' }>`           |
| `app/shop/[tag]/[item]/layout.js` | `/shop/1/2`    | `Promise<{ tag: '1', item: '2' }>` |
| `app/blog/[...slug]/layout.js`    | `/blog/1/2`    | `Promise<{ slug: ['1', '2'] }>`    |

- Dado que la prop `params` es una promesa, debes usar `async/await` o la función [`use`](https://react.dev/reference/react/use) de React para acceder a los valores.
  - En la versión 14 y anteriores, `params` era una prop síncrona. Para mantener la compatibilidad con versiones anteriores, aún puedes acceder a ella de forma síncrona en Next.js 15, pero este comportamiento quedará obsoleto en el futuro.

### Diseño raíz (Root Layout)

El directorio `app` **debe** incluir un `app/layout.js` raíz.

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

- El diseño raíz **debe** definir las etiquetas `<html>` y `<body>`.
  - No debes agregar manualmente etiquetas `<head>` como `<title>` y `<meta>` en los diseños raíz. En su lugar, debes usar la [API de Metadata](/docs/app/getting-started/metadata-and-og-images) que maneja automáticamente requisitos avanzados como streaming y desduplicación de elementos `<head>`.
- Puedes usar [grupos de rutas (route groups)](/docs/app/api-reference/file-conventions/route-groups) para crear múltiples diseños raíz.
  - Navegar **entre múltiples diseños raíz** causará una **recarga completa de página** (en lugar de una navegación del lado del cliente). Por ejemplo, navegar desde `/cart` que usa `app/(shop)/layout.js` a `/blog` que usa `app/(marketing)/layout.js` causará una recarga completa de página. Esto **solo** aplica para múltiples diseños raíz.

## Consideraciones

### Objeto Request

Los diseños se almacenan en caché en el cliente durante la navegación para evitar solicitudes innecesarias al servidor.

[Los diseños](/docs/app/api-reference/file-conventions/layout) no se vuelven a renderizar. Pueden almacenarse en caché y reutilizarse para evitar cálculos innecesarios al navegar entre páginas. Al restringir el acceso al objeto request crudo en los diseños, Next.js puede evitar la ejecución de código de usuario potencialmente lento o costoso dentro del diseño, lo que podría afectar negativamente el rendimiento.

Para acceder al objeto request, puedes usar las APIs [`headers`](/docs/app/api-reference/functions/headers) y [`cookies`](/docs/app/api-reference/functions/cookies) en [Componentes del Servidor (Server Components)](/docs/app/getting-started/server-and-client-components) y Funciones.

```tsx filename="app/shop/layout.tsx" switcher
import { cookies } from 'next/headers'

export default async function Layout({ children }) {
  const cookieStore = await cookies()
  const theme = cookieStore.get('theme')
  return '...'
}
```

```jsx filename="app/shop/layout.js" switcher
import { cookies } from 'next/headers'

export default async function Layout({ children }) {
  const cookieStore = await cookies()
  const theme = cookieStore.get('theme')
  return '...'
}
```

### Parámetros de consulta (Query params)

Los diseños no se vuelven a renderizar en la navegación, por lo que no pueden acceder a los parámetros de búsqueda que de otro modo quedarían obsoletos.

Para acceder a los parámetros de consulta actualizados, puedes usar la prop [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) de la Página, o leerlos dentro de un Componente del Cliente usando el hook [`useSearchParams`](/docs/app/api-reference/functions/use-search-params). Dado que los Componentes del Cliente se vuelven a renderizar durante la navegación, tienen acceso a los últimos parámetros de consulta.

```tsx filename="app/ui/search.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function Search() {
  const searchParams = useSearchParams()

  const search = searchParams.get('search')

  return '...'
}
```

```jsx filename="app/ui/search.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function Search() {
  const searchParams = useSearchParams()

  const search = searchParams.get('search')

  return '...'
}
```

```tsx filename="app/shop/layout.tsx" switcher
import Search from '@/app/ui/search'

export default function Layout({ children }) {
  return (
    <>
      <Search />
      {children}
    </>
  )
}
```

```jsx filename="app/shop/layout.js" switcher
import Search from '@/app/ui/search'

export default function Layout({ children }) {
  return (
    <>
      <Search />
      {children}
    </>
  )
}
```

### Pathname

Los diseños no se vuelven a renderizar en la navegación, por lo que no acceden al pathname que de otro modo quedaría obsoleto.

Para acceder al pathname actual, puedes leerlo dentro de un Componente del Cliente usando el hook [`usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname). Dado que los Componentes del Cliente se vuelven a renderizar durante la navegación, tienen acceso al último pathname.

```tsx filename="app/ui/breadcrumbs.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

// Lógica simplificada de breadcrumbs
export default function Breadcrumbs() {
  const pathname = usePathname()
  const segments = pathname.split('/')

  return (
    <nav>
      {segments.map((segment, index) => (
        <span key={index}>
          {' > '}
          {segment}
        </span>
      ))}
    </nav>
  )
}
```

```jsx filename="app/ui/breadcrumbs.js" switcher
'use client'

import { usePathname } from 'next/navigation'

// Lógica simplificada de breadcrumbs
export default function Breadcrumbs() {
  const pathname = usePathname()
  const segments = pathname.split('/')

  return (
    <nav>
      {segments.map((segment, index) => (
        <span key={index}>
          {' > '}
          {segment}
        </span>
      ))}
    </nav>
  )
}
```

```tsx filename="app/docs/layout.tsx" switcher
import { Breadcrumbs } from '@/app/ui/Breadcrumbs'

export default function Layout({ children }) {
  return (
    <>
      <Breadcrumbs />
      <main>{children}</main>
    </>
  )
}
```

```jsx filename="app/docs/layout.js" switcher
import { Breadcrumbs } from '@/app/ui/Breadcrumbs'

export default function Layout({ children }) {
  return (
    <>
      <Breadcrumbs />
      <main>{children}</main>
    </>
  )
}
```

### Obtención de datos (Fetching Data)

Los diseños no pueden pasar datos a sus `children`. Sin embargo, puedes obtener los mismos datos en una ruta más de una vez y usar [`cache`](https://react.dev/reference/react/cache) de React para desduplicar las solicitudes sin afectar el rendimiento.

Alternativamente, al usar [`fetch`](https://nextjs.org/docs/app/api-reference/functions/fetch) en Next.js, las solicitudes se desduplican automáticamente.

```tsx filename="app/lib/data.ts" switcher
export async function getUser(id: string) {
  const res = await fetch(`https://.../users/${id}`)
  return res.json()
}
```

```tsx filename="app/dashboard/layout.tsx" switcher
import { getUser } from '@/app/lib/data'
import { UserName } from '@/app/ui/user-name'

export default async function Layout({ children }) {
  const user = await getUser('1')

  return (
    <>
      <nav>
        {/* ... */}
        <UserName user={user.name} />
      </nav>
      {children}
    </>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
import { getUser } from '@/app/lib/data'
import { UserName } from '@/app/ui/user-name'

export default async function Layout({ children }) {
  const user = await getUser('1')

  return (
    <>
      <nav>
        {/* ... */}
        <UserName user={user.name} />
      </nav>
      {children}
    </>
  )
}
```

```tsx filename="app/dashboard/page.tsx" switcher
import { getUser } from '@/app/lib/data'
import { UserName } from '@/app/ui/user-name'

export default async function Page() {
  const user = await getUser('1')

  return (
    <div>
      <h1>Welcome {user.name}</h1>
    </div>
  )
}
```

```jsx filename="app/dashboard/page.js" switcher
import { getUser } from '@/app/lib/data'
import { UserName } from '@/app/ui/user-name'

export default async function Page() {
  const user = await getUser('1')

  return (
    <div>
      <h1>Welcome {user.name}</h1>
    </div>
  )
}
```

### Acceso a segmentos hijos

Los diseños no tienen acceso a los segmentos de ruta por debajo de sí mismos. Para acceder a todos los segmentos de ruta, puedes usar [`useSelectedLayoutSegment`](/docs/app/api-reference/functions/use-selected-layout-segment) o [`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments) en un Componente del Cliente.

```tsx filename="app/ui/nav-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useSelectedLayoutSegment } from 'next/navigation'

export default function NavLink({
  slug,
  children,
}: {
  slug: string
  children: React.ReactNode
}) {
  const segment = useSelectedLayoutSegment()
  const isActive = slug === segment

  return (
    <Link
      href={`/blog/${slug}`}
      // Cambiar estilo dependiendo de si el enlace está activo
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
    >
      {children}
    </Link>
  )
}
```

```jsx filename="app/ui/nav-link.js" switcher
'use client'

import Link from 'next/link'
import { useSelectedLayoutSegment } from 'next/navigation'

export default function NavLinks({ slug, children }) {
  const segment = useSelectedLayoutSegment()
  const isActive = slug === segment

  return (
    <Link
      href={`/blog/${slug}`}
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
    >
      {children}
    </Link>
  )
}
```

```tsx filename="app/blog/layout.tsx" switcher
import { NavLink } from './nav-link'
import getPosts from './get-posts'

export default async function Layout({
  children,
}: {
  children: React.ReactNode
}) {
  const featuredPosts = await getPosts()
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <NavLink slug={post.slug}>{post.title}</NavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  )
}
```

```jsx filename="app/blog/layout.js" switcher
import { NavLink } from './nav-link'
import getPosts from './get-posts'

export default async function Layout({ children }) {
  const featuredPosts = await getPosts()
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <NavLink slug={post.slug}>{post.title}</NavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  )
}
```

## Ejemplos

### Metadata

Puedes modificar los elementos HTML `<head>` como `title` y `meta` usando el [objeto `metadata`](/docs/app/api-reference/functions/generate-metadata#the-metadata-object) o la [función `generateMetadata`](/docs/app/api-reference/functions/generate-metadata#generatemetadata-function).

```tsx filename="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Next.js',
}

export default function Layout({ children }: { children: React.ReactNode }) {
  return '...'
}
```

```jsx filename="app/layout.js" switcher
export const metadata = {
  title: 'Next.js',
}

export default function Layout({ children }) {
  return '...'
}
```

> **Nota importante**: No debes agregar manualmente etiquetas `<head>` como `<title>` y `<meta>` en los diseños raíz. En su lugar, usa las [APIs de Metadata](/docs/app/api-reference/functions/generate-metadata) que manejan automáticamente requisitos avanzados como streaming y desduplicación de elementos `<head>`.

### Enlaces de navegación activos

Puedes usar el hook [`usePathname`](/docs/app/api-reference/functions/use-pathname) para determinar si un enlace de navegación está activo.

Dado que `usePathname` es un hook del cliente, necesitas extraer los enlaces de navegación en un Componente del Cliente, que puede importarse en tu diseño:

```tsx filename="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function NavLinks() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Inicio
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        Acerca de
      </Link>
    </nav>
  )
}
```

```jsx filename="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Inicio
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        Acerca de
      </Link>
    </nav>
  )
}
```

```tsx filename="app/layout.tsx" switcher
import { NavLinks } from '@/app/ui/nav-links'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <NavLinks />
        <main>{children}</main>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { NavLinks } from '@/app/ui/nav-links'

export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavLinks />
        <main>{children}</main>
      </body>
    </html>
  )
}
```

### Mostrar contenido basado en `params`

Utilizando [segmentos de ruta dinámicos](/docs/app/api-reference/file-conventions/dynamic-routes), puede mostrar o recuperar contenido específico basado en la propiedad `params`.

```tsx filename="app/dashboard/layout.tsx" switcher
export default async function DashboardLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Promise<{ team: string }>
}) {
  const { team } = await params

  return (
    <section>
      <header>
        <h1>Bienvenido al Panel de {team}</h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default async function DashboardLayout({ children, params }) {
  const { team } = await params

  return (
    <section>
      <header>
        <h1>Bienvenido al Panel de {team}</h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

### Leer `params` en Componentes del Cliente (Client Components)

Para usar `params` en un Componente del Cliente (que no puede ser `async`), puede utilizar la función [`use`](https://react.dev/reference/react/use) de React para leer la promesa:

```tsx filename="app/page.tsx" switcher
'use client'

import { use } from 'react'

export default function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = use(params)
}
```

```js filename="app/page.js" switcher
'use client'

import { use } from 'react'

export default function Page({ params }) {
  const { slug } = use(params)
}
```

## Historial de Versiones

| Versión      | Cambios                                                                                       |
| ------------ | --------------------------------------------------------------------------------------------- |
| `v15.0.0-RC` | `params` ahora es una promesa. Hay disponible un [codemod](/docs/app/guides/upgrading/codemods#150). |
| `v13.0.0`    | Se introdujo `layout`.                                                                        |
