---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:14:37.297Z
title: Link
description: Habilita navegación rápida del lado del cliente con el componente integrado `next/link`.
---

{/* El contenido de este documento se comparte entre el enrutador de app y pages. Puedes usar el componente `<PagesOnly>Contenido</PagesOnly>` para agregar contenido específico del enrutador Pages. Cualquier contenido compartido no debe estar envuelto en un componente. */}

`<Link>` es un componente de React que extiende el elemento HTML `<a>` para proporcionar [prefetching](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) y navegación del lado del cliente entre rutas. Es la forma principal de navegar entre rutas en Next.js.

Uso básico:

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</PagesOnly>

## Referencia

Las siguientes props pueden pasarse al componente `<Link>`:

<PagesOnly>

| Prop                                | Ejemplo                  | Tipo              | Requerido |
| ----------------------------------- | ------------------------ | ----------------- | --------- |
| [`href`](#href-required)            | `href="/dashboard"`      | String u Objeto   | Sí        |
| [`replace`](#replace)               | `replace={false}`        | Booleano          | -         |
| [`scroll`](#scroll)                 | `scroll={false}`         | Booleano          | -         |
| [`prefetch`](#prefetch)             | `prefetch={false}`       | Booleano          | -         |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}`  | Booleano          | -         |
| [`passHref`](#passhref)             | `passHref={true}`        | Booleano          | -         |
| [`shallow`](#shallow)               | `shallow={false}`        | Booleano          | -         |
| [`locale`](#locale)                 | `locale="fr"`            | String o Booleano | -         |
| [`onNavigate`](#onnavigate)         | `onNavigate={(e) => {}}` | Función           | -         |

</PagesOnly>

<AppOnly>

| Prop                        | Ejemplo                  | Tipo             | Requerido |
| --------------------------- | ------------------------ | ---------------- | --------- |
| [`href`](#href-required)    | `href="/dashboard"`      | String u Objeto  | Sí        |
| [`replace`](#replace)       | `replace={false}`        | Booleano         | -         |
| [`scroll`](#scroll)         | `scroll={false}`         | Booleano         | -         |
| [`prefetch`](#prefetch)     | `prefetch={false}`       | Booleano o null  | -         |
| [`onNavigate`](#onnavigate) | `onNavigate={(e) => {}}` | Función          | -         |

</AppOnly>

> **Bueno saber**: Los atributos de la etiqueta `<a>` como `className` o `target="_blank"` pueden agregarse a `<Link>` como props y se pasarán al elemento `<a>` subyacente.

### `href` (requerido)

La ruta o URL a la que navegar.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

// Navegar a /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

// Navegar a /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

// Navegar a /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

// Navegar a /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</PagesOnly>

### `replace`

**Por defecto es `false`.** Cuando es `true`, `next/link` reemplazará el estado actual del historial en lugar de agregar una nueva URL a la [pila del historial del navegador](https://developer.mozilla.org/docs/Web/API/History_API).

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `scroll`

**Por defecto es `true`.** El comportamiento de desplazamiento predeterminado de `<Link>` en Next.js **es mantener la posición de desplazamiento**, similar a cómo los navegadores manejan la navegación hacia atrás y adelante. Cuando navegas a una nueva [Página](/docs/app/api-reference/file-conventions/page), la posición de desplazamiento se mantendrá igual siempre que la Página sea visible en el viewport. Sin embargo, si la Página no es visible en el viewport, Next.js se desplazará hasta la parte superior del primer elemento de la Página.

Cuando `scroll = {false}`, Next.js no intentará desplazarse al primer elemento de la Página.

> **Bueno saber**: Next.js verifica si `scroll: false` antes de gestionar el comportamiento de desplazamiento. Si el desplazamiento está habilitado, identifica el nodo DOM relevante para la navegación e inspecciona cada elemento de nivel superior. Se omiten todos los elementos no desplazables y aquellos sin HTML renderizado, esto incluye elementos con posición fija o sticky, y elementos no visibles como los calculados con `getBoundingClientRect`. Next.js continúa a través de los elementos hermanos hasta identificar un elemento desplazable que sea visible en el viewport.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `prefetch`

<AppOnly>

El prefetching ocurre cuando un componente `<Link />` entra en el viewport del usuario (inicialmente o mediante desplazamiento). Next.js precarga y carga la ruta vinculada (indicada por el `href`) y sus datos en segundo plano para mejorar el rendimiento de las navegaciones del lado del cliente. Si los datos precargados han expirado cuando el usuario pasa el cursor sobre un `<Link />`, Next.js intentará precargarlos nuevamente. **El prefetching solo está habilitado en producción**.

Los siguientes valores pueden pasarse a la prop `prefetch`:

- **`null` (predeterminado)**: El comportamiento de prefetch depende de si la ruta es estática o dinámica. Para rutas estáticas, se precargará toda la ruta (incluyendo todos sus datos). Para rutas dinámicas, se precargará la ruta parcial hasta el segmento más cercano con un límite [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- `true`: Se precargará toda la ruta tanto para rutas estáticas como dinámicas.
- `false`: El prefetching nunca ocurrirá ni al entrar en el viewport ni al pasar el cursor.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

El prefetching ocurre cuando un componente `<Link />` entra en el viewport del usuario (inicialmente o mediante desplazamiento). Next.js precarga y carga la ruta vinculada (indicada por el `href`) y los datos en segundo plano para mejorar el rendimiento de las navegaciones del lado del cliente. **El prefetching solo está habilitado en producción**.

Los siguientes valores pueden pasarse a la prop `prefetch`:

- **`true` (predeterminado)**: Se precargará toda la ruta y sus datos.
- `false`: El prefetching no ocurrirá al entrar en el viewport, pero sí al pasar el cursor. Si deseas eliminar completamente el prefetching al pasar el cursor, considera usar una etiqueta `<a>` o [adoptar incrementalmente](/docs/app/guides/migrating/app-router-migration) el App Router, que permite deshabilitar el prefetching al pasar el cursor.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

### `legacyBehavior`

> **Advertencia**: La prop `legacyBehavior` se eliminará en Next.js v16. Para adoptar el nuevo comportamiento de `<Link>`, elimina cualquier etiqueta `<a>` usada como hijo de `<Link>`. Hay un [codemod disponible](/docs/app/guides/upgrading/codemods#new-link) para ayudarte a actualizar automáticamente tu código base.

Desde la versión 13, un elemento `<a>` ya no es necesario como hijo del componente `<Link>`. Si aún necesitas el comportamiento antiguo por razones de compatibilidad, puedes agregar la prop `legacyBehavior`.

> **Bueno saber**: cuando `legacyBehavior` no está establecido en `true`, todas las propiedades de la etiqueta [`anchor`](https://developer.mozilla.org/docs/Web/HTML/Element/a) pueden pasarse a `next/link`, como `className`, `onClick`, etc.

### `passHref`

Fuerza a `Link` a enviar la propiedad `href` a su hijo. Por defecto es `false`. Consulta el ejemplo de [pasar un componente funcional](#nesting-a-functional-component) para más información.

### `shallow`

Actualiza la ruta de la página actual sin volver a ejecutar [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props), [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props) o [`getInitialProps`](/docs/pages/api-reference/functions/get-initial-props). Por defecto es `false`.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

### `locale`

La configuración regional activa se agrega automáticamente. `locale` permite proporcionar una configuración regional diferente. Cuando es `false`, `href` debe incluir la configuración regional ya que el comportamiento predeterminado está deshabilitado.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Comportamiento predeterminado: se agrega la configuración regional */}
      <Link href="/dashboard">Dashboard (con configuración regional)</Link>

      {/* Deshabilitar la adición automática de configuración regional */}
      <Link href="/dashboard" locale={false}>
        Dashboard (sin configuración regional)
      </Link>

      {/* Especificar una configuración regional diferente */}
      <Link href="/dashboard" locale="fr">
        Dashboard (Francés)
      </Link>
    </>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Comportamiento predeterminado: se agrega la configuración regional */}
      <Link href="/dashboard">Dashboard (con configuración regional)</Link>

      {/* Deshabilitar la adición automática de configuración regional */}
      <Link href="/dashboard" locale={false}>
        Dashboard (sin configuración regional)
      </Link>

      {/* Especificar una configuración regional diferente */}
      <Link href="/dashboard" locale="fr">
        Dashboard (Francés)
      </Link>
    </>
  )
}
```

</PagesOnly>

### `onNavigate`

Un manejador de eventos que se llama durante la navegación del lado del cliente. El manejador recibe un objeto de evento que incluye un método `preventDefault()`, permitiéndote cancelar la navegación si es necesario.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Solo se ejecuta durante la navegación SPA
        console.log('Navegando...')

        // Opcionalmente prevenir la navegación
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Solo se ejecuta durante la navegación SPA
        console.log('Navegando...')

        // Opcionalmente prevenir la navegación
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

> **Bueno saber**: Aunque `onClick` y `onNavigate` pueden parecer similares, sirven para diferentes propósitos. `onClick` se ejecuta para todos los eventos de clic, mientras que `onNavigate` solo se ejecuta durante la navegación del lado del cliente. Algunas diferencias clave:
>
> - Al usar teclas modificadoras (`Ctrl`/`Cmd` + Clic), `onClick` se ejecuta pero `onNavigate` no, ya que Next.js previene la navegación predeterminada para nuevas pestañas.
> - Las URL externas no activarán `onNavigate` ya que es solo para navegaciones del mismo origen y del lado del cliente.
> - Los enlaces con el atributo `download` funcionarán con `onClick` pero no con `onNavigate` ya que el navegador tratará la URL vinculada como una descarga.

## Ejemplos

Los siguientes ejemplos demuestran cómo usar el componente `<Link>` en diferentes escenarios.

<AppOnly>

### Enlazando a segmentos dinámicos

Cuando enlazas a [segmentos dinámicos](/docs/app/api-reference/file-conventions/dynamic-routes), puedes usar [template literals e interpolación](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals) para generar una lista de enlaces. Por ejemplo, para generar una lista de publicaciones de blog:

```tsx filename="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

### Verificación de enlaces activos

Puede utilizar [`usePathname()`](/docs/app/api-reference/functions/use-pathname) para determinar si un enlace está activo. Por ejemplo, para agregar una clase al enlace activo, puede verificar si el `pathname` actual coincide con el `href` del enlace:

```tsx filename="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Inicio
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        Acerca de
      </Link>
    </nav>
  )
}
```

```jsx filename="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Inicio
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        Acerca de
      </Link>
    </nav>
  )
}
```

### Desplazamiento a un `id`

Si desea desplazarse a un `id` específico durante la navegación, puede agregar a su URL un enlace con hash `#` o simplemente pasar un enlace con hash a la propiedad `href`. Esto es posible ya que `<Link>` se renderiza como un elemento `<a>`.

```jsx
<Link href="/dashboard#settings">Configuración</Link>

// Salida
<a href="/dashboard#settings">Configuración</a>
```

> **Nota importante**:
>
> - Next.js se desplazará a la [Página](/docs/app/api-reference/file-conventions/page) si no está visible en el viewport durante la navegación.

</AppOnly>

### Enlaces a segmentos de ruta dinámicos

Para [segmentos de ruta dinámicos](/docs/app/api-reference/file-conventions/dynamic-routes), puede ser útil utilizar literales de plantilla para crear la ruta del enlace.

<PagesOnly>

Por ejemplo, puede generar una lista de enlaces a la ruta dinámica `pages/blog/[slug].js`

```tsx filename="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</PagesOnly>

<AppOnly>

Por ejemplo, puede generar una lista de enlaces a la ruta dinámica `app/blog/[slug]/page.js`:

```tsx filename="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</AppOnly>

### Si el hijo es un componente personalizado que envuelve una etiqueta `<a>`

<AppOnly>

Si el hijo de `Link` es un componente personalizado que envuelve una etiqueta `<a>`, debe agregar `passHref` a `Link`. Esto es necesario si utiliza bibliotecas como [styled-components](https://styled-components.com/). Sin esto, la etiqueta `<a>` no tendrá el atributo `href`, lo que afecta la accesibilidad de su sitio y podría perjudicar el SEO. Si utiliza [ESLint](/docs/pages/api-reference/config/eslint), existe una regla integrada `next/link-passhref` para garantizar el uso correcto de `passHref`.

</AppOnly>

<PagesOnly>

Si el hijo de `Link` es un componente personalizado que envuelve una etiqueta `<a>`, debe agregar `passHref` a `Link`. Esto es necesario si utiliza bibliotecas como [styled-components](https://styled-components.com/). Sin esto, la etiqueta `<a>` no tendrá el atributo `href`, lo que afecta la accesibilidad de su sitio y podría perjudicar el SEO. Si utiliza [ESLint](/docs/pages/api-reference/config/eslint), existe una regla integrada `next/link-passhref` para garantizar el uso correcto de `passHref`.

</PagesOnly>

```tsx filename="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Esto crea un componente personalizado que envuelve una etiqueta <a>
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

```jsx filename="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Esto crea un componente personalizado que envuelve una etiqueta <a>
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

- Si utiliza la función JSX pragma de [emotion](https://emotion.sh/) (`@jsx jsx`), debe usar `passHref` incluso si utiliza una etiqueta `<a>` directamente.
- El componente debe admitir la propiedad `onClick` para activar la navegación correctamente.

### Anidar un componente funcional

Si el hijo de `Link` es un componente funcional, además de usar `passHref` y `legacyBehavior`, debe envolver el componente en [`React.forwardRef`](https://react.dev/reference/react/forwardRef):

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Definir el tipo de props para MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Usar React.ForwardRefRenderFunction para tipar correctamente la ref reenviada
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Haz clic aquí
    </a>
  )
}

// Usar React.forwardRef para envolver el componente
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` y `ref` deben pasarse al elemento DOM
// para un manejo adecuado
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Haz clic aquí
    </a>
  )
})

// Agregar un nombre de visualización para el componente (útil para depuración)
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Definir el tipo de props para MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Usar React.ForwardRefRenderFunction para tipar correctamente la ref reenviada
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Haz clic aquí
    </a>
  )
}

// Usar React.forwardRef para envolver el componente
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` y `ref` deben pasarse al elemento DOM
// para un manejo adecuado
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Haz clic aquí
    </a>
  )
})

// Agregar un nombre de visualización para el componente (útil para depuración)
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

### Pasar un objeto URL

`Link` también puede recibir un objeto URL y lo formateará automáticamente para crear la cadena de URL:

```tsx filename="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          Acerca de nosotros
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Entrada de blog
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          Acerca de nosotros
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Entrada de blog
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

El ejemplo anterior tiene un enlace a:

- Una ruta predefinida: `/about?name=test`
- Una [ruta dinámica](/docs/app/api-reference/file-conventions/dynamic-routes): `/blog/my-post`

Puede utilizar todas las propiedades como se definen en la [documentación del módulo URL de Node.js](https://nodejs.org/api/url.html#url_url_strings_and_url_objects).

</PagesOnly>

### Reemplazar la URL en lugar de empujar

El comportamiento predeterminado del componente `Link` es `empujar` una nueva URL a la pila del `historial`. Puede usar la propiedad `replace` para evitar agregar una nueva entrada, como en el siguiente ejemplo:

<AppOnly>

```tsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      Acerca de nosotros
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      Acerca de nosotros
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      Acerca de nosotros
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      Acerca de nosotros
    </Link>
  )
}
```

</PagesOnly>

### Desactivar el desplazamiento a la parte superior de la página

<AppOnly>

El comportamiento predeterminado de desplazamiento de `<Link>` en Next.js **es mantener la posición de desplazamiento**, similar a cómo los navegadores manejan la navegación hacia atrás y adelante. Cuando navega a una nueva [Página](/docs/app/api-reference/file-conventions/page), la posición de desplazamiento se mantendrá igual siempre que la Página sea visible en el viewport.

Sin embargo, si la Página no es visible en el viewport, Next.js se desplazará a la parte superior del primer elemento de la Página. Si desea desactivar este comportamiento, puede pasar `scroll={false}` al componente `<Link>`, o `scroll: false` a `router.push()` o `router.replace()`.

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Desactiva el desplazamiento a la parte superior
    </Link>
  )
}
```

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Desactiva el desplazamiento a la parte superior
    </Link>
  )
}
```

Usando `router.push()` o `router.replace()`:

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

El comportamiento predeterminado de `Link` es desplazarse a la parte superior de la página. Cuando hay un hash definido, se desplazará al id específico, como una etiqueta `<a>` normal. Para evitar el desplazamiento a la parte superior o al hash, se puede agregar `scroll={false}` a `Link`:

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Desactiva el desplazamiento a la parte superior
    </Link>
  )
}
```

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Desactiva el desplazamiento a la parte superior
    </Link>
  )
}
```

</PagesOnly>

### Prefetching de enlaces en Middleware

Es común usar [Middleware](/docs/app/building-your-application/routing/middleware) para autenticación u otros propósitos que involucren reescribir al usuario a una página diferente. Para que el componente `<Link />` pueda prefetch (precargar) correctamente los enlaces con reescrituras a través de Middleware, necesita indicarle a Next.js tanto la URL a mostrar como la URL para prefetch. Esto es necesario para evitar solicitudes innecesarias al middleware para conocer la ruta correcta a precargar.

Por ejemplo, si desea servir una ruta `/dashboard` que tenga vistas autenticadas y para visitantes, puede agregar lo siguiente en su Middleware para redirigir al usuario a la página correcta:

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

En este caso, debería usar el siguiente código en su componente `<Link />`:

<AppOnly>

```tsx filename="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Your auth hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

> **Nota importante**: Si está usando [Rutas Dinámicas](/docs/app/api-reference/file-conventions/dynamic-routes), necesitará adaptar sus props `as` y `href`. Por ejemplo, si tiene una Ruta Dinámica como `/dashboard/authed/[user]` que desea presentar de manera diferente a través de middleware, escribiría: `<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>`.

</PagesOnly>

### Bloqueo de navegación

Puede usar la prop `onNavigate` para bloquear la navegación cuando se cumplan ciertas condiciones, como cuando un formulario tiene cambios sin guardar. Cuando necesite bloquear la navegación en múltiples componentes de su aplicación (como prevenir la navegación desde cualquier enlace mientras se edita un formulario), React Context proporciona una forma limpia de compartir este estado de bloqueo. Primero, cree un contexto para rastrear el estado de bloqueo de navegación:

```tsx filename="app/contexts/navigation-blocker.tsx" switcher
'use client'

import { createContext, useState, useContext } from 'react'

interface NavigationBlockerContextType {
  isBlocked: boolean
  setIsBlocked: (isBlocked: boolean) => void
}

export const NavigationBlockerContext =
  createContext<NavigationBlockerContextType>({
    isBlocked: false,
    setIsBlocked: () => {},
  })

export function NavigationBlockerProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

```jsx filename="app/contexts/navigation-blocker.js" switcher
'use client'

import { createContext, useState, useContext } from 'react'

export const NavigationBlockerContext = createContext({
  isBlocked: false,
  setIsBlocked: () => {},
})

export function NavigationBlockerProvider({ children }) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

Cree un componente de formulario que use el contexto:

```tsx filename="app/components/form.tsx" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

```jsx filename="app/components/form.js" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Save</button>
    </form>
  )
}
```

Cree un componente Link personalizado que bloquee la navegación:

```tsx filename="app/components/custom-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

interface CustomLinkProps extends React.ComponentProps<typeof Link> {
  children: React.ReactNode
}

export function CustomLink({ children, ...props }: CustomLinkProps) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('Tienes cambios sin guardar. ¿Salir de todas formas?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

```jsx filename="app/components/custom-link.js" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

export function CustomLink({ children, ...props }) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('Tienes cambios sin guardar. ¿Salir de todas formas?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

Cree un componente de navegación:

```tsx filename="app/components/nav.tsx" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

```jsx filename="app/components/nav.js" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
    </nav>
  )
}
```

Finalmente, envuelva su aplicación con el `NavigationBlockerProvider` en el layout raíz y use los componentes en su página:

```tsx filename="app/layout.tsx" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

Luego, use los componentes `Nav` y `Form` en su página:

```tsx filename="app/page.tsx" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Welcome to the Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

Cuando un usuario intente navegar usando `CustomLink` mientras el formulario tiene cambios sin guardar, se le pedirá confirmación antes de salir.

## Historial de versiones

| Versión   | Cambios                                                                                                                                                                      |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.3.0` | Se agregó API `onNavigate`                                                                                                                                                  |
| `v13.0.0` | Ya no requiere una etiqueta `<a>` hija. Se proporciona un [codemod](/docs/app/guides/upgrading/codemods#remove-a-tags-from-link-components) para actualizar automáticamente su código. |
| `v10.0.0` | Las props `href` que apuntan a una ruta dinámica se resuelven automáticamente y ya no requieren una prop `as`.                                                              |
| `v8.0.0`  | Mejora en el rendimiento del prefetching.                                                                                                                                    |
| `v1.0.0`  | Se introdujo `next/link`.                                                                                                                                                   |
