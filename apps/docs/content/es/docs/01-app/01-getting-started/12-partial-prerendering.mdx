---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:02:41.448Z
title: C√≥mo usar el Renderizado Parcial (Partial Prerendering)
nav_title: Renderizado Parcial
description: Aprende a combinar los beneficios del renderizado est√°tico y din√°mico con el Renderizado Parcial (Partial Prerendering).
version: experimental
related:
  title: Pr√≥ximos pasos
  description: M√°s informaci√≥n sobre la opci√≥n de configuraci√≥n para el Renderizado Parcial.
  links:
    - app/api-reference/config/next-config-js/ppr
---

El Renderizado Parcial (PPR) es una estrategia de renderizado que te permite combinar contenido est√°tico y din√°mico en la misma ruta. Esto mejora el rendimiento inicial de la p√°gina mientras sigue admitiendo datos personalizados y din√°micos.

<Image
  alt="P√°gina de producto con Renderizado Parcial mostrando navegaci√≥n est√°tica e informaci√≥n del producto, junto con carrito din√°mico y productos recomendados"
  srcLight="/learn/light/thinking-in-ppr.png"
  srcDark="/learn/dark/thinking-in-ppr.png"
  width="1600"
  height="632"
/>

Cuando un usuario visita una ruta:

- El servidor env√≠a un **shell** que contiene el contenido est√°tico, garantizando una carga inicial r√°pida.
- El shell deja **huecos** para el contenido din√°mico que se cargar√° de forma as√≠ncrona.
- Los huecos din√°micos se **transmiten en paralelo**, reduciendo el tiempo total de carga de la p√°gina.

> **üé• Ver:** Por qu√© PPR y c√≥mo funciona ‚Üí [YouTube (10 minutos)](https://www.youtube.com/watch?v=MTcPrTIBkpA).

## ¬øC√≥mo funciona el Renderizado Parcial?

Para entender el Renderizado Parcial, es √∫til familiarizarse con las estrategias de renderizado disponibles en Next.js.

### Renderizado Est√°tico

Con el Renderizado Est√°tico, el HTML se genera con anticipaci√≥n, ya sea en el momento de la construcci√≥n o mediante [revalidaci√≥n](/docs/app/guides/incremental-static-regeneration). El resultado se almacena en cach√© y se comparte entre usuarios y solicitudes.

En el Renderizado Parcial, Next.js prerrenderiza un **shell est√°tico** para una ruta. Esto puede incluir el dise√±o y cualquier otro componente que no dependa de datos en tiempo de solicitud.

### Renderizado Din√°mico

Con el Renderizado Din√°mico, el HTML se genera en **tiempo de solicitud**. Esto te permite servir contenido personalizado basado en datos en tiempo de solicitud.

Un componente se vuelve din√°mico si utiliza las siguientes APIs:

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [prop `searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)
- [`fetch`](/docs/app/api-reference/functions/fetch) con `{ cache: 'no-store' }`

En el Renderizado Parcial, el uso de estas APIs lanza un error especial de React que informa a Next.js que el componente no se puede renderizar est√°ticamente, causando un error de construcci√≥n. Puedes usar un l√≠mite de [Suspense](#suspense) para envolver tu componente y diferir el renderizado hasta el tiempo de ejecuci√≥n.

### Suspense

React [Suspense](https://react.dev/reference/react/Suspense) se utiliza para diferir el renderizado de partes de tu aplicaci√≥n hasta que se cumpla alguna condici√≥n.

En el Renderizado Parcial, Suspense se utiliza para marcar **l√≠mites din√°micos** en tu √°rbol de componentes.

En el momento de construcci√≥n, Next.js prerrenderiza el contenido est√°tico y la UI de `fallback`. El contenido din√°mico se **pospone** hasta que el usuario solicite la ruta.

Envolver un componente en Suspense no hace que el componente en s√≠ sea din√°mico (eso lo determina tu uso de APIs), sino que Suspense act√∫a como un l√≠mite que encapsula contenido din√°mico y habilita el [streaming](#streaming).

```jsx filename="app/page.js"
import { Suspense } from 'react'
import StaticComponent from './StaticComponent'
import DynamicComponent from './DynamicComponent'
import Fallback from './Fallback'

export const experimental_ppr = true

export default function Page() {
  return (
    <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
    </>
  )
}
```

### Streaming

El streaming divide la ruta en fragmentos y los transmite progresivamente al cliente a medida que est√°n listos. Esto permite que el usuario vea partes de la p√°gina inmediatamente, antes de que todo el contenido haya terminado de renderizarse.

<Image
  alt="Diagrama que muestra una p√°gina parcialmente renderizada en el cliente, con UI de carga para fragmentos que se est√°n transmitiendo."
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

En el Renderizado Parcial, los componentes din√°micos envueltos en Suspense comienzan a transmitirse desde el servidor en paralelo.

<Image
  alt="Diagrama que muestra la paralelizaci√≥n de segmentos de ruta durante el streaming, mostrando la obtenci√≥n de datos, renderizado e hidrataci√≥n de fragmentos individuales."
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Para reducir la sobrecarga de red, la respuesta completa, incluyendo el HTML est√°tico y las partes din√°micas transmitidas, se env√≠a en una **√∫nica solicitud HTTP**. Esto evita viajes adicionales y mejora tanto la carga inicial como el rendimiento general.

## Habilitar el Renderizado Parcial

Puedes habilitar PPR a√±adiendo la opci√≥n [`ppr`](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr) a tu archivo `next.config.ts`:

```ts filename="next.config.ts" highlight={5} switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

export default nextConfig
```

```js filename="next.config.js" highlight={4} switcher
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}
```

El valor `'incremental'` te permite adoptar PPR para rutas espec√≠ficas:

```tsx filename="/app/dashboard/layout.tsx"
export const experimental_ppr = true

export default function Layout({ children }: { children: React.ReactNode }) {
  // ...
}
```

```jsx filename="/app/dashboard/layout.js"
export const experimental_ppr = true

export default function Layout({ children }) {
  // ...
}
```

Las rutas que no tengan `experimental_ppr` tendr√°n como valor predeterminado `false` y no se prerrenderizar√°n usando PPR. Debes optar expl√≠citamente por PPR para cada ruta.

> **Nota importante**:
>
> - `experimental_ppr` se aplicar√° a todos los hijos del segmento de ruta, incluyendo dise√±os y p√°ginas anidadas. No es necesario a√±adirlo a cada archivo, solo al segmento superior de una ruta.
> - Para deshabilitar PPR en segmentos hijos, puedes establecer `experimental_ppr` en `false` en el segmento hijo.

## Ejemplos

### APIs Din√°micas

Cuando se usan APIs din√°micas que requieren examinar la solicitud entrante, Next.js optar√° por el renderizado din√°mico para la ruta. Para seguir usando PPR, envuelve el componente con Suspense. Por ejemplo, el componente `<User />` es din√°mico porque usa la API `cookies`:

```jsx filename="app/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

```tsx filename="app/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

El componente `<User />` se transmitir√° mientras que cualquier otro contenido dentro de `<Page />` se prerrenderizar√° y formar√° parte del shell est√°tico.

```tsx filename="app/page.tsx" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Esto se prerrenderizar√°</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Esto se prerrenderizar√°</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

### Pasar props din√°micas

Los componentes solo optan por el renderizado din√°mico cuando se accede al valor. Por ejemplo, si est√°s leyendo `searchParams` desde un componente `<Page />`, puedes reenviar este valor a otro componente como prop:

```tsx filename="app/page.tsx" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  return (
    <section>
      <h1>Esto se prerrenderizar√°</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({ searchParams }) {
  return (
    <section>
      <h1>Esto se prerrenderizar√°</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

Dentro del componente de tabla, acceder al valor de `searchParams` har√° que el componente sea din√°mico mientras que el resto de la p√°gina se prerrenderizar√°.

```tsx filename="app/table.tsx" switcher
export async function Table({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

```jsx filename="app/table.js" switcher
export async function Table({ searchParams }) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```