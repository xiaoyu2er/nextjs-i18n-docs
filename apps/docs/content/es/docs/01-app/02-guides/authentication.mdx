---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:27:51.167Z
title: C√≥mo implementar autenticaci√≥n en Next.js
nav_title: Autenticaci√≥n
description: Aprende a implementar autenticaci√≥n en tu aplicaci√≥n Next.js.
---

Comprender la autenticaci√≥n es crucial para proteger los datos de tu aplicaci√≥n. Esta p√°gina te guiar√° a trav√©s de las caracter√≠sticas de React y Next.js que puedes usar para implementar autenticaci√≥n.

Antes de comenzar, es √∫til dividir el proceso en tres conceptos:

1. **[Autenticaci√≥n](#authentication)**: Verifica si el usuario es quien dice ser. Requiere que el usuario demuestre su identidad con algo que conoce, como un nombre de usuario y contrase√±a.
2. **[Gesti√≥n de sesiones](#session-management)**: Realiza un seguimiento del estado de autenticaci√≥n del usuario entre solicitudes.
3. **[Autorizaci√≥n](#authorization)**: Decide qu√© rutas y datos puede acceder el usuario.

Este diagrama muestra el flujo de autenticaci√≥n usando caracter√≠sticas de React y Next.js:

<Image
  alt="Diagrama que muestra el flujo de autenticaci√≥n con caracter√≠sticas de React y Next.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

Los ejemplos en esta p√°gina explican una autenticaci√≥n b√°sica con nombre de usuario y contrase√±a con fines educativos. Si bien puedes implementar una soluci√≥n de autenticaci√≥n personalizada, para mayor seguridad y simplicidad, recomendamos usar una biblioteca de autenticaci√≥n. Estas ofrecen soluciones integradas para autenticaci√≥n, gesti√≥n de sesiones y autorizaci√≥n, adem√°s de caracter√≠sticas adicionales como inicios de sesi√≥n sociales, autenticaci√≥n multifactor y control de acceso basado en roles. Puedes encontrar una lista en la secci√≥n [Bibliotecas de autenticaci√≥n](#auth-libraries).

## Autenticaci√≥n

<AppOnly>

### Funcionalidad de registro e inicio de sesi√≥n

Puedes usar el elemento [`<form>`](https://react.dev/reference/react-dom/components/form) con las [Acciones de Servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) de React y `useActionState` para capturar credenciales de usuario, validar campos del formulario y llamar a la API o base de datos de tu Proveedor de Autenticaci√≥n.

Dado que las Acciones de Servidor siempre se ejecutan en el servidor, proporcionan un entorno seguro para manejar la l√≥gica de autenticaci√≥n.

Estos son los pasos para implementar la funcionalidad de registro/inicio de sesi√≥n:

#### 1. Capturar credenciales de usuario

Para capturar credenciales de usuario, crea un formulario que invoque una Acci√≥n de Servidor al enviarse. Por ejemplo, un formulario de registro que acepte el nombre, correo electr√≥nico y contrase√±a del usuario:

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      <div>
        <label htmlFor="email">Correo electr√≥nico</label>
        <input id="email" name="email" type="email" placeholder="Correo electr√≥nico" />
      </div>
      <div>
        <label htmlFor="password">Contrase√±a</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Registrarse</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      <div>
        <label htmlFor="email">Correo electr√≥nico</label>
        <input id="email" name="email" type="email" placeholder="Correo electr√≥nico" />
      </div>
      <div>
        <label htmlFor="password">Contrase√±a</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Registrarse</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. Validar campos del formulario en el servidor

Usa la Acci√≥n de Servidor para validar los campos del formulario en el servidor. Si tu proveedor de autenticaci√≥n no proporciona validaci√≥n de formularios, puedes usar una biblioteca de validaci√≥n de esquemas como [Zod](https://zod.dev/) o [Yup](https://github.com/jquense/yup).

Usando Zod como ejemplo, puedes definir un esquema de formulario con mensajes de error apropiados:

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'El nombre debe tener al menos 2 caracteres.' })
    .trim(),
  email: z.string().email({ message: 'Por favor ingresa un correo electr√≥nico v√°lido.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Debe tener al menos 8 caracteres' })
    .regex(/[a-zA-Z]/, { message: 'Debe contener al menos una letra.' })
    .regex(/[0-9]/, { message: 'Debe contener al menos un n√∫mero.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Debe contener al menos un car√°cter especial.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'El nombre debe tener al menos 2 caracteres.' })
    .trim(),
  email: z.string().email({ message: 'Por favor ingresa un correo electr√≥nico v√°lido.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Debe tener al menos 8 caracteres' })
    .regex(/[a-zA-Z]/, { message: 'Debe contener al menos una letra.' })
    .regex(/[0-9]/, { message: 'Debe contener al menos un n√∫mero.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Debe contener al menos un car√°cter especial.',
    })
    .trim(),
})
```

Para evitar llamadas innecesarias a la API o base de datos de tu proveedor de autenticaci√≥n, puedes hacer un `return` anticipado en la Acci√≥n de Servidor si alg√∫n campo del formulario no coincide con el esquema definido.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Validar campos del formulario
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si alg√∫n campo del formulario es inv√°lido, retornar anticipadamente
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Llamar al proveedor o base de datos para crear un usuario...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Validar campos del formulario
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si alg√∫n campo del formulario es inv√°lido, retornar anticipadamente
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Llamar al proveedor o base de datos para crear un usuario...
}
```

De vuelta en tu `<SignupForm />`, puedes usar el hook `useActionState` de React para mostrar errores de validaci√≥n mientras se env√≠a el formulario:

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Correo electr√≥nico</label>
        <input id="email" name="email" placeholder="Correo electr√≥nico" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Contrase√±a</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>La contrase√±a debe:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Registrarse
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Correo electr√≥nico</label>
        <input id="email" name="email" placeholder="Correo electr√≥nico" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Contrase√±a</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>La contrase√±a debe:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Registrarse
      </button>
    </form>
  )
}
```

> **Nota importante:**
>
> - En React 19, `useFormStatus` incluye claves adicionales en el objeto retornado, como data, method y action. Si no est√°s usando React 19, solo est√° disponible la clave `pending`.
> - Antes de mutar datos, siempre debes asegurarte de que un usuario tambi√©n est√© autorizado para realizar la acci√≥n. Consulta [Autenticaci√≥n y Autorizaci√≥n](#authorization).

#### 3. Crear un usuario o verificar credenciales

Despu√©s de validar los campos del formulario, puede crear una nueva cuenta de usuario o verificar si el usuario existe llamando a la API o base de datos de su proveedor de autenticaci√≥n.

Continuando con el ejemplo anterior:

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Validar campos del formulario
  // ...

  // 2. Preparar datos para inserci√≥n en la base de datos
  const { name, email, password } = validatedFields.data
  // Ejemplo: Hashear la contrase√±a antes de almacenarla
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insertar el usuario en la base de datos o llamar a la API de una biblioteca de autenticaci√≥n
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Ocurri√≥ un error al crear su cuenta.',
    }
  }

  // TODO:
  // 4. Crear sesi√≥n de usuario
  // 5. Redirigir al usuario
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Validar campos del formulario
  // ...

  // 2. Preparar datos para inserci√≥n en la base de datos
  const { name, email, password } = validatedFields.data
  // Ejemplo: Hashear la contrase√±a antes de almacenarla
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insertar el usuario en la base de datos o llamar a la API de una biblioteca
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Ocurri√≥ un error al crear su cuenta.',
    }
  }

  // TODO:
  // 4. Crear sesi√≥n de usuario
  // 5. Redirigir al usuario
}
```

Despu√©s de crear exitosamente la cuenta de usuario o verificar las credenciales, puede crear una sesi√≥n para manejar el estado de autenticaci√≥n del usuario. Dependiendo de su estrategia de gesti√≥n de sesiones, la sesi√≥n puede almacenarse en una cookie, base de datos o ambas. Contin√∫e a la secci√≥n [Gesti√≥n de Sesiones](#session-management) para aprender m√°s.

> **Consejos:**
>
> - El ejemplo anterior es detallado ya que desglosa los pasos de autenticaci√≥n con fines educativos. Esto resalta que implementar su propia soluci√≥n segura puede volverse complejo r√°pidamente. Considere usar una [Biblioteca de Autenticaci√≥n](#auth-libraries) para simplificar el proceso.
> - Para mejorar la experiencia del usuario, puede verificar correos electr√≥nicos o nombres de usuario duplicados antes en el flujo de registro. Por ejemplo, mientras el usuario escribe o cuando el campo de entrada pierde el foco. Esto puede evitar env√≠os innecesarios del formulario y proporcionar retroalimentaci√≥n inmediata al usuario. Puede controlar la frecuencia de estas verificaciones con bibliotecas como [use-debounce](https://www.npmjs.com/package/use-debounce).

</AppOnly>

<PagesOnly>

Estos son los pasos para implementar un formulario de registro y/o inicio de sesi√≥n:

1. El usuario env√≠a sus credenciales a trav√©s de un formulario.
2. El formulario env√≠a una solicitud manejada por una ruta API.
3. Tras la verificaci√≥n exitosa, se completa el proceso, indicando la autenticaci√≥n exitosa del usuario.
4. Si la verificaci√≥n falla, se muestra un mensaje de error.

Considere un formulario de inicio de sesi√≥n donde los usuarios pueden ingresar sus credenciales:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contrase√±a" required />
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  )
}
```

El formulario anterior tiene dos campos de entrada para capturar el correo electr√≥nico y la contrase√±a del usuario. Al enviarlo, se activa una funci√≥n que env√≠a una solicitud POST a una ruta API (`/api/auth/login`).

Luego puede llamar a la API de su Proveedor de Autenticaci√≥n en la ruta API para manejar la autenticaci√≥n:

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inv√°lidas.' })
    } else {
      res.status(500).json({ error: 'Algo sali√≥ mal.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inv√°lidas.' })
    } else {
      res.status(500).json({ error: 'Algo sali√≥ mal.' })
    }
  }
}
```

</PagesOnly>

## Gesti√≥n de Sesiones

La gesti√≥n de sesiones asegura que el estado autenticado del usuario se mantenga entre solicitudes. Incluye crear, almacenar, actualizar y eliminar sesiones o tokens.

Existen dos tipos de sesiones:

1. [**Sin estado (Stateless)**](#stateless-sessions): Los datos de la sesi√≥n (o un token) se almacenan en las cookies del navegador. La cookie se env√≠a con cada solicitud, permitiendo verificar la sesi√≥n en el servidor. Este m√©todo es m√°s simple, pero puede ser menos seguro si no se implementa correctamente.
2. [**Base de datos**](#database-sessions): Los datos de la sesi√≥n se almacenan en una base de datos, y el navegador del usuario solo recibe el ID de sesi√≥n encriptado. Este m√©todo es m√°s seguro, pero puede ser complejo y usar m√°s recursos del servidor.

> **Nota importante:** Aunque puede usar cualquiera de los m√©todos, o ambos, recomendamos usar una biblioteca de gesti√≥n de sesiones como [iron-session](https://github.com/vvo/iron-session) o [Jose](https://github.com/panva/jose).

### Sesiones sin estado (Stateless)

<AppOnly>

Para crear y gestionar sesiones sin estado, hay algunos pasos que debe seguir:

1. Generar una clave secreta, que se usar√° para firmar su sesi√≥n, y almacenarla como una [variable de entorno](/docs/app/guides/environment-variables).
2. Escribir l√≥gica para encriptar/desencriptar datos de sesi√≥n usando una biblioteca de gesti√≥n de sesiones.
3. Gestionar cookies usando la API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js.

Adem√°s de lo anterior, considere a√±adir funcionalidad para [actualizar (o refrescar)](#updating-or-refreshing-sessions) la sesi√≥n cuando el usuario regrese a la aplicaci√≥n, y [eliminar](#deleting-the-session) la sesi√≥n cuando el usuario cierre sesi√≥n.

> **Nota importante:** Verifique si su [biblioteca de autenticaci√≥n](#auth-libraries) incluye gesti√≥n de sesiones.

#### 1. Generar una clave secreta

Hay varias formas de generar una clave secreta para firmar su sesi√≥n. Por ejemplo, puede usar el comando `openssl` en su terminal:

```bash filename="terminal"
openssl rand -base64 32
```

Este comando genera una cadena aleatoria de 32 caracteres que puede usar como clave secreta y almacenar en su [archivo de variables de entorno](/docs/app/guides/environment-variables):

```bash filename=".env"
SESSION_SECRET=su_clave_secreta
```

Luego puede referenciar esta clave en su l√≥gica de gesti√≥n de sesiones:

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Encriptar y desencriptar sesiones

A continuaci√≥n, puede usar su [biblioteca de gesti√≥n de sesiones](#session-management-libraries) preferida para encriptar y desencriptar sesiones. Continuando con el ejemplo anterior, usaremos [Jose](https://www.npmjs.com/package/jose) (compatible con el [Edge Runtime](/docs/app/api-reference/edge)) y el paquete [`server-only`](https://www.npmjs.com/package/server-only) de React para asegurar que su l√≥gica de gesti√≥n de sesiones solo se ejecute en el servidor.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Error al verificar la sesi√≥n')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Error al verificar la sesi√≥n')
  }
}
```

> **Consejos:**
>
> - El payload debe contener los datos √∫nicos **m√≠nimos** del usuario que se usar√°n en solicitudes posteriores, como el ID del usuario, rol, etc. No debe contener informaci√≥n personal identificable como n√∫mero de tel√©fono, direcci√≥n de correo electr√≥nico, informaci√≥n de tarjetas de cr√©dito, etc., o datos sensibles como contrase√±as.

#### 3. Configurar cookies (opciones recomendadas)

Para almacenar la sesi√≥n en una cookie, use la API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js. La cookie debe configurarse en el servidor e incluir las opciones recomendadas:

- **HttpOnly**: Evita que JavaScript del lado del cliente acceda a la cookie.
- **Secure**: Usar https para enviar la cookie.
- **SameSite**: Especificar si la cookie puede enviarse con solicitudes entre sitios.
- **Max-Age o Expires**: Eliminar la cookie despu√©s de un per√≠odo determinado.
- **Path**: Definir la ruta URL para la cookie.

Consulte [MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Cookies) para m√°s informaci√≥n sobre cada una de estas opciones.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

En su Acci√≥n de Servidor, puede invocar la funci√≥n `createSession()` y usar la API [`redirect()`](/docs/app/guides/redirecting) para redirigir al usuario a la p√°gina apropiada:

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // Pasos previos:
  // 1. Validar campos del formulario
  // 2. Preparar datos para inserci√≥n en la base de datos
  // 3. Insertar el usuario en la base de datos o llamar a una API de biblioteca

  // Pasos actuales:
  // 4. Crear sesi√≥n de usuario
  await createSession(user.id)
  // 5. Redirigir al usuario
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // Pasos previos:
  // 1. Validar campos del formulario
  // 2. Preparar datos para inserci√≥n en la base de datos
  // 3. Insertar el usuario en la base de datos o llamar a una API de biblioteca

  // Pasos actuales:
  // 4. Crear sesi√≥n de usuario
  await createSession(user.id)
  // 5. Redirigir al usuario
  redirect('/profile')
}
```

> **Consejos:**
>
> - **Las cookies deben configurarse en el servidor** para evitar manipulaciones del lado del cliente.
> - üé• Ver: Aprenda m√°s sobre sesiones sin estado y autenticaci√≥n con Next.js ‚Üí [YouTube (11 minutos)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### Actualizar (o refrescar) sesiones

Tambi√©n puede extender el tiempo de expiraci√≥n de la sesi√≥n. Esto es √∫til para mantener al usuario conectado despu√©s de que acceda nuevamente a la aplicaci√≥n. Por ejemplo:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Consejo:** Verifique si su biblioteca de autenticaci√≥n admite tokens de actualizaci√≥n, que pueden usarse para extender la sesi√≥n del usuario.

#### Eliminar la sesi√≥n

Para eliminar la sesi√≥n, puede borrar la cookie:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

Luego puede reutilizar la funci√≥n `deleteSession()` en su aplicaci√≥n, por ejemplo, al cerrar sesi√≥n:

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### Configurar y eliminar cookies

Puede usar [Rutas API](/docs/pages/building-your-application/routing/api-routes) para establecer la sesi√≥n como una cookie en el servidor:

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

### Sesiones en base de datos

Para crear y administrar sesiones en base de datos, deber√° seguir estos pasos:

1. Crear una tabla en su base de datos para almacenar sesiones y datos (o verificar si su biblioteca de autenticaci√≥n maneja esto).
2. Implementar funcionalidad para insertar, actualizar y eliminar sesiones
3. Cifrar el ID de sesi√≥n antes de almacenarlo en el navegador del usuario, y asegurarse de que la base de datos y la cookie est√©n sincronizadas (esto es opcional, pero recomendado para verificaciones optimistas de autenticaci√≥n en [Middleware](#verificaciones-optimistas-con-middleware-opcional)).

<AppOnly>

Por ejemplo:

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Crear una sesi√≥n en la base de datos
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Devolver el ID de sesi√≥n
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Cifrar el ID de sesi√≥n
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Almacenar la sesi√≥n en cookies para verificaciones optimistas de autenticaci√≥n
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Crear una sesi√≥n en la base de datos
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Devolver el ID de sesi√≥n
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Cifrar el ID de sesi√≥n
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Almacenar la sesi√≥n en cookies para verificaciones optimistas de autenticaci√≥n
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Consejos**:
>
> - Para un acceso m√°s r√°pido, puede considerar agregar cach√© del servidor durante el tiempo de vida de la sesi√≥n. Tambi√©n puede mantener los datos de sesi√≥n en su base de datos principal y combinar solicitudes de datos para reducir el n√∫mero de consultas.
> - Puede optar por usar sesiones en base de datos para casos de uso m√°s avanzados, como realizar un seguimiento de la √∫ltima vez que un usuario inici√≥ sesi√≥n, o el n√∫mero de dispositivos activos, o dar a los usuarios la capacidad de cerrar sesi√≥n en todos los dispositivos.

Despu√©s de implementar la gesti√≥n de sesiones, deber√° agregar l√≥gica de autorizaci√≥n para controlar lo que los usuarios pueden acceder y hacer dentro de su aplicaci√≥n. Contin√∫e a la secci√≥n [Autorizaci√≥n](#autorizaci√≥n) para obtener m√°s informaci√≥n.

</AppOnly>

<PagesOnly>

**Crear una sesi√≥n en el servidor**:

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

## Autorizaci√≥n

Una vez que un usuario est√° autenticado y se crea una sesi√≥n, puede implementar autorizaci√≥n para controlar lo que el usuario puede acceder y hacer dentro de su aplicaci√≥n.

Hay dos tipos principales de verificaciones de autorizaci√≥n:

1. **Optimistas**: Verifican si el usuario est√° autorizado para acceder a una ruta o realizar una acci√≥n utilizando los datos de sesi√≥n almacenados en la cookie. Estas verificaciones son √∫tiles para operaciones r√°pidas, como mostrar/ocultar elementos de la interfaz de usuario o redirigir usuarios seg√∫n permisos o roles.
2. **Seguras**: Verifican si el usuario est√° autorizado para acceder a una ruta o realizar una acci√≥n utilizando los datos de sesi√≥n almacenados en la base de datos. Estas verificaciones son m√°s seguras y se utilizan para operaciones que requieren acceso a datos sensibles o acciones.

Para ambos casos, recomendamos:

- Crear una [Capa de Acceso a Datos (DAL)](#crear-una-capa-de-acceso-a-datos-dal) para centralizar su l√≥gica de autorizaci√≥n
- Usar [Objetos de Transferencia de Datos (DTO)](#usar-objetos-de-transferencia-de-datos-dto) para devolver solo los datos necesarios
- Opcionalmente usar [Middleware](#verificaciones-optimistas-con-middleware-opcional) para realizar verificaciones optimistas.

### Verificaciones optimistas con Middleware (Opcional)

Hay algunos casos en los que puede querer usar [Middleware](/docs/app/building-your-application/routing/middleware) y redirigir usuarios seg√∫n permisos:

- Para realizar verificaciones optimistas. Dado que Middleware se ejecuta en cada ruta, es una buena manera de centralizar la l√≥gica de redirecci√≥n y pre-filtrar usuarios no autorizados.
- Para proteger rutas est√°ticas que comparten datos entre usuarios (ej. contenido detr√°s de un muro de pago).

Sin embargo, dado que Middleware se ejecuta en cada ruta, incluidas las rutas [precargadas](/docs/app/getting-started/linking-and-navigating#prefetching), es importante solo leer la sesi√≥n de la cookie (verificaciones optimistas), y evitar verificaciones en la base de datos para prevenir problemas de rendimiento.

Por ejemplo:

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Especificar rutas protegidas y p√∫blicas
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. Verificar si la ruta actual es protegida o p√∫blica
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Descifrar la sesi√≥n de la cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Redirigir a /login si el usuario no est√° autenticado
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Redirigir a /dashboard si el usuario est√° autenticado
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Rutas en las que Middleware no deber√≠a ejecutarse
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Especificar rutas protegidas y p√∫blicas
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. Verificar si la ruta actual es protegida o p√∫blica
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Descifrar la sesi√≥n de la cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Redirigir a /login si el usuario no est√° autenticado
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Redirigir a /dashboard si el usuario est√° autenticado
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Rutas en las que Middleware no deber√≠a ejecutarse
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Si bien Middleware puede ser √∫til para verificaciones iniciales, no deber√≠a ser su √∫nica l√≠nea de defensa para proteger sus datos. La mayor√≠a de las verificaciones de seguridad deben realizarse lo m√°s cerca posible de su fuente de datos, consulte [Capa de Acceso a Datos](#crear-una-capa-de-acceso-a-datos-dal) para obtener m√°s informaci√≥n.

> **Consejos**:
>
> - En Middleware, tambi√©n puede leer cookies usando `req.cookies.get('session').value`.
> - Middleware usa el [Edge Runtime](/docs/app/api-reference/edge), verifique si su biblioteca de autenticaci√≥n y la biblioteca de gesti√≥n de sesiones son compatibles.
> - Puede usar la propiedad `matcher` en Middleware para especificar en qu√© rutas debe ejecutarse Middleware. Aunque, para autenticaci√≥n, se recomienda que Middleware se ejecute en todas las rutas.

<AppOnly>

### Crear una Capa de Acceso a Datos (DAL)

Recomendamos crear una DAL para centralizar sus solicitudes de datos y l√≥gica de autorizaci√≥n.

La DAL debe incluir una funci√≥n que verifique la sesi√≥n del usuario mientras interact√∫a con su aplicaci√≥n. Como m√≠nimo, la funci√≥n debe verificar si la sesi√≥n es v√°lida, luego redirigir o devolver la informaci√≥n del usuario necesaria para realizar m√°s solicitudes.

Por ejemplo, cree un archivo separado para su DAL que incluya una funci√≥n `verifySession()`. Luego use la API [cache](https://react.dev/reference/react/cache) de React para memorizar el valor de retorno de la funci√≥n durante un pase de renderizado de React:

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

Luego puede invocar la funci√≥n `verifySession()` en sus solicitudes de datos, Acciones del Servidor, Manejadores de Ruta:

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Devuelva expl√≠citamente las columnas que necesita en lugar de todo el objeto de usuario
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Devuelva expl√≠citamente las columnas que necesita en lugar de todo el objeto de usuario
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

> **Consejo**:
>
> - Una DAL puede usarse para proteger datos obtenidos en tiempo de solicitud. Sin embargo, para rutas est√°ticas que comparten datos entre usuarios, los datos se obtendr√°n en tiempo de compilaci√≥n y no en tiempo de solicitud. Use [Middleware](#verificaciones-optimistas-con-middleware-opcional) para proteger rutas est√°ticas.
> - Para verificaciones seguras, puede verificar si la sesi√≥n es v√°lida comparando el ID de sesi√≥n con su base de datos. Use la funci√≥n [cache](https://react.dev/reference/react/cache) de React para evitar solicitudes duplicadas innecesarias a la base de datos durante un pase de renderizado.
> - Puede consolidar solicitudes de datos relacionadas en una clase JavaScript que ejecute `verifySession()` antes de cualquier m√©todo.

### Uso de Objetos de Transferencia de Datos (DTO)

Al recuperar datos, se recomienda devolver solo la informaci√≥n necesaria que se utilizar√° en su aplicaci√≥n, y no objetos completos. Por ejemplo, si est√° obteniendo datos de usuario, podr√≠a devolver solo el ID y el nombre del usuario, en lugar del objeto de usuario completo que podr√≠a contener contrase√±as, n√∫meros de tel√©fono, etc.

Sin embargo, si no tiene control sobre la estructura de datos devuelta, o est√° trabajando en equipo y desea evitar que se pasen objetos completos al cliente, puede utilizar estrategias como especificar qu√© campos son seguros para exponer al cliente.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Devuelve columnas espec√≠ficas aqu√≠
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // O devuelve solo lo espec√≠fico para la consulta aqu√≠
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Devuelve columnas espec√≠ficas aqu√≠
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // O devuelve solo lo espec√≠fico para la consulta aqu√≠
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

Al centralizar sus solicitudes de datos y la l√≥gica de autorizaci√≥n en una DAL (Capa de Acceso a Datos) y utilizar DTOs, puede asegurarse de que todas las solicitudes de datos sean seguras y consistentes, facilitando el mantenimiento, auditor√≠a y depuraci√≥n a medida que su aplicaci√≥n crece.

> **Nota importante**:
>
> - Hay varias formas de definir un DTO, desde usar `toJSON()`, hasta funciones individuales como en el ejemplo anterior, o clases de JavaScript. Dado que estos son patrones de JavaScript y no una caracter√≠stica de React o Next.js, recomendamos investigar para encontrar el mejor patr√≥n para su aplicaci√≥n.
> - Obtenga m√°s informaci√≥n sobre las mejores pr√°cticas de seguridad en nuestro [art√≠culo sobre Seguridad en Next.js](/blog/security-nextjs-server-components-actions).

### Componentes del Servidor (Server Components)

Las verificaciones de autenticaci√≥n en [Componentes del Servidor](/docs/app/getting-started/server-and-client-components) son √∫tiles para el acceso basado en roles. Por ejemplo, para renderizar condicionalmente componentes seg√∫n el rol del usuario:

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // Asumiendo que 'role' es parte del objeto de sesi√≥n

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // Asumiendo que 'role' es parte del objeto de sesi√≥n

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

En el ejemplo, usamos la funci√≥n `verifySession()` de nuestra DAL para verificar los roles 'admin', 'user' y usuarios no autorizados. Este patr√≥n asegura que cada usuario interact√∫e solo con los componentes apropiados para su rol.

### Dise√±os (Layouts) y verificaciones de autenticaci√≥n

Debido al [Renderizado Parcial](/docs/app/getting-started/linking-and-navigating#client-side-transitions), tenga cuidado al realizar verificaciones en [Dise√±os](/docs/app/api-reference/file-conventions/layout), ya que estos no se vuelven a renderizar en la navegaci√≥n, lo que significa que la sesi√≥n del usuario no se verificar√° en cada cambio de ruta.

En su lugar, debe realizar las verificaciones cerca de su fuente de datos o del componente que se renderizar√° condicionalmente.

Por ejemplo, considere un dise√±o compartido que obtiene los datos del usuario y muestra la imagen del usuario en una navegaci√≥n. En lugar de realizar la verificaci√≥n de autenticaci√≥n en el dise√±o, debe obtener los datos del usuario (`getUser()`) en el dise√±o y realizar la verificaci√≥n de autenticaci√≥n en su DAL.

Esto garantiza que donde sea que se llame a `getUser()` dentro de su aplicaci√≥n, se realice la verificaci√≥n de autenticaci√≥n, y evita que los desarrolladores olviden verificar si el usuario est√° autorizado para acceder a los datos.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Obtener ID de usuario de la sesi√≥n y recuperar datos
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Obtener ID de usuario de la sesi√≥n y recuperar datos
})
```

> **Nota importante:**
>
> - Un patr√≥n com√∫n en SPAs es devolver `null` en un dise√±o o un componente de nivel superior si un usuario no est√° autorizado. Este patr√≥n **no se recomienda** ya que las aplicaciones de Next.js tienen m√∫ltiples puntos de entrada, lo que no evitar√° que se acceda a segmentos de ruta anidados y Acciones del Servidor.

### Acciones del Servidor (Server Actions)

Trate las [Acciones del Servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) con las mismas consideraciones de seguridad que los puntos finales de API p√∫blicos, y verifique si el usuario est√° autorizado para realizar una mutaci√≥n.

En el ejemplo a continuaci√≥n, verificamos el rol del usuario antes de permitir que la acci√≥n contin√∫e:

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Devuelve temprano si el usuario no est√° autorizado para realizar la acci√≥n
  if (userRole !== 'admin') {
    return null
  }

  // Procede con la acci√≥n para usuarios autorizados
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Devuelve temprano si el usuario no est√° autorizado para realizar la acci√≥n
  if (userRole !== 'admin') {
    return null
  }

  // Procede con la acci√≥n para usuarios autorizados
}
```

### Manejadores de Ruta (Route Handlers)

Trate los [Manejadores de Ruta](/docs/app/building-your-application/routing/route-handlers) con las mismas consideraciones de seguridad que los puntos finales de API p√∫blicos, y verifique si el usuario est√° autorizado para acceder al Manejador de Ruta.

Por ejemplo:

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Autenticaci√≥n del usuario y verificaci√≥n de rol
  const session = await verifySession()

  // Verifica si el usuario est√° autenticado
  if (!session) {
    // El usuario no est√° autenticado
    return new Response(null, { status: 401 })
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    // El usuario est√° autenticado pero no tiene los permisos adecuados
    return new Response(null, { status: 403 })
  }

  // Contin√∫a para usuarios autorizados
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Autenticaci√≥n del usuario y verificaci√≥n de rol
  const session = await verifySession()

  // Verifica si el usuario est√° autenticado
  if (!session) {
    // El usuario no est√° autenticado
    return new Response(null, { status: 401 })
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    // El usuario est√° autenticado pero no tiene los permisos adecuados
    return new Response(null, { status: 403 })
  }

  // Contin√∫a para usuarios autorizados
}
```

El ejemplo anterior muestra un Manejador de Ruta con una verificaci√≥n de seguridad de dos niveles. Primero verifica si hay una sesi√≥n activa y luego verifica si el usuario que inici√≥ sesi√≥n es un 'admin'.

## Proveedores de Contexto (Context Providers)

El uso de proveedores de contexto para autenticaci√≥n funciona gracias al [entrelazado](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). Sin embargo, el `context` de React no es compatible con los Componentes del Servidor, lo que los hace aplicables solo a los Componentes del Cliente.

Esto funciona, pero cualquier Componente del Servidor hijo se renderizar√° primero en el servidor y no tendr√° acceso a los datos de sesi√≥n del proveedor de contexto:

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

Si se necesitan datos de sesi√≥n en Componentes del Cliente (por ejemplo, para la obtenci√≥n de datos del lado del cliente), use la API [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) de React para evitar que los datos sensibles de la sesi√≥n se expongan al cliente.

</AppOnly>

<PagesOnly>

### Creaci√≥n de una Capa de Acceso a Datos (DAL)

#### Protecci√≥n de Rutas de API

Las Rutas de API en Next.js son esenciales para manejar la l√≥gica del lado del servidor y la gesti√≥n de datos. Es crucial asegurar estas rutas para garantizar que solo los usuarios autorizados puedan acceder a funcionalidades espec√≠ficas. Esto generalmente implica verificar el estado de autenticaci√≥n del usuario y sus permisos basados en roles.

Aqu√≠ hay un ejemplo de c√≥mo asegurar una Ruta de API:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Verifica si el usuario est√° autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no est√° autenticado',
    })
    return
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Procede con la ruta para usuarios autorizados
  // ... implementaci√≥n de la Ruta de API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Verifica si el usuario est√° autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no est√° autenticado',
    })
    return
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Procede con la ruta para usuarios autorizados
  // ... implementaci√≥n de la Ruta de API
}
```

Este ejemplo muestra una Ruta de API con una verificaci√≥n de seguridad de dos niveles para autenticaci√≥n y autorizaci√≥n. Primero verifica si hay una sesi√≥n activa y luego verifica si el usuario que inici√≥ sesi√≥n es un 'admin'. Este enfoque garantiza un acceso seguro, limitado a usuarios autenticados y autorizados, manteniendo una seguridad robusta para el procesamiento de solicitudes.

</PagesOnly>

## Recursos

Ahora que ha aprendido sobre autenticaci√≥n en Next.js, aqu√≠ hay bibliotecas compatibles con Next.js y recursos para ayudarle a implementar una autenticaci√≥n segura y gesti√≥n de sesiones:

### Bibliotecas de Autenticaci√≥n

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Bibliotecas de Gesti√≥n de Sesiones

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Lectura Adicional

Para continuar aprendiendo sobre autenticaci√≥n y seguridad, consulte los siguientes recursos:

- [C√≥mo pensar sobre seguridad en Next.js](/blog/security-nextjs-server-components-actions)
- [Entendiendo los Ataques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Entendiendo los Ataques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
