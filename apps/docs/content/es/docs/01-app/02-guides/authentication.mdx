---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:27:51.167Z
title: Cómo implementar autenticación en Next.js
nav_title: Autenticación
description: Aprende a implementar autenticación en tu aplicación Next.js.
---

Comprender la autenticación es crucial para proteger los datos de tu aplicación. Esta página te guiará a través de las características de React y Next.js que puedes usar para implementar autenticación.

Antes de comenzar, es útil dividir el proceso en tres conceptos:

1. **[Autenticación](#authentication)**: Verifica si el usuario es quien dice ser. Requiere que el usuario demuestre su identidad con algo que conoce, como un nombre de usuario y contraseña.
2. **[Gestión de sesiones](#session-management)**: Realiza un seguimiento del estado de autenticación del usuario entre solicitudes.
3. **[Autorización](#authorization)**: Decide qué rutas y datos puede acceder el usuario.

Este diagrama muestra el flujo de autenticación usando características de React y Next.js:

<Image
  alt="Diagrama que muestra el flujo de autenticación con características de React y Next.js"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

Los ejemplos en esta página explican una autenticación básica con nombre de usuario y contraseña con fines educativos. Si bien puedes implementar una solución de autenticación personalizada, para mayor seguridad y simplicidad, recomendamos usar una biblioteca de autenticación. Estas ofrecen soluciones integradas para autenticación, gestión de sesiones y autorización, además de características adicionales como inicios de sesión sociales, autenticación multifactor y control de acceso basado en roles. Puedes encontrar una lista en la sección [Bibliotecas de autenticación](#auth-libraries).

## Autenticación

<AppOnly>

### Funcionalidad de registro e inicio de sesión

Puedes usar el elemento [`<form>`](https://react.dev/reference/react-dom/components/form) con las [Acciones de Servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) de React y `useActionState` para capturar credenciales de usuario, validar campos del formulario y llamar a la API o base de datos de tu Proveedor de Autenticación.

Dado que las Acciones de Servidor siempre se ejecutan en el servidor, proporcionan un entorno seguro para manejar la lógica de autenticación.

Estos son los pasos para implementar la funcionalidad de registro/inicio de sesión:

#### 1. Capturar credenciales de usuario

Para capturar credenciales de usuario, crea un formulario que invoque una Acción de Servidor al enviarse. Por ejemplo, un formulario de registro que acepte el nombre, correo electrónico y contraseña del usuario:

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      <div>
        <label htmlFor="email">Correo electrónico</label>
        <input id="email" name="email" type="email" placeholder="Correo electrónico" />
      </div>
      <div>
        <label htmlFor="password">Contraseña</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Registrarse</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      <div>
        <label htmlFor="email">Correo electrónico</label>
        <input id="email" name="email" type="email" placeholder="Correo electrónico" />
      </div>
      <div>
        <label htmlFor="password">Contraseña</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Registrarse</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. Validar campos del formulario en el servidor

Usa la Acción de Servidor para validar los campos del formulario en el servidor. Si tu proveedor de autenticación no proporciona validación de formularios, puedes usar una biblioteca de validación de esquemas como [Zod](https://zod.dev/) o [Yup](https://github.com/jquense/yup).

Usando Zod como ejemplo, puedes definir un esquema de formulario con mensajes de error apropiados:

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'El nombre debe tener al menos 2 caracteres.' })
    .trim(),
  email: z.string().email({ message: 'Por favor ingresa un correo electrónico válido.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Debe tener al menos 8 caracteres' })
    .regex(/[a-zA-Z]/, { message: 'Debe contener al menos una letra.' })
    .regex(/[0-9]/, { message: 'Debe contener al menos un número.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Debe contener al menos un carácter especial.',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'El nombre debe tener al menos 2 caracteres.' })
    .trim(),
  email: z.string().email({ message: 'Por favor ingresa un correo electrónico válido.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Debe tener al menos 8 caracteres' })
    .regex(/[a-zA-Z]/, { message: 'Debe contener al menos una letra.' })
    .regex(/[0-9]/, { message: 'Debe contener al menos un número.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Debe contener al menos un carácter especial.',
    })
    .trim(),
})
```

Para evitar llamadas innecesarias a la API o base de datos de tu proveedor de autenticación, puedes hacer un `return` anticipado en la Acción de Servidor si algún campo del formulario no coincide con el esquema definido.

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // Validar campos del formulario
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si algún campo del formulario es inválido, retornar anticipadamente
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Llamar al proveedor o base de datos para crear un usuario...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // Validar campos del formulario
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // Si algún campo del formulario es inválido, retornar anticipadamente
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // Llamar al proveedor o base de datos para crear un usuario...
}
```

De vuelta en tu `<SignupForm />`, puedes usar el hook `useActionState` de React para mostrar errores de validación mientras se envía el formulario:

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Correo electrónico</label>
        <input id="email" name="email" placeholder="Correo electrónico" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Contraseña</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>La contraseña debe:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Registrarse
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">Nombre</label>
        <input id="name" name="name" placeholder="Nombre" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">Correo electrónico</label>
        <input id="email" name="email" placeholder="Correo electrónico" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">Contraseña</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>La contraseña debe:</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        Registrarse
      </button>
    </form>
  )
}
```

> **Nota importante:**
>
> - En React 19, `useFormStatus` incluye claves adicionales en el objeto retornado, como data, method y action. Si no estás usando React 19, solo está disponible la clave `pending`.
> - Antes de mutar datos, siempre debes asegurarte de que un usuario también esté autorizado para realizar la acción. Consulta [Autenticación y Autorización](#authorization).

#### 3. Crear un usuario o verificar credenciales

Después de validar los campos del formulario, puede crear una nueva cuenta de usuario o verificar si el usuario existe llamando a la API o base de datos de su proveedor de autenticación.

Continuando con el ejemplo anterior:

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. Validar campos del formulario
  // ...

  // 2. Preparar datos para inserción en la base de datos
  const { name, email, password } = validatedFields.data
  // Ejemplo: Hashear la contraseña antes de almacenarla
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insertar el usuario en la base de datos o llamar a la API de una biblioteca de autenticación
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Ocurrió un error al crear su cuenta.',
    }
  }

  // TODO:
  // 4. Crear sesión de usuario
  // 5. Redirigir al usuario
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. Validar campos del formulario
  // ...

  // 2. Preparar datos para inserción en la base de datos
  const { name, email, password } = validatedFields.data
  // Ejemplo: Hashear la contraseña antes de almacenarla
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. Insertar el usuario en la base de datos o llamar a la API de una biblioteca
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: 'Ocurrió un error al crear su cuenta.',
    }
  }

  // TODO:
  // 4. Crear sesión de usuario
  // 5. Redirigir al usuario
}
```

Después de crear exitosamente la cuenta de usuario o verificar las credenciales, puede crear una sesión para manejar el estado de autenticación del usuario. Dependiendo de su estrategia de gestión de sesiones, la sesión puede almacenarse en una cookie, base de datos o ambas. Continúe a la sección [Gestión de Sesiones](#session-management) para aprender más.

> **Consejos:**
>
> - El ejemplo anterior es detallado ya que desglosa los pasos de autenticación con fines educativos. Esto resalta que implementar su propia solución segura puede volverse complejo rápidamente. Considere usar una [Biblioteca de Autenticación](#auth-libraries) para simplificar el proceso.
> - Para mejorar la experiencia del usuario, puede verificar correos electrónicos o nombres de usuario duplicados antes en el flujo de registro. Por ejemplo, mientras el usuario escribe o cuando el campo de entrada pierde el foco. Esto puede evitar envíos innecesarios del formulario y proporcionar retroalimentación inmediata al usuario. Puede controlar la frecuencia de estas verificaciones con bibliotecas como [use-debounce](https://www.npmjs.com/package/use-debounce).

</AppOnly>

<PagesOnly>

Estos son los pasos para implementar un formulario de registro y/o inicio de sesión:

1. El usuario envía sus credenciales a través de un formulario.
2. El formulario envía una solicitud manejada por una ruta API.
3. Tras la verificación exitosa, se completa el proceso, indicando la autenticación exitosa del usuario.
4. Si la verificación falla, se muestra un mensaje de error.

Considere un formulario de inicio de sesión donde los usuarios pueden ingresar sus credenciales:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contraseña" required />
      <button type="submit">Iniciar sesión</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Manejar errores
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Contraseña" required />
      <button type="submit">Iniciar sesión</button>
    </form>
  )
}
```

El formulario anterior tiene dos campos de entrada para capturar el correo electrónico y la contraseña del usuario. Al enviarlo, se activa una función que envía una solicitud POST a una ruta API (`/api/auth/login`).

Luego puede llamar a la API de su Proveedor de Autenticación en la ruta API para manejar la autenticación:

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inválidas.' })
    } else {
      res.status(500).json({ error: 'Algo salió mal.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Credenciales inválidas.' })
    } else {
      res.status(500).json({ error: 'Algo salió mal.' })
    }
  }
}
```

</PagesOnly>

## Gestión de Sesiones

La gestión de sesiones asegura que el estado autenticado del usuario se mantenga entre solicitudes. Incluye crear, almacenar, actualizar y eliminar sesiones o tokens.

Existen dos tipos de sesiones:

1. [**Sin estado (Stateless)**](#stateless-sessions): Los datos de la sesión (o un token) se almacenan en las cookies del navegador. La cookie se envía con cada solicitud, permitiendo verificar la sesión en el servidor. Este método es más simple, pero puede ser menos seguro si no se implementa correctamente.
2. [**Base de datos**](#database-sessions): Los datos de la sesión se almacenan en una base de datos, y el navegador del usuario solo recibe el ID de sesión encriptado. Este método es más seguro, pero puede ser complejo y usar más recursos del servidor.

> **Nota importante:** Aunque puede usar cualquiera de los métodos, o ambos, recomendamos usar una biblioteca de gestión de sesiones como [iron-session](https://github.com/vvo/iron-session) o [Jose](https://github.com/panva/jose).

### Sesiones sin estado (Stateless)

<AppOnly>

Para crear y gestionar sesiones sin estado, hay algunos pasos que debe seguir:

1. Generar una clave secreta, que se usará para firmar su sesión, y almacenarla como una [variable de entorno](/docs/app/guides/environment-variables).
2. Escribir lógica para encriptar/desencriptar datos de sesión usando una biblioteca de gestión de sesiones.
3. Gestionar cookies usando la API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js.

Además de lo anterior, considere añadir funcionalidad para [actualizar (o refrescar)](#updating-or-refreshing-sessions) la sesión cuando el usuario regrese a la aplicación, y [eliminar](#deleting-the-session) la sesión cuando el usuario cierre sesión.

> **Nota importante:** Verifique si su [biblioteca de autenticación](#auth-libraries) incluye gestión de sesiones.

#### 1. Generar una clave secreta

Hay varias formas de generar una clave secreta para firmar su sesión. Por ejemplo, puede usar el comando `openssl` en su terminal:

```bash filename="terminal"
openssl rand -base64 32
```

Este comando genera una cadena aleatoria de 32 caracteres que puede usar como clave secreta y almacenar en su [archivo de variables de entorno](/docs/app/guides/environment-variables):

```bash filename=".env"
SESSION_SECRET=su_clave_secreta
```

Luego puede referenciar esta clave en su lógica de gestión de sesiones:

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. Encriptar y desencriptar sesiones

A continuación, puede usar su [biblioteca de gestión de sesiones](#session-management-libraries) preferida para encriptar y desencriptar sesiones. Continuando con el ejemplo anterior, usaremos [Jose](https://www.npmjs.com/package/jose) (compatible con el [Edge Runtime](/docs/app/api-reference/edge)) y el paquete [`server-only`](https://www.npmjs.com/package/server-only) de React para asegurar que su lógica de gestión de sesiones solo se ejecute en el servidor.

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Error al verificar la sesión')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('Error al verificar la sesión')
  }
}
```

> **Consejos:**
>
> - El payload debe contener los datos únicos **mínimos** del usuario que se usarán en solicitudes posteriores, como el ID del usuario, rol, etc. No debe contener información personal identificable como número de teléfono, dirección de correo electrónico, información de tarjetas de crédito, etc., o datos sensibles como contraseñas.

#### 3. Configurar cookies (opciones recomendadas)

Para almacenar la sesión en una cookie, use la API [`cookies`](/docs/app/api-reference/functions/cookies) de Next.js. La cookie debe configurarse en el servidor e incluir las opciones recomendadas:

- **HttpOnly**: Evita que JavaScript del lado del cliente acceda a la cookie.
- **Secure**: Usar https para enviar la cookie.
- **SameSite**: Especificar si la cookie puede enviarse con solicitudes entre sitios.
- **Max-Age o Expires**: Eliminar la cookie después de un período determinado.
- **Path**: Definir la ruta URL para la cookie.

Consulte [MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Cookies) para más información sobre cada una de estas opciones.

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

En su Acción de Servidor, puede invocar la función `createSession()` y usar la API [`redirect()`](/docs/app/guides/redirecting) para redirigir al usuario a la página apropiada:

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // Pasos previos:
  // 1. Validar campos del formulario
  // 2. Preparar datos para inserción en la base de datos
  // 3. Insertar el usuario en la base de datos o llamar a una API de biblioteca

  // Pasos actuales:
  // 4. Crear sesión de usuario
  await createSession(user.id)
  // 5. Redirigir al usuario
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // Pasos previos:
  // 1. Validar campos del formulario
  // 2. Preparar datos para inserción en la base de datos
  // 3. Insertar el usuario en la base de datos o llamar a una API de biblioteca

  // Pasos actuales:
  // 4. Crear sesión de usuario
  await createSession(user.id)
  // 5. Redirigir al usuario
  redirect('/profile')
}
```

> **Consejos:**
>
> - **Las cookies deben configurarse en el servidor** para evitar manipulaciones del lado del cliente.
> - 🎥 Ver: Aprenda más sobre sesiones sin estado y autenticación con Next.js → [YouTube (11 minutos)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

#### Actualizar (o refrescar) sesiones

También puede extender el tiempo de expiración de la sesión. Esto es útil para mantener al usuario conectado después de que acceda nuevamente a la aplicación. Por ejemplo:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Consejo:** Verifique si su biblioteca de autenticación admite tokens de actualización, que pueden usarse para extender la sesión del usuario.

#### Eliminar la sesión

Para eliminar la sesión, puede borrar la cookie:

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

Luego puede reutilizar la función `deleteSession()` en su aplicación, por ejemplo, al cerrar sesión:

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### Configurar y eliminar cookies

Puede usar [Rutas API](/docs/pages/building-your-application/routing/api-routes) para establecer la sesión como una cookie en el servidor:

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Una semana
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

### Sesiones en base de datos

Para crear y administrar sesiones en base de datos, deberá seguir estos pasos:

1. Crear una tabla en su base de datos para almacenar sesiones y datos (o verificar si su biblioteca de autenticación maneja esto).
2. Implementar funcionalidad para insertar, actualizar y eliminar sesiones
3. Cifrar el ID de sesión antes de almacenarlo en el navegador del usuario, y asegurarse de que la base de datos y la cookie estén sincronizadas (esto es opcional, pero recomendado para verificaciones optimistas de autenticación en [Middleware](#verificaciones-optimistas-con-middleware-opcional)).

<AppOnly>

Por ejemplo:

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Crear una sesión en la base de datos
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Devolver el ID de sesión
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Cifrar el ID de sesión
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Almacenar la sesión en cookies para verificaciones optimistas de autenticación
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. Crear una sesión en la base de datos
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // Devolver el ID de sesión
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. Cifrar el ID de sesión
  const session = await encrypt({ sessionId, expiresAt })

  // 3. Almacenar la sesión en cookies para verificaciones optimistas de autenticación
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **Consejos**:
>
> - Para un acceso más rápido, puede considerar agregar caché del servidor durante el tiempo de vida de la sesión. También puede mantener los datos de sesión en su base de datos principal y combinar solicitudes de datos para reducir el número de consultas.
> - Puede optar por usar sesiones en base de datos para casos de uso más avanzados, como realizar un seguimiento de la última vez que un usuario inició sesión, o el número de dispositivos activos, o dar a los usuarios la capacidad de cerrar sesión en todos los dispositivos.

Después de implementar la gestión de sesiones, deberá agregar lógica de autorización para controlar lo que los usuarios pueden acceder y hacer dentro de su aplicación. Continúe a la sección [Autorización](#autorización) para obtener más información.

</AppOnly>

<PagesOnly>

**Crear una sesión en el servidor**:

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

## Autorización

Una vez que un usuario está autenticado y se crea una sesión, puede implementar autorización para controlar lo que el usuario puede acceder y hacer dentro de su aplicación.

Hay dos tipos principales de verificaciones de autorización:

1. **Optimistas**: Verifican si el usuario está autorizado para acceder a una ruta o realizar una acción utilizando los datos de sesión almacenados en la cookie. Estas verificaciones son útiles para operaciones rápidas, como mostrar/ocultar elementos de la interfaz de usuario o redirigir usuarios según permisos o roles.
2. **Seguras**: Verifican si el usuario está autorizado para acceder a una ruta o realizar una acción utilizando los datos de sesión almacenados en la base de datos. Estas verificaciones son más seguras y se utilizan para operaciones que requieren acceso a datos sensibles o acciones.

Para ambos casos, recomendamos:

- Crear una [Capa de Acceso a Datos (DAL)](#crear-una-capa-de-acceso-a-datos-dal) para centralizar su lógica de autorización
- Usar [Objetos de Transferencia de Datos (DTO)](#usar-objetos-de-transferencia-de-datos-dto) para devolver solo los datos necesarios
- Opcionalmente usar [Middleware](#verificaciones-optimistas-con-middleware-opcional) para realizar verificaciones optimistas.

### Verificaciones optimistas con Middleware (Opcional)

Hay algunos casos en los que puede querer usar [Middleware](/docs/app/building-your-application/routing/middleware) y redirigir usuarios según permisos:

- Para realizar verificaciones optimistas. Dado que Middleware se ejecuta en cada ruta, es una buena manera de centralizar la lógica de redirección y pre-filtrar usuarios no autorizados.
- Para proteger rutas estáticas que comparten datos entre usuarios (ej. contenido detrás de un muro de pago).

Sin embargo, dado que Middleware se ejecuta en cada ruta, incluidas las rutas [precargadas](/docs/app/getting-started/linking-and-navigating#prefetching), es importante solo leer la sesión de la cookie (verificaciones optimistas), y evitar verificaciones en la base de datos para prevenir problemas de rendimiento.

Por ejemplo:

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Especificar rutas protegidas y públicas
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. Verificar si la ruta actual es protegida o pública
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Descifrar la sesión de la cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. Redirigir a /login si el usuario no está autenticado
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. Redirigir a /dashboard si el usuario está autenticado
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Rutas en las que Middleware no debería ejecutarse
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. Especificar rutas protegidas y públicas
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. Verificar si la ruta actual es protegida o pública
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. Descifrar la sesión de la cookie
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. Redirigir a /login si el usuario no está autenticado
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. Redirigir a /dashboard si el usuario está autenticado
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// Rutas en las que Middleware no debería ejecutarse
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Si bien Middleware puede ser útil para verificaciones iniciales, no debería ser su única línea de defensa para proteger sus datos. La mayoría de las verificaciones de seguridad deben realizarse lo más cerca posible de su fuente de datos, consulte [Capa de Acceso a Datos](#crear-una-capa-de-acceso-a-datos-dal) para obtener más información.

> **Consejos**:
>
> - En Middleware, también puede leer cookies usando `req.cookies.get('session').value`.
> - Middleware usa el [Edge Runtime](/docs/app/api-reference/edge), verifique si su biblioteca de autenticación y la biblioteca de gestión de sesiones son compatibles.
> - Puede usar la propiedad `matcher` en Middleware para especificar en qué rutas debe ejecutarse Middleware. Aunque, para autenticación, se recomienda que Middleware se ejecute en todas las rutas.

<AppOnly>

### Crear una Capa de Acceso a Datos (DAL)

Recomendamos crear una DAL para centralizar sus solicitudes de datos y lógica de autorización.

La DAL debe incluir una función que verifique la sesión del usuario mientras interactúa con su aplicación. Como mínimo, la función debe verificar si la sesión es válida, luego redirigir o devolver la información del usuario necesaria para realizar más solicitudes.

Por ejemplo, cree un archivo separado para su DAL que incluya una función `verifySession()`. Luego use la API [cache](https://react.dev/reference/react/cache) de React para memorizar el valor de retorno de la función durante un pase de renderizado de React:

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

Luego puede invocar la función `verifySession()` en sus solicitudes de datos, Acciones del Servidor, Manejadores de Ruta:

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Devuelva explícitamente las columnas que necesita en lugar de todo el objeto de usuario
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // Devuelva explícitamente las columnas que necesita en lugar de todo el objeto de usuario
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

> **Consejo**:
>
> - Una DAL puede usarse para proteger datos obtenidos en tiempo de solicitud. Sin embargo, para rutas estáticas que comparten datos entre usuarios, los datos se obtendrán en tiempo de compilación y no en tiempo de solicitud. Use [Middleware](#verificaciones-optimistas-con-middleware-opcional) para proteger rutas estáticas.
> - Para verificaciones seguras, puede verificar si la sesión es válida comparando el ID de sesión con su base de datos. Use la función [cache](https://react.dev/reference/react/cache) de React para evitar solicitudes duplicadas innecesarias a la base de datos durante un pase de renderizado.
> - Puede consolidar solicitudes de datos relacionadas en una clase JavaScript que ejecute `verifySession()` antes de cualquier método.

### Uso de Objetos de Transferencia de Datos (DTO)

Al recuperar datos, se recomienda devolver solo la información necesaria que se utilizará en su aplicación, y no objetos completos. Por ejemplo, si está obteniendo datos de usuario, podría devolver solo el ID y el nombre del usuario, en lugar del objeto de usuario completo que podría contener contraseñas, números de teléfono, etc.

Sin embargo, si no tiene control sobre la estructura de datos devuelta, o está trabajando en equipo y desea evitar que se pasen objetos completos al cliente, puede utilizar estrategias como especificar qué campos son seguros para exponer al cliente.

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Devuelve columnas específicas aquí
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // O devuelve solo lo específico para la consulta aquí
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // Devuelve columnas específicas aquí
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // O devuelve solo lo específico para la consulta aquí
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

Al centralizar sus solicitudes de datos y la lógica de autorización en una DAL (Capa de Acceso a Datos) y utilizar DTOs, puede asegurarse de que todas las solicitudes de datos sean seguras y consistentes, facilitando el mantenimiento, auditoría y depuración a medida que su aplicación crece.

> **Nota importante**:
>
> - Hay varias formas de definir un DTO, desde usar `toJSON()`, hasta funciones individuales como en el ejemplo anterior, o clases de JavaScript. Dado que estos son patrones de JavaScript y no una característica de React o Next.js, recomendamos investigar para encontrar el mejor patrón para su aplicación.
> - Obtenga más información sobre las mejores prácticas de seguridad en nuestro [artículo sobre Seguridad en Next.js](/blog/security-nextjs-server-components-actions).

### Componentes del Servidor (Server Components)

Las verificaciones de autenticación en [Componentes del Servidor](/docs/app/getting-started/server-and-client-components) son útiles para el acceso basado en roles. Por ejemplo, para renderizar condicionalmente componentes según el rol del usuario:

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // Asumiendo que 'role' es parte del objeto de sesión

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // Asumiendo que 'role' es parte del objeto de sesión

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

En el ejemplo, usamos la función `verifySession()` de nuestra DAL para verificar los roles 'admin', 'user' y usuarios no autorizados. Este patrón asegura que cada usuario interactúe solo con los componentes apropiados para su rol.

### Diseños (Layouts) y verificaciones de autenticación

Debido al [Renderizado Parcial](/docs/app/getting-started/linking-and-navigating#client-side-transitions), tenga cuidado al realizar verificaciones en [Diseños](/docs/app/api-reference/file-conventions/layout), ya que estos no se vuelven a renderizar en la navegación, lo que significa que la sesión del usuario no se verificará en cada cambio de ruta.

En su lugar, debe realizar las verificaciones cerca de su fuente de datos o del componente que se renderizará condicionalmente.

Por ejemplo, considere un diseño compartido que obtiene los datos del usuario y muestra la imagen del usuario en una navegación. En lugar de realizar la verificación de autenticación en el diseño, debe obtener los datos del usuario (`getUser()`) en el diseño y realizar la verificación de autenticación en su DAL.

Esto garantiza que donde sea que se llame a `getUser()` dentro de su aplicación, se realice la verificación de autenticación, y evita que los desarrolladores olviden verificar si el usuario está autorizado para acceder a los datos.

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Obtener ID de usuario de la sesión y recuperar datos
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // Obtener ID de usuario de la sesión y recuperar datos
})
```

> **Nota importante:**
>
> - Un patrón común en SPAs es devolver `null` en un diseño o un componente de nivel superior si un usuario no está autorizado. Este patrón **no se recomienda** ya que las aplicaciones de Next.js tienen múltiples puntos de entrada, lo que no evitará que se acceda a segmentos de ruta anidados y Acciones del Servidor.

### Acciones del Servidor (Server Actions)

Trate las [Acciones del Servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) con las mismas consideraciones de seguridad que los puntos finales de API públicos, y verifique si el usuario está autorizado para realizar una mutación.

En el ejemplo a continuación, verificamos el rol del usuario antes de permitir que la acción continúe:

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // Devuelve temprano si el usuario no está autorizado para realizar la acción
  if (userRole !== 'admin') {
    return null
  }

  // Procede con la acción para usuarios autorizados
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // Devuelve temprano si el usuario no está autorizado para realizar la acción
  if (userRole !== 'admin') {
    return null
  }

  // Procede con la acción para usuarios autorizados
}
```

### Manejadores de Ruta (Route Handlers)

Trate los [Manejadores de Ruta](/docs/app/building-your-application/routing/route-handlers) con las mismas consideraciones de seguridad que los puntos finales de API públicos, y verifique si el usuario está autorizado para acceder al Manejador de Ruta.

Por ejemplo:

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Autenticación del usuario y verificación de rol
  const session = await verifySession()

  // Verifica si el usuario está autenticado
  if (!session) {
    // El usuario no está autenticado
    return new Response(null, { status: 401 })
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    // El usuario está autenticado pero no tiene los permisos adecuados
    return new Response(null, { status: 403 })
  }

  // Continúa para usuarios autorizados
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // Autenticación del usuario y verificación de rol
  const session = await verifySession()

  // Verifica si el usuario está autenticado
  if (!session) {
    // El usuario no está autenticado
    return new Response(null, { status: 401 })
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    // El usuario está autenticado pero no tiene los permisos adecuados
    return new Response(null, { status: 403 })
  }

  // Continúa para usuarios autorizados
}
```

El ejemplo anterior muestra un Manejador de Ruta con una verificación de seguridad de dos niveles. Primero verifica si hay una sesión activa y luego verifica si el usuario que inició sesión es un 'admin'.

## Proveedores de Contexto (Context Providers)

El uso de proveedores de contexto para autenticación funciona gracias al [entrelazado](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components). Sin embargo, el `context` de React no es compatible con los Componentes del Servidor, lo que los hace aplicables solo a los Componentes del Cliente.

Esto funciona, pero cualquier Componente del Servidor hijo se renderizará primero en el servidor y no tendrá acceso a los datos de sesión del proveedor de contexto:

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

Si se necesitan datos de sesión en Componentes del Cliente (por ejemplo, para la obtención de datos del lado del cliente), use la API [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) de React para evitar que los datos sensibles de la sesión se expongan al cliente.

</AppOnly>

<PagesOnly>

### Creación de una Capa de Acceso a Datos (DAL)

#### Protección de Rutas de API

Las Rutas de API en Next.js son esenciales para manejar la lógica del lado del servidor y la gestión de datos. Es crucial asegurar estas rutas para garantizar que solo los usuarios autorizados puedan acceder a funcionalidades específicas. Esto generalmente implica verificar el estado de autenticación del usuario y sus permisos basados en roles.

Aquí hay un ejemplo de cómo asegurar una Ruta de API:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // Verifica si el usuario está autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no está autenticado',
    })
    return
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Procede con la ruta para usuarios autorizados
  // ... implementación de la Ruta de API
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // Verifica si el usuario está autenticado
  if (!session) {
    res.status(401).json({
      error: 'El usuario no está autenticado',
    })
    return
  }

  // Verifica si el usuario tiene el rol 'admin'
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Acceso no autorizado: El usuario no tiene privilegios de administrador.',
    })
    return
  }

  // Procede con la ruta para usuarios autorizados
  // ... implementación de la Ruta de API
}
```

Este ejemplo muestra una Ruta de API con una verificación de seguridad de dos niveles para autenticación y autorización. Primero verifica si hay una sesión activa y luego verifica si el usuario que inició sesión es un 'admin'. Este enfoque garantiza un acceso seguro, limitado a usuarios autenticados y autorizados, manteniendo una seguridad robusta para el procesamiento de solicitudes.

</PagesOnly>

## Recursos

Ahora que ha aprendido sobre autenticación en Next.js, aquí hay bibliotecas compatibles con Next.js y recursos para ayudarle a implementar una autenticación segura y gestión de sesiones:

### Bibliotecas de Autenticación

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Bibliotecas de Gestión de Sesiones

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## Lectura Adicional

Para continuar aprendiendo sobre autenticación y seguridad, consulte los siguientes recursos:

- [Cómo pensar sobre seguridad en Next.js](/blog/security-nextjs-server-components-actions)
- [Entendiendo los Ataques XSS](https://vercel.com/guides/understanding-xss-attacks)
- [Entendiendo los Ataques CSRF](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
