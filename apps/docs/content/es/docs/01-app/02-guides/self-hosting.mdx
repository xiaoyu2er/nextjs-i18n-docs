---
source-updated-at: 2025-06-08T05:18:05.000Z
translation-updated-at: 2025-06-08T21:21:06.805Z
title: C√≥mo autoalojar tu aplicaci√≥n Next.js
nav_title: Autoalojamiento
description: Aprende c√≥mo autoalojar tu aplicaci√≥n Next.js en un servidor Node.js, imagen Docker o archivos HTML est√°ticos (exportaciones est√°ticas).
---

{/* El contenido de este documento se comparte entre el enrutador de app y pages. Puedes usar el componente `<PagesOnly>Contenido</PagesOnly>` para a√±adir contenido espec√≠fico del Pages Router. Cualquier contenido compartido no debe estar envuelto en un componente. */}

Cuando [despliegues](/docs/app/getting-started/deploying) tu aplicaci√≥n Next.js, es posible que desees configurar c√≥mo se manejan diferentes caracter√≠sticas seg√∫n tu infraestructura.

> **üé• Ver:** Aprende m√°s sobre autoalojar Next.js ‚Üí [YouTube (45 minutos)](https://www.youtube.com/watch?v=sIVL4JMqRfc).

## Optimizaci√≥n de im√°genes

La [Optimizaci√≥n de im√°genes](/docs/app/api-reference/components/image) a trav√©s de `next/image` funciona con autoalojamiento sin configuraci√≥n cuando se despliega usando `next start`. Si prefieres tener un servicio separado para optimizar im√°genes, puedes [configurar un cargador de im√°genes](/docs/app/api-reference/components/image#loader).

La Optimizaci√≥n de im√°genes puede usarse con una [exportaci√≥n est√°tica](/docs/app/guides/static-exports#image-optimization) definiendo un cargador de im√°genes personalizado en `next.config.js`. Ten en cuenta que las im√°genes se optimizan en tiempo de ejecuci√≥n, no durante la construcci√≥n.

> **Es bueno saber:**
>
> - En sistemas Linux basados en glibc, la Optimizaci√≥n de im√°genes puede requerir [configuraci√≥n adicional](https://sharp.pixelplumbing.com/install#linux-memory-allocator) para evitar un uso excesivo de memoria.
> - Aprende m√°s sobre el [comportamiento de cach√© de im√°genes optimizadas](/docs/app/api-reference/components/image#minimumcachettl) y c√≥mo configurar el TTL.
> - Tambi√©n puedes [desactivar la Optimizaci√≥n de im√°genes](/docs/app/api-reference/components/image#unoptimized) y conservar otros beneficios de usar `next/image` si lo prefieres. Por ejemplo, si optimizas las im√°genes por separado.

## Middleware

El [Middleware](/docs/app/building-your-application/routing/middleware) funciona con autoalojamiento sin configuraci√≥n cuando se despliega usando `next start`. Como requiere acceso a la solicitud entrante, no es compatible cuando se usa una [exportaci√≥n est√°tica](/docs/app/guides/static-exports).

El Middleware usa el [runtime Edge](/docs/app/api-reference/edge), un subconjunto de todas las APIs de Node.js disponibles para ayudar a garantizar baja latencia, ya que puede ejecutarse antes de cada ruta o recurso en tu aplicaci√≥n. Si no deseas esto, puedes usar el [runtime completo de Node.js](/blog/next-15-2#nodejs-middleware-experimental) para ejecutar Middleware.

Si buscas a√±adir l√≥gica (o usar un paquete externo) que requiera todas las APIs de Node.js, podr√≠as mover esta l√≥gica a un [layout](/docs/app/api-reference/file-conventions/layout) como un [Componente de Servidor](/docs/app/getting-started/server-and-client-components). Por ejemplo, verificando [headers](/docs/app/api-reference/functions/headers) y [redireccionando](/docs/app/api-reference/functions/redirect). Tambi√©n puedes usar headers, cookies o par√°metros de consulta para [redireccionar](/docs/app/api-reference/config/next-config-js/redirects#header-cookie-and-query-matching) o [reescribir](/docs/app/api-reference/config/next-config-js/rewrites#header-cookie-and-query-matching) a trav√©s de `next.config.js`. Si eso no funciona, tambi√©n puedes usar un [servidor personalizado](/docs/pages/guides/custom-server).

## Variables de entorno

Next.js puede soportar variables de entorno tanto en tiempo de construcci√≥n como en tiempo de ejecuci√≥n.

**Por defecto, las variables de entorno solo est√°n disponibles en el servidor**. Para exponer una variable de entorno al navegador, debe tener el prefijo `NEXT_PUBLIC_`. Sin embargo, estas variables p√∫blicas se incluir√°n en el paquete JavaScript durante `next build`.

<PagesOnly>

Para leer variables de entorno en tiempo de ejecuci√≥n, recomendamos usar `getServerSideProps` o [adoptar incrementalmente el App Router](/docs/app/guides/migrating/app-router-migration).

</PagesOnly>

<AppOnly>

Puedes leer variables de entorno de forma segura en el servidor durante el renderizado din√°mico.

```tsx filename="app/page.ts" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers y otras APIs din√°micas
  // tambi√©n optar√°n por renderizado din√°mico, lo que significa
  // que esta variable de entorno se eval√∫a en tiempo de ejecuci√≥n
  const value = process.env.MY_VALUE
  // ...
}
```

```jsx filename="app/page.js" switcher
import { connection } from 'next/server'

export default async function Component() {
  await connection()
  // cookies, headers y otras APIs din√°micas
  // tambi√©n optar√°n por renderizado din√°mico, lo que significa
  // que esta variable de entorno se eval√∫a en tiempo de ejecuci√≥n
  const value = process.env.MY_VALUE
  // ...
}
```

</AppOnly>

Esto te permite usar una √∫nica imagen Docker que puede promoverse a trav√©s de m√∫ltiples entornos con diferentes valores.

> **Es bueno saber:**
>
> - Puedes ejecutar c√≥digo al iniciar el servidor usando la [funci√≥n `register`](/docs/app/guides/instrumentation).
> - No recomendamos usar la opci√≥n [runtimeConfig](/docs/pages/api-reference/config/next-config-js/runtime-configuration), ya que no funciona con el modo de salida independiente. En su lugar, recomendamos [adoptar incrementalmente](/docs/app/guides/migrating/app-router-migration) el App Router.

## Cach√© e ISR

Next.js puede almacenar en cach√© respuestas, p√°ginas est√°ticas generadas, salidas de construcci√≥n y otros recursos est√°ticos como im√°genes, fuentes y scripts.

El almacenamiento en cach√© y la revalidaci√≥n de p√°ginas (con [Regeneraci√≥n Est√°tica Incremental](/docs/app/guides/incremental-static-regeneration)) usan la **misma cach√© compartida**. Por defecto, esta cach√© se almacena en el sistema de archivos (en disco) en tu servidor Next.js. **Esto funciona autom√°ticamente con autoalojamiento** usando tanto el Pages Router como el App Router.

Puedes configurar la ubicaci√≥n de la cach√© de Next.js si deseas persistir p√°ginas y datos en cach√© en almacenamiento duradero, o compartir la cach√© entre m√∫ltiples contenedores o instancias de tu aplicaci√≥n Next.js.

### Cach√© autom√°tica

- Next.js establece el header `Cache-Control` como `public, max-age=31536000, immutable` para recursos verdaderamente inmutables. No puede ser sobrescrito. Estos archivos inmutables contienen un hash SHA en el nombre del archivo, por lo que pueden almacenarse en cach√© indefinidamente. Por ejemplo, [Importaciones de im√°genes est√°ticas](/docs/app/getting-started/images#local-images). Puedes [configurar el TTL](/docs/app/api-reference/components/image#minimumcachettl) para im√°genes.
- La Regeneraci√≥n Est√°tica Incremental (ISR) establece el header `Cache-Control` como `s-maxage: <revalidate in getStaticProps>, stale-while-revalidate`. Este tiempo de revalidaci√≥n se define en tu [funci√≥n `getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) en segundos. Si estableces `revalidate: false`, por defecto tendr√° una duraci√≥n de cach√© de un a√±o.
- Las p√°ginas renderizadas din√°micamente establecen un header `Cache-Control` como `private, no-cache, no-store, max-age=0, must-revalidate` para evitar que se almacenen en cach√© datos espec√≠ficos del usuario. Esto aplica tanto al App Router como al Pages Router. Esto tambi√©n incluye [Modo Borrador](/docs/app/guides/draft-mode).

### Recursos est√°ticos

Si deseas alojar recursos est√°ticos en un dominio o CDN diferente, puedes usar la configuraci√≥n `assetPrefix` en `next.config.js`. Next.js usar√° este prefijo de recurso al recuperar archivos JavaScript o CSS. Separar tus recursos a un dominio diferente tiene la desventaja de tiempo adicional en la resoluci√≥n DNS y TLS.

[Aprende m√°s sobre `assetPrefix`](/docs/app/api-reference/config/next-config-js/assetPrefix).

### Configuraci√≥n de la cach√©

Por defecto, los recursos de cach√© generados se almacenar√°n en memoria (por defecto 50mb) y en disco. Si est√°s alojando Next.js usando una plataforma de orquestaci√≥n de contenedores como Kubernetes, cada pod tendr√° una copia de la cach√©. Para evitar que se muestren datos obsoletos ya que la cach√© no se comparte entre pods por defecto, puedes configurar la cach√© de Next.js para proporcionar un manejador de cach√© y desactivar el almacenamiento en memoria.

Para configurar la ubicaci√≥n de la cach√© ISR/Data cuando autoalojas, puedes configurar un manejador personalizado en tu archivo `next.config.js`:

```jsx filename="next.config.js"
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // desactivar cach√© en memoria por defecto
}
```

Luego, crea `cache-handler.js` en la ra√≠z de tu proyecto, por ejemplo:

```jsx filename="cache-handler.js"
const cache = new Map()

module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }

  async get(key) {
    // Esto podr√≠a almacenarse en cualquier lugar, como almacenamiento duradero
    return cache.get(key)
  }

  async set(key, data, ctx) {
    // Esto podr√≠a almacenarse en cualquier lugar, como almacenamiento duradero
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }

  async revalidateTag(tags) {
    // tags es un string o un array de strings
    tags = [tags].flat()
    // Iterar sobre todas las entradas en la cach√©
    for (let [key, value] of cache) {
      // Si los tags del valor incluyen el tag especificado, eliminar esta entrada
      if (value.tags.some((tag) => tags.includes(tag))) {
        cache.delete(key)
      }
    }
  }

  // Si deseas tener cach√© temporal en memoria para una sola solicitud que se reinicia
  // antes de la siguiente solicitud, puedes aprovechar este m√©todo
  resetRequestCache() {}
}
```

Usar un manejador de cach√© personalizado te permitir√° garantizar consistencia entre todos los pods que alojan tu aplicaci√≥n Next.js. Por ejemplo, puedes guardar los valores en cach√© en cualquier lugar, como [Redis](https://github.com/vercel/next.js/tree/canary/examples/cache-handler-redis) o AWS S3.

> **Es bueno saber:**
>
> - `revalidatePath` es una capa de conveniencia sobre los tags de cach√©. Llamar a `revalidatePath` llamar√° a la funci√≥n `revalidateTag` con un tag especial por defecto para la p√°gina proporcionada.

## Cach√© de construcci√≥n

Next.js genera un ID durante `next build` para identificar qu√© versi√≥n de tu aplicaci√≥n se est√° sirviendo. La misma construcci√≥n debe usarse e iniciarse en m√∫ltiples contenedores.

Si est√°s reconstruyendo para cada etapa de tu entorno, necesitar√°s generar un ID de construcci√≥n consistente para usar entre contenedores. Usa el comando `generateBuildId` en `next.config.js`:

```jsx filename="next.config.js"
module.exports = {
  generateBuildId: async () => {
    // Esto podr√≠a ser cualquier cosa, usando el √∫ltimo hash git
    return process.env.GIT_HASH
  },
}
```

## Desfase de versi√≥n

Next.js mitigar√° autom√°ticamente la mayor√≠a de los casos de [desfase de versi√≥n](https://www.industrialempathy.com/posts/version-skew/) y recargar√° autom√°ticamente la aplicaci√≥n para recuperar nuevos recursos cuando se detecte. Por ejemplo, si hay una discrepancia en el `deploymentId`, las transiciones entre p√°ginas realizar√°n una navegaci√≥n dura versus usar un valor precargado.

Cuando la aplicaci√≥n se recarga, puede haber una p√©rdida del estado de la aplicaci√≥n si no est√° dise√±ado para persistir entre navegaciones de p√°gina. Por ejemplo, usar el estado de la URL o almacenamiento local persistir√≠a el estado despu√©s de una recarga de p√°gina. Sin embargo, el estado del componente como `useState` se perder√≠a en tales navegaciones.

<AppOnly>

## Streaming y Suspense

El App Router de Next.js soporta [respuestas en streaming](/docs/app/api-reference/file-conventions/loading) con autoalojamiento. Si est√°s usando Nginx o un proxy similar, necesitar√°s configurarlo para desactivar el buffering y permitir streaming.

Por ejemplo, puedes desactivar buffering en Nginx estableciendo `X-Accel-Buffering` como `no`:

```js filename="next.config.js"
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*{/}?',
        headers: [
          {
            key: 'X-Accel-Buffering',
            value: 'no',
          },
        ],
      },
    ]
  },
}
```

## Prerenderizado parcial

[Prerenderizado parcial (experimental)](/docs/app/getting-started/partial-prerendering) funciona por defecto con Next.js y no es una caracter√≠stica exclusiva de CDN. Esto incluye despliegue como servidor Node.js (a trav√©s de `next start`) y cuando se usa con un contenedor Docker.

## Uso con CDNs

Cuando usas un CDN delante de tu aplicaci√≥n Next.js, la p√°gina incluir√° el header de respuesta `Cache-Control: private` cuando se accede a APIs din√°micas. Esto asegura que la p√°gina HTML resultante se marque como no almacenable en cach√©. Si la p√°gina est√° completamente prerenderizada a est√°tico, incluir√° `Cache-Control: public` para permitir que la p√°gina se almacene en cach√© en el CDN.

Si no necesitas una mezcla de componentes est√°ticos y din√°micos, puedes hacer que toda tu ruta sea est√°tica y almacenar en cach√© el HTML resultante en un CDN. Esta Optimizaci√≥n Est√°tica Autom√°tica es el comportamiento por defecto al ejecutar `next build` si no se usan APIs din√°micas.

A medida que el Prerenderizado parcial se estabilice, proporcionaremos soporte a trav√©s de la API de Deployment Adapters.

</AppOnly>

<AppOnly>

## `after`

[`after`](/docs/app/api-reference/functions/after) es totalmente compatible con autoalojamiento usando `next start`.

Al detener el servidor, asegura un apagado elegante enviando se√±ales `SIGINT` o `SIGTERM` y esperando. Esto permite que el servidor Next.js espere hasta que las funciones de callback pendientes o promesas usadas dentro de `after` hayan terminado.

</AppOnly>

<PagesOnly>

## Apagados elegantes manuales

Con autoalojamiento, es posible que desees ejecutar c√≥digo cuando el servidor se apague con se√±ales `SIGTERM` o `SIGINT`.

Puedes establecer la variable de entorno `NEXT_MANUAL_SIG_HANDLE` como `true` y luego registrar un manejador para esa se√±al dentro de tu archivo `_document.js`. Necesitar√°s registrar la variable de entorno directamente en el script `package.json`, no en el archivo `.env`.

> **Es bueno saber**: El manejo manual de se√±ales no est√° disponible en `next dev`.

```json filename="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

```js filename="pages/_document.js"
if (process.env.NEXT_MANUAL_SIG_HANDLE) {
  process.on('SIGTERM', () => {
    console.log('Recibido SIGTERM: limpiando')
    process.exit(0)
  })
  process.on('SIGINT', () => {
    console.log('Recibido SIGINT: limpiando')
    process.exit(0)
  })
}
```

</PagesOnly>