---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:04:00.122Z
title: Caché en Next.js
nav_title: Caché
description: Una visión general de los mecanismos de caché en Next.js.
---

Next.js mejora el rendimiento de tu aplicación y reduce costos almacenando en caché el trabajo de renderizado y las solicitudes de datos. Esta página ofrece un análisis detallado de los mecanismos de caché de Next.js, las APIs que puedes usar para configurarlos y cómo interactúan entre sí.

> **Es bueno saberlo**: Esta página te ayuda a entender cómo funciona Next.js internamente, pero **no** es conocimiento esencial para ser productivo con Next.js. La mayoría de las heurísticas de caché de Next.js están determinadas por tu uso de API y tienen configuraciones predeterminadas para el mejor rendimiento con cero o mínima configuración. Si prefieres ir directamente a ejemplos, [comienza aquí](/docs/app/getting-started/fetching-data).

## Visión general

Aquí tienes una visión general de alto nivel de los diferentes mecanismos de caché y su propósito:

| Mecanismo                                   | Qué almacena            | Dónde  | Propósito                                       | Duración                        |
| ------------------------------------------- | ----------------------- | ------ | ----------------------------------------------- | ------------------------------- |
| [Memoización de solicitudes](#request-memoization) | Valores de retorno de funciones | Servidor | Reutilizar datos en un árbol de componentes React | Ciclo de vida por solicitud      |
| [Caché de datos](#data-cache)               | Datos                   | Servidor | Almacenar datos entre solicitudes de usuarios y despliegues | Persistente (puede revalidarse) |
| [Caché de ruta completa](#full-route-cache) | HTML y carga útil RSC   | Servidor | Reducir costos de renderizado y mejorar rendimiento | Persistente (puede revalidarse) |
| [Caché del enrutador](#client-side-router-cache) | Carga útil RSC          | Cliente | Reducir solicitudes al servidor en navegación   | Sesión de usuario o por tiempo  |

Por defecto, Next.js almacenará en caché tanto como sea posible para mejorar el rendimiento y reducir costos. Esto significa que las rutas se renderizan **estáticamente** y las solicitudes de datos se **almacenan en caché** a menos que decidas lo contrario. El diagrama a continuación muestra el comportamiento predeterminado del caché: cuando una ruta se renderiza estáticamente en tiempo de construcción y cuando se visita por primera vez una ruta estática.

<Image
  alt="Diagrama que muestra el comportamiento predeterminado del caché en Next.js para los cuatro mecanismos, con HIT, MISS y SET en tiempo de construcción y cuando una ruta se visita por primera vez."
  srcLight="/docs/light/caching-overview.png"
  srcDark="/docs/dark/caching-overview.png"
  width="1600"
  height="1179"
/>

El comportamiento del caché cambia dependiendo de si la ruta se renderiza estática o dinámicamente, si los datos están en caché o no, y si una solicitud es parte de una visita inicial o una navegación posterior. Dependiendo de tu caso de uso, puedes configurar el comportamiento del caché para rutas individuales y solicitudes de datos.

## Memoización de solicitudes

Next.js extiende la API [`fetch`](#fetch) para **memoizar** automáticamente solicitudes que tienen la misma URL y opciones. Esto significa que puedes llamar a una función fetch para los mismos datos en múltiples lugares de un árbol de componentes React mientras solo se ejecuta una vez.

<Image
  alt="Solicitudes Fetch deduplicadas"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

Por ejemplo, si necesitas usar los mismos datos a lo largo de una ruta (ej. en un Layout, Página y múltiples componentes), no tienes que obtener los datos en la parte superior del árbol y pasar props entre componentes. En su lugar, puedes obtener datos en los componentes que los necesitan sin preocuparte por las implicaciones de rendimiento de hacer múltiples solicitudes a la red por los mismos datos.

```tsx filename="app/example.tsx" switcher
async function getItem() {
  // La función `fetch` se memoiza automáticamente y el resultado
  // se almacena en caché
  const res = await fetch('https://.../item/1')
  return res.json()
}

// Esta función se llama dos veces, pero solo se ejecuta la primera vez
const item = await getItem() // cache MISS

// La segunda llamada podría estar en cualquier parte de tu ruta
const item = await getItem() // cache HIT
```

```jsx filename="app/example.js" switcher
async function getItem() {
  // La función `fetch` se memoiza automáticamente y el resultado
  // se almacena en caché
  const res = await fetch('https://.../item/1')
  return res.json()
}

// Esta función se llama dos veces, pero solo se ejecuta la primera vez
const item = await getItem() // cache MISS

// La segunda llamada podría estar en cualquier parte de tu ruta
const item = await getItem() // cache HIT
```

**Cómo funciona la memoización de solicitudes**

<Image
  alt="Diagrama que muestra cómo funciona la memoización de fetch durante el renderizado de React."
  srcLight="/docs/light/request-memoization.png"
  srcDark="/docs/dark/request-memoization.png"
  width="1600"
  height="742"
/>

- Al renderizar una ruta, la primera vez que se llama a una solicitud particular, su resultado no estará en memoria y será un `MISS` del caché.
- Por lo tanto, la función se ejecutará, los datos se obtendrán de la fuente externa, y el resultado se almacenará en memoria.
- Las llamadas posteriores a la función de la misma solicitud en el mismo pase de renderizado serán un `HIT` del caché, y los datos se devolverán desde la memoria sin ejecutar la función.
- Una vez que la ruta se ha renderizado y el pase de renderizado ha terminado, la memoria se "reinicia" y todas las entradas de memoización de solicitudes se borran.

> **Es bueno saberlo**:
>
> - La memoización de solicitudes es una característica de React, no de Next.js. Se incluye aquí para mostrar cómo interactúa con otros mecanismos de caché.
> - La memoización solo se aplica al método `GET` en solicitudes `fetch`.
> - La memoización solo se aplica al árbol de componentes React, esto significa:
>   - Se aplica a solicitudes `fetch` en `generateMetadata`, `generateStaticParams`, Layouts, Pages y otros Server Components.
>   - No se aplica a solicitudes `fetch` en Route Handlers ya que no son parte del árbol de componentes React.
> - Para casos donde `fetch` no es adecuado (ej. algunos clientes de bases de datos, CMS o GraphQL), puedes usar la [función `cache` de React](#react-cache-function) para memoizar funciones.

### Duración

El caché dura el tiempo de vida de una solicitud al servidor hasta que el árbol de componentes React ha terminado de renderizarse.

### Revalidación

Dado que la memoización no se comparte entre solicitudes al servidor y solo se aplica durante el renderizado, no es necesario revalidarla.

### Desactivación

La memoización solo se aplica al método `GET` en solicitudes `fetch`, otros métodos como `POST` y `DELETE` no se memoizan. Este comportamiento predeterminado es una optimización de React y no recomendamos desactivarlo.

Para gestionar solicitudes individuales, puedes usar la propiedad [`signal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal) de [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController). Sin embargo, esto no desactivará la memoización de las solicitudes, sino que abortará las solicitudes en curso.

```js filename="app/example.js"
const { signal } = new AbortController()
fetch(url, { signal })
```

## Caché de datos

Next.js tiene un Caché de datos incorporado que **persiste** el resultado de las obtenciones de datos entre **solicitudes al servidor** y **despliegues**. Esto es posible porque Next.js extiende la API nativa `fetch` para permitir que cada solicitud en el servidor establezca su propia semántica de caché persistente.

> **Es bueno saberlo**: En el navegador, la opción `cache` de `fetch` indica cómo una solicitud interactuará con el caché HTTP del navegador, en Next.js, la opción `cache` indica cómo una solicitud del lado del servidor interactuará con el Caché de datos del servidor.

Puedes usar las opciones [`cache`](#fetch-optionscache) y [`next.revalidate`](#fetch-optionsnextrevalidate) de `fetch` para configurar el comportamiento del caché.

**Cómo funciona el Caché de datos**

<Image
  alt="Diagrama que muestra cómo las solicitudes fetch en caché y sin caché interactúan con el Caché de datos. Las solicitudes en caché se almacenan en el Caché de datos y se memoizan, las solicitudes sin caché se obtienen de la fuente de datos, no se almacenan en el Caché de datos y se memoizan."
  srcLight="/docs/light/data-cache.png"
  srcDark="/docs/dark/data-cache.png"
  width="1600"
  height="661"
/>

- La primera vez que se llama a una solicitud `fetch` con la opción `'force-cache'` durante el renderizado, Next.js verifica el Caché de datos para una respuesta en caché.
- Si se encuentra una respuesta en caché, se devuelve inmediatamente y se [memoiza](#request-memoization).
- Si no se encuentra una respuesta en caché, se realiza la solicitud a la fuente de datos, el resultado se almacena en el Caché de datos y se memoiza.
- Para datos sin caché (ej. sin opción `cache` definida o usando `{ cache: 'no-store' }`), el resultado siempre se obtiene de la fuente de datos y se memoiza.
- Ya sea que los datos estén en caché o no, las solicitudes siempre se memoizan para evitar hacer solicitudes duplicadas por los mismos datos durante un pase de renderizado de React.

> **Diferencias entre el Caché de datos y la Memoización de solicitudes**
>
> Aunque ambos mecanismos de caché ayudan a mejorar el rendimiento reutilizando datos en caché, el Caché de datos es persistente entre solicitudes entrantes y despliegues, mientras que la memoización solo dura el tiempo de vida de una solicitud.

### Duración

El Caché de datos es persistente entre solicitudes entrantes y despliegues a menos que lo revalides o lo desactives.

### Revalidación

Los datos en caché se pueden revalidar de dos maneras, con:

- **Revalidación basada en tiempo**: Revalida datos después de que ha pasado cierta cantidad de tiempo y se hace una nueva solicitud. Esto es útil para datos que cambian con poca frecuencia y la frescura no es tan crítica.
- **Revalidación bajo demanda**: Revalida datos basados en un evento (ej. envío de un formulario). La revalidación bajo demanda puede usar un enfoque basado en etiquetas o rutas para revalidar grupos de datos a la vez. Esto es útil cuando quieres asegurarte de que se muestren los datos más recientes lo antes posible (ej. cuando se actualiza contenido de tu CMS headless).

#### Revalidación basada en tiempo

Para revalidar datos en intervalos de tiempo, puedes usar la opción `next.revalidate` de `fetch` para establecer el tiempo de vida del caché de un recurso (en segundos).

```js
// Revalida como máximo cada hora
fetch('https://...', { next: { revalidate: 3600 } })
```

Alternativamente, puedes usar [opciones de configuración de segmentos de ruta](#segment-config-options) para configurar todas las solicitudes `fetch` en un segmento o para casos donde no puedas usar `fetch`.

**Cómo funciona la revalidación basada en tiempo**

<Image
  alt="Diagrama que muestra cómo funciona la revalidación basada en tiempo, después del período de revalidación, se devuelven datos obsoletos para la primera solicitud, luego los datos se revalidan."
  srcLight="/docs/light/time-based-revalidation.png"
  srcDark="/docs/dark/time-based-revalidation.png"
  width="1600"
  height="1252"
/>

- La primera vez que se llama a una solicitud fetch con `revalidate`, los datos se obtendrán de la fuente de datos externa y se almacenarán en el Caché de datos.
- Cualquier solicitud que se llame dentro del período de tiempo especificado (ej. 60 segundos) devolverá los datos en caché.
- Después del período de tiempo, la siguiente solicitud aún devolverá los datos en caché (ahora obsoletos).
  - Next.js activará una revalidación de los datos en segundo plano.
  - Una vez que los datos se obtengan exitosamente, Next.js actualizará el Caché de datos con los datos frescos.
  - Si la revalidación en segundo plano falla, se mantendrán los datos anteriores sin cambios.

Esto es similar al comportamiento [**stale-while-revalidate**](https://web.dev/articles/stale-while-revalidate).

#### Revalidación bajo demanda

Los datos se pueden revalidar bajo demanda por ruta ([`revalidatePath`](#revalidatepath)) o por etiqueta de caché ([`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)).

**Cómo funciona la revalidación bajo demanda**

<Image
  alt="Diagrama que muestra cómo funciona la revalidación bajo demanda, el Caché de datos se actualiza con datos frescos después de una solicitud de revalidación."
  srcLight="/docs/light/on-demand-revalidation.png"
  srcDark="/docs/dark/on-demand-revalidation.png"
  width="1600"
  height="1082"
/>

- La primera vez que se llama a una solicitud `fetch`, los datos se obtendrán de la fuente de datos externa y se almacenarán en el Caché de datos.
- Cuando se activa una revalidación bajo demanda, las entradas de caché apropiadas se purgarán del caché.
  - Esto es diferente a la revalidación basada en tiempo, que mantiene los datos obsoletos en el caché hasta que se obtienen los datos frescos.
- La próxima vez que se haga una solicitud, será un `MISS` del caché nuevamente, y los datos se obtendrán de la fuente de datos externa y se almacenarán en el Caché de datos.

### Desactivación

Si _no_ quieres almacenar en caché la respuesta de `fetch`, puedes hacer lo siguiente:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

## Caché de ruta completa

> **Términos relacionados**:
>
> Puedes ver los términos **Optimización Estática Automática**, **Generación de Sitios Estáticos** o **Renderizado Estático** usados indistintamente para referirse al proceso de renderizar y almacenar en caché rutas de tu aplicación en tiempo de construcción.

Next.js renderiza y almacena en caché rutas automáticamente en tiempo de construcción. Esta es una optimización que te permite servir la ruta en caché en lugar de renderizar en el servidor para cada solicitud, resultando en tiempos de carga de página más rápidos.

Para entender cómo funciona el Caché de ruta completa, es útil ver cómo React maneja el renderizado y cómo Next.js almacena en caché el resultado:

### 1. Renderizado de React en el servidor

En el servidor, Next.js usa las APIs de React para orquestar el renderizado. El trabajo de renderizado se divide en fragmentos: por segmentos de ruta individuales y límites de Suspense.

Cada fragmento se renderiza en dos pasos:

1. React renderiza Server Components en un formato de datos especial optimizado para streaming, llamado **React Server Component Payload**.
2. Next.js usa el React Server Component Payload y las instrucciones JavaScript de Client Components para renderizar **HTML** en el servidor.

Esto significa que no tenemos que esperar a que todo se renderice antes de almacenar en caché el trabajo o enviar una respuesta. En su lugar, podemos transmitir una respuesta a medida que se completa el trabajo.

> **¿Qué es el React Server Component Payload?**
>
> El React Server Component Payload es una representación binaria compacta del árbol de React Server Components renderizado. Lo usa React en el cliente para actualizar el DOM del navegador. El React Server Component Payload contiene:
>
> - El resultado renderizado de Server Components
> - Marcadores de posición para dónde deberían renderizarse Client Components y referencias a sus archivos JavaScript
> - Cualquier prop pasado de un Server Component a un Client Component
>
> Para aprender más, consulta la documentación de [Server Components](/docs/app/getting-started/server-and-client-components).

### 2. Almacenamiento en caché de Next.js en el servidor (Caché de ruta completa)

<Image
  alt="Comportamiento predeterminado del Caché de ruta completa, mostrando cómo el React Server Component Payload y HTML se almacenan en caché en el servidor para rutas renderizadas estáticamente."
  srcLight="/docs/light/full-route-cache.png"
  srcDark="/docs/dark/full-route-cache.png"
  width="1600"
  height="888"
/>

El comportamiento predeterminado de Next.js es almacenar en caché el resultado renderizado (React Server Component Payload y HTML) de una ruta en el servidor. Esto se aplica a rutas renderizadas estáticamente en tiempo de construcción, o durante la revalidación.

### 3. Hidratación y reconciliación de React en el cliente

En el momento de la solicitud, en el cliente:

1. El HTML se usa para mostrar inmediatamente una vista previa rápida no interactiva inicial de los Client y Server Components.
2. El React Server Components Payload se usa para reconciliar los árboles de Client y Server Components renderizados, y actualizar el DOM.
3. Las instrucciones JavaScript se usan para [hidratar](https://react.dev/reference/react-dom/client/hydrateRoot) los Client Components y hacer la aplicación interactiva.

### 4. Almacenamiento en caché de Next.js en el cliente (Caché del enrutador)

El React Server Component Payload se almacena en el [Caché del enrutador](#client-side-router-cache) del lado del cliente - un caché en memoria separado, dividido por segmentos de ruta individuales. Este Caché del enrutador se usa para mejorar la experiencia de navegación almacenando rutas visitadas previamente y prefetching rutas futuras.

### 5. Navegaciones posteriores

En navegaciones posteriores o durante el prefetching, Next.js verificará si el React Server Components Payload está almacenado en el Caché del enrutador. Si es así, omitirá enviar una nueva solicitud al servidor.

Si los segmentos de ruta no están en el caché, Next.js obtendrá el React Server Components Payload desde el servidor y poblará el Caché del enrutador en el cliente.

### Renderizado estático y dinámico

Si una ruta se almacena en caché o no en el momento de la compilación depende de si se renderiza estática o dinámicamente. Las rutas estáticas se almacenan en caché por defecto, mientras que las rutas dinámicas se renderizan en el momento de la solicitud y no se almacenan en caché.

Este diagrama muestra la diferencia entre rutas renderizadas estática y dinámicamente, con datos en caché y no en caché:

<Image
  alt="Cómo el renderizado estático y dinámico afecta a la caché de ruta completa. Las rutas estáticas se almacenan en caché en el momento de la compilación o después de la revalidación de datos, mientras que las rutas dinámicas nunca se almacenan en caché"
  srcLight="/docs/light/static-and-dynamic-routes.png"
  srcDark="/docs/dark/static-and-dynamic-routes.png"
  width="1600"
  height="1314"
/>

Aprende más sobre [renderizado estático y dinámico](/docs/app/getting-started/partial-prerendering#static-rendering).

### Duración

Por defecto, la caché de ruta completa es persistente. Esto significa que el resultado del renderizado se almacena en caché entre solicitudes de usuarios.

### Invalidación

Hay dos formas de invalidar la caché de ruta completa:

- **[Revalidando datos](/docs/app/deep-dive/caching#revalidating)**: Revalidar la [caché de datos](#data-cache) invalidará a su vez la caché del enrutador al volver a renderizar los componentes en el servidor y almacenar en caché el nuevo resultado del renderizado.
- **Nueva implementación**: A diferencia de la caché de datos, que persiste entre implementaciones, la caché de ruta completa se borra en nuevas implementaciones.

### Optar por no usar

Puedes optar por no usar la caché de ruta completa, o en otras palabras, renderizar dinámicamente componentes para cada solicitud entrante, mediante:

- **Usar una [API dinámica](#dynamic-apis)**: Esto excluirá la ruta de la caché de ruta completa y la renderizará dinámicamente en el momento de la solicitud. La caché de datos aún puede usarse.
- **Usar las opciones de configuración de segmento de ruta `dynamic = 'force-dynamic'` o `revalidate = 0`**: Esto omitirá la caché de ruta completa y la caché de datos. Esto significa que los componentes se renderizarán y los datos se obtendrán en cada solicitud entrante al servidor. La caché del enrutador seguirá aplicándose ya que es una caché del lado del cliente.
- **Optar por no usar la [caché de datos](#data-cache)**: Si una ruta tiene una solicitud `fetch` que no está en caché, esto excluirá la ruta de la caché de ruta completa. Los datos para la solicitud `fetch` específica se obtendrán para cada solicitud entrante. Otras solicitudes `fetch` que no opten por no usar la caché seguirán almacenándose en la caché de datos. Esto permite una combinación de datos en caché y no en caché.

## Caché del enrutador del lado del cliente

Next.js tiene una caché de enrutador del lado del cliente en memoria que almacena la carga útil RSC de segmentos de ruta, divididos por diseños, estados de carga y páginas.

Cuando un usuario navega entre rutas, Next.js almacena en caché los segmentos de ruta visitados y [precarga](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) las rutas a las que es probable que el usuario navegue. Esto resulta en una navegación instantánea hacia atrás/adelante, sin recarga completa de la página entre navegaciones, y preservación del estado de React y del estado del navegador.

Con la caché del enrutador:

- **Los diseños** se almacenan en caché y se reutilizan en la navegación ([renderizado parcial](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)).
- **Los estados de carga** se almacenan en caché y se reutilizan en la navegación para [navegación instantánea](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states).
- **Las páginas** no se almacenan en caché por defecto, pero se reutilizan durante la navegación hacia atrás y adelante en el navegador. Puedes habilitar el almacenamiento en caché para segmentos de página usando la opción de configuración experimental [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes).

{/* TODO: Actualizar diagrama para que coincida con el comportamiento de v15 */}

> **Es bueno saber:** Esta caché se aplica específicamente a Next.js y a los componentes del servidor, y es diferente a la [bfcache](https://web.dev/bfcache/) del navegador, aunque tiene un resultado similar.

### Duración

La caché se almacena en la memoria temporal del navegador. Dos factores determinan cuánto dura la caché del enrutador:

- **Sesión**: La caché persiste entre navegaciones. Sin embargo, se borra al actualizar la página.
- **Período de invalidación automática**: La caché de diseños y estados de carga se invalida automáticamente después de un tiempo específico. La duración depende de cómo se [precargó](/docs/app/api-reference/components/link#prefetch) el recurso y si el recurso fue [generado estáticamente](/docs/app/getting-started/partial-prerendering#static-rendering):
  - **Precarga predeterminada** (`prefetch={null}` o no especificado): no se almacena en caché para páginas dinámicas, 5 minutos para páginas estáticas.
  - **Precarga completa** (`prefetch={true}` o `router.prefetch`): 5 minutos tanto para páginas estáticas como dinámicas.

Mientras que una actualización de página borrará **todos** los segmentos en caché, el período de invalidación automática solo afecta al segmento individual desde el momento en que se precargó.

> **Es bueno saber**: La opción de configuración experimental [`staleTimes`](/docs/app/api-reference/config/next-config-js/staleTimes) se puede usar para ajustar los tiempos de invalidación automática mencionados anteriormente.

### Invalidación

Hay dos formas de invalidar la caché del enrutador:

- En una **acción del servidor**:
  - Revalidar datos bajo demanda por ruta con ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)) o por etiqueta de caché con ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag))
  - Usar [`cookies.set`](/docs/app/api-reference/functions/cookies#setting-a-cookie) o [`cookies.delete`](/docs/app/api-reference/functions/cookies#deleting-cookies) invalida la caché del enrutador para evitar que las rutas que usan cookies se vuelvan obsoletas (por ejemplo, autenticación).
- Llamar a [`router.refresh`](/docs/app/api-reference/functions/use-router) invalidará la caché del enrutador y hará una nueva solicitud al servidor para la ruta actual.

### Optar por no usar

A partir de Next.js 15, los segmentos de página están excluidos por defecto.

> **Es bueno saber:** También puedes optar por no usar la [precarga](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) estableciendo la propiedad `prefetch` del componente `<Link>` en `false`.

## Interacciones de caché

Al configurar los diferentes mecanismos de caché, es importante entender cómo interactúan entre sí:

### Caché de datos y caché de ruta completa

- Revalidar o optar por no usar la caché de datos **invalidará** la caché de ruta completa, ya que el resultado del renderizado depende de los datos.
- Invalidar o optar por no usar la caché de ruta completa **no afecta** la caché de datos. Puedes renderizar dinámicamente una ruta que tenga tanto datos en caché como no en caché. Esto es útil cuando la mayor parte de tu página usa datos en caché, pero tienes algunos componentes que dependen de datos que deben obtenerse en el momento de la solicitud. Puedes renderizar dinámicamente sin preocuparte por el impacto en el rendimiento de volver a obtener todos los datos.

### Caché de datos y caché del enrutador del lado del cliente

- Para invalidar inmediatamente la caché de datos y la caché del enrutador, puedes usar [`revalidatePath`](#revalidatepath) o [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag) en una [acción del servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations).
- Revalidar la caché de datos en un [manejador de ruta](/docs/app/building-your-application/routing/route-handlers) **no invalidará** inmediatamente la caché del enrutador, ya que el manejador de ruta no está vinculado a una ruta específica. Esto significa que la caché del enrutador seguirá sirviendo la carga útil anterior hasta que se realice una actualización completa o haya transcurrido el período de invalidación automática.

## APIs

La siguiente tabla proporciona un resumen de cómo diferentes APIs de Next.js afectan el almacenamiento en caché:

| API                                                                     | Caché del enrutador       | Caché de ruta completa | Caché de datos        | Caché de React |
| ----------------------------------------------------------------------- | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                              | Almacena en caché          |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                    | Almacena en caché          |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                      | Revalida                  |                       |                       |             |
| [`fetch`](#fetch)                                                       |                            |                       | Almacena en caché     | Almacena en caché |
| [`fetch` `options.cache`](#fetch-optionscache)                          |                            |                       | Almacena en caché o excluye |             |
| [`fetch` `options.next.revalidate`](#fetch-optionsnextrevalidate)       |                            | Revalida              | Revalida              |             |
| [`fetch` `options.next.tags`](#fetch-optionsnexttags-and-revalidatetag) |                            | Almacena en caché     | Almacena en caché     |             |
| [`revalidateTag`](#fetch-optionsnexttags-and-revalidatetag)             | Revalida (acción del servidor) | Revalida              | Revalida              |             |
| [`revalidatePath`](#revalidatepath)                                     | Revalida (acción del servidor) | Revalida              | Revalida              |             |
| [`const revalidate`](#segment-config-options)                           |                            | Revalida o excluye    | Revalida o excluye    |             |
| [`const dynamic`](#segment-config-options)                              |                            | Almacena en caché o excluye | Almacena en caché o excluye |             |
| [`cookies`](#cookies)                                                   | Revalida (acción del servidor) | Excluye               |                       |             |
| [`headers`, `searchParams`](#dynamic-apis)                              |                            | Excluye               |                       |             |
| [`generateStaticParams`](#generatestaticparams)                         |                            | Almacena en caché     |                       |             |
| [`React.cache`](#react-cache-function)                                  |                            |                       |                       | Almacena en caché |
| [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)    |                            |                       | Almacena en caché     |             |

### `<Link>`

Por defecto, el componente `<Link>` precarga automáticamente rutas de la caché de ruta completa y agrega la carga útil del componente del servidor React a la caché del enrutador.

Para deshabilitar la precarga, puedes establecer la propiedad `prefetch` en `false`. Pero esto no omitirá la caché permanentemente, el segmento de ruta seguirá almacenándose en caché en el lado del cliente cuando el usuario visite la ruta.

Aprende más sobre el [componente `<Link>`](/docs/app/api-reference/components/link).

### `router.prefetch`

La opción `prefetch` del hook `useRouter` se puede usar para precargar manualmente una ruta. Esto agrega la carga útil del componente del servidor React a la caché del enrutador.

Consulta la referencia de la API del [hook `useRouter`](/docs/app/api-reference/functions/use-router).

### `router.refresh`

La opción `refresh` del hook `useRouter` se puede usar para actualizar manualmente una ruta. Esto borra completamente la caché del enrutador y hace una nueva solicitud al servidor para la ruta actual. `refresh` no afecta la caché de datos ni la caché de ruta completa.

El resultado renderizado se reconciliará en el cliente mientras se preserva el estado de React y el estado del navegador.

Consulta la referencia de la API del [hook `useRouter`](/docs/app/api-reference/functions/use-router).

### `fetch`

Los datos devueltos por `fetch` no se almacenan automáticamente en la caché de datos.

El comportamiento predeterminado de almacenamiento en caché de `fetch` (por ejemplo, cuando no se especifica la opción `cache`) es igual a establecer la opción `cache` en `no-store`:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

Consulta la [referencia de la API de `fetch`](/docs/app/api-reference/functions/fetch) para más opciones.

### `fetch options.cache`

Puedes optar por almacenar en caché individualmente `fetch` estableciendo la opción `cache` en `force-cache`:

```jsx
// Optar por almacenar en caché
fetch(`https://...`, { cache: 'force-cache' })
```

Consulta la [referencia de la API de `fetch`](/docs/app/api-reference/functions/fetch) para más opciones.

### `fetch options.next.revalidate`

Puedes usar la opción `next.revalidate` de `fetch` para establecer el período de revalidación (en segundos) de una solicitud `fetch` individual. Esto revalidará la caché de datos, que a su vez revalidará la caché de ruta completa. Se obtendrán datos frescos y los componentes se volverán a renderizar en el servidor.

```jsx
// Revalidar como máximo después de 1 hora
fetch(`https://...`, { next: { revalidate: 3600 } })
```

Consulta la [referencia de la API de `fetch`](/docs/app/api-reference/functions/fetch) para más opciones.

### `fetch options.next.tags` y `revalidateTag`

Next.js tiene un sistema de etiquetas de caché para el almacenamiento en caché y la revalidación de datos con gran precisión.

1. Al usar `fetch` o [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache), tienes la opción de etiquetar entradas de caché con una o más etiquetas.
2. Luego, puedes llamar a `revalidateTag` para purgar las entradas de caché asociadas con esa etiqueta.

Por ejemplo, puedes establecer una etiqueta al obtener datos:

```jsx
// Almacenar datos en caché con una etiqueta
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

Luego, llama a `revalidateTag` con una etiqueta para purgar la entrada de caché:

```jsx
// Revalidar entradas con una etiqueta específica
revalidateTag('a')
```

Hay dos lugares donde puedes usar `revalidateTag`, dependiendo de lo que quieras lograr:

1. [Manejadores de ruta](/docs/app/building-your-application/routing/route-handlers) - para revalidar datos en respuesta a un evento de terceros (por ejemplo, un webhook). Esto no invalidará inmediatamente la caché del enrutador, ya que el manejador de ruta no está vinculado a una ruta específica.
2. [Acciones del servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - para revalidar datos después de una acción del usuario (por ejemplo, envío de un formulario). Esto invalidará la caché del enrutador para la ruta asociada.

### `revalidatePath`

`revalidatePath` te permite revalidar manualmente datos **y** volver a renderizar los segmentos de ruta debajo de una ruta específica en una sola operación. Llamar al método `revalidatePath` revalida la caché de datos, que a su vez invalida la caché de ruta completa.

```jsx
revalidatePath('/')
```

Hay dos lugares donde puedes usar `revalidatePath`, dependiendo de lo que quieras lograr:

1. [Manejadores de ruta](/docs/app/building-your-application/routing/route-handlers) - para revalidar datos en respuesta a un evento de terceros (por ejemplo, un webhook).
2. [Acciones del servidor](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - para revalidar datos después de una interacción del usuario (por ejemplo, envío de un formulario, hacer clic en un botón).

Consulta la [referencia de la API de `revalidatePath`](/docs/app/api-reference/functions/revalidatePath) para más información.

> **`revalidatePath`** vs. **`router.refresh`**:
>
> Llamar a `router.refresh` borrará la caché del enrutador y volverá a renderizar los segmentos de ruta en el servidor sin invalidar la caché de datos ni la caché de ruta completa.
>
> La diferencia es que `revalidatePath` purga la caché de datos y la caché de ruta completa, mientras que `router.refresh()` no cambia la caché de datos ni la caché de ruta completa, ya que es una API del lado del cliente.

### APIs dinámicas

Las APIs dinámicas como `cookies` y `headers`, y la propiedad `searchParams` en Páginas dependen de la información de la solicitud entrante en tiempo de ejecución. Usarlas excluirá una ruta de la caché de ruta completa, en otras palabras, la ruta se renderizará dinámicamente.

#### `cookies`

Usar `cookies.set` o `cookies.delete` en una acción del servidor invalida la caché del enrutador para evitar que las rutas que usan cookies se vuelvan obsoletas (por ejemplo, para reflejar cambios de autenticación).

Consulta la [referencia de la API de `cookies`](/docs/app/api-reference/functions/cookies).

### Opciones de Configuración de Segmentos de Ruta

Las opciones de Configuración de Segmentos de Ruta pueden utilizarse para anular los valores predeterminados del segmento de ruta o cuando no es posible utilizar la API `fetch` (por ejemplo, clientes de base de datos o bibliotecas de terceros).

Las siguientes opciones de Configuración de Segmentos de Ruta excluirán la ruta de la Caché de Ruta Completa (Full Route Cache):

- `const dynamic = 'force-dynamic'`

Esta opción de configuración excluirá todas las solicitudes fetch de la Caché de Datos (es decir, `no-store`):

- `const fetchCache = 'default-no-store'`

Consulte [`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache) para ver opciones más avanzadas.

Vea la documentación de [Configuración de Segmentos de Ruta](/docs/app/api-reference/file-conventions/route-segment-config) para más opciones.

### `generateStaticParams`

Para [segmentos dinámicos](/docs/app/api-reference/file-conventions/dynamic-routes) (por ejemplo, `app/blog/[slug]/page.js`), las rutas proporcionadas por `generateStaticParams` se almacenan en la Caché de Ruta Completa (Full Route Cache) durante el tiempo de construcción. En el momento de la solicitud, Next.js también almacenará en caché las rutas que no se conocían en el momento de construcción la primera vez que se visitan.

Para renderizar estáticamente todas las rutas en el momento de construcción, proporcione la lista completa de rutas a `generateStaticParams`:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

Para renderizar estáticamente un subconjunto de rutas en el momento de construcción, y el resto la primera vez que se visiten en tiempo de ejecución, devuelva una lista parcial de rutas:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // Renderizar los primeros 10 posts en el momento de construcción
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

Para renderizar estáticamente todas las rutas la primera vez que se visiten, devuelva un array vacío (no se renderizarán rutas en el momento de construcción) o utilice [`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic):

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Nota importante:** Debe devolver un array desde `generateStaticParams`, incluso si está vacío. De lo contrario, la ruta se renderizará dinámicamente.

```jsx filename="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

Para deshabilitar el almacenamiento en caché en el momento de la solicitud, agregue la opción `export const dynamicParams = false` en un segmento de ruta. Cuando se utiliza esta opción de configuración, solo se servirán las rutas proporcionadas por `generateStaticParams`, y otras rutas devolverán un 404 o coincidirán (en el caso de [rutas catch-all](/docs/app/api-reference/file-conventions/dynamic-routes#catch-all-segments)).

### Función `cache` de React

La función `cache` de React le permite memorizar el valor de retorno de una función, permitiéndole llamar a la misma función múltiples veces mientras solo se ejecuta una vez.

Dado que las solicitudes `fetch` se memorizan automáticamente, no necesita envolverlas en `cache` de React. Sin embargo, puede usar `cache` para memorizar manualmente solicitudes de datos en casos de uso donde la API `fetch` no sea adecuada. Por ejemplo, algunos clientes de bases de datos, clientes de CMS o clientes de GraphQL.

```ts filename="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

```js filename="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
