---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:12:15.841Z
title: Enlaces y Navegación
description: Aprenda cómo funciona la navegación en Next.js y cómo usar el componente `Link` y el hook `useRouter`.
related:
  links:
    - app/deep-dive/caching
    - app/api-reference/config/typescript
---

Existen cuatro formas de navegar entre rutas en Next.js:

- Usando el [componente `<Link>`](#link-component)
- Usando el [hook `useRouter`](#userouter-hook) ([Componentes del Cliente](/docs/app/getting-started/server-and-client-components))
- Usando la [función `redirect`](#redirect-function) ([Componentes del Servidor](/docs/app/getting-started/server-and-client-components))
- Usando la [API History nativa](#using-the-native-history-api)

Esta página explicará cómo usar cada una de estas opciones y profundizará en el funcionamiento de la navegación.

## Componente `<Link>`

`<Link>` es un componente integrado que extiende la etiqueta HTML `<a>` para proporcionar [precarga (prefetching)](#2-prefetching) y navegación del lado del cliente entre rutas. Es la forma principal y recomendada para navegar entre rutas en Next.js.

Puede usarlo importándolo desde `next/link` y pasando una propiedad `href` al componente:

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

Hay otras propiedades opcionales que puede pasar a `<Link>`. Consulte la [referencia de API](/docs/app/api-reference/components/link) para más información.

## Hook `useRouter()`

El hook `useRouter` permite cambiar rutas programáticamente desde [Componentes del Cliente](/docs/app/getting-started/server-and-client-components).

```tsx filename="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Para una lista completa de métodos de `useRouter`, consulte la [referencia de API](/docs/app/api-reference/functions/use-router).

> **Recomendación:** Use el componente `<Link>` para navegar entre rutas a menos que tenga un requisito específico para usar `useRouter`.

## Función `redirect`

Para [Componentes del Servidor](/docs/app/getting-started/server-and-client-components), use la función `redirect` en su lugar.

```tsx filename="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

```jsx filename="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

> **Importante**:
>
> - `redirect` devuelve por defecto un código de estado 307 (Redirección Temporal). Cuando se usa en una Server Action, devuelve un 303 (Ver Otro), que se usa comúnmente para redirigir a una página de éxito como resultado de una solicitud POST.
> - `redirect` internamente lanza un error, por lo que debe llamarse fuera de bloques `try/catch`.
> - `redirect` puede llamarse en Componentes del Cliente durante el proceso de renderizado pero no en manejadores de eventos. Puede usar el [hook `useRouter`](#userouter-hook) en su lugar.
> - `redirect` también acepta URLs absolutas y puede usarse para redirigir a enlaces externos.
> - Si desea redirigir antes del proceso de renderizado, use [`next.config.js`](/docs/app/guides/redirecting#redirects-in-nextconfigjs) o [Middleware](/docs/app/guides/redirecting#nextresponseredirect-in-middleware).

Consulte la [referencia de API de `redirect`](/docs/app/api-reference/functions/redirect) para más información.

## Uso de la API History nativa

Next.js permite usar los métodos nativos [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) y [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) para actualizar el historial del navegador sin recargar la página.

Las llamadas a `pushState` y `replaceState` se integran con el Router de Next.js, permitiéndole sincronizarse con [`usePathname`](/docs/app/api-reference/functions/use-pathname) y [`useSearchParams`](/docs/app/api-reference/functions/use-search-params).

### `window.history.pushState`

Úselo para añadir una nueva entrada al historial del navegador. El usuario puede navegar de vuelta al estado anterior. Por ejemplo, para ordenar una lista de productos:

```tsx fileName="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Ordenar Ascendente</button>
      <button onClick={() => updateSorting('desc')}>Ordenar Descendente</button>
    </>
  )
}
```

```jsx fileName="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Ordenar Ascendente</button>
      <button onClick={() => updateSorting('desc')}>Ordenar Descendente</button>
    </>
  )
}
```

### `window.history.replaceState`

Úselo para reemplazar la entrada actual en el historial del navegador. El usuario no podrá navegar de vuelta al estado anterior. Por ejemplo, para cambiar el idioma de la aplicación:

```tsx fileName="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // ej. '/en/about' o '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Inglés</button>
      <button onClick={() => switchLocale('fr')}>Francés</button>
    </>
  )
}
```

```jsx fileName="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // ej. '/en/about' o '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Inglés</button>
      <button onClick={() => switchLocale('fr')}>Francés</button>
    </>
  )
}
```

## Cómo Funcionan el Enrutamiento y la Navegación

El App Router utiliza un enfoque híbrido para el enrutamiento y la navegación. En el servidor, su código de aplicación se divide automáticamente [por segmentos de ruta](#1-code-splitting). Y en el cliente, Next.js [precarga](#2-prefetching) y [almacena en caché](#3-caching) los segmentos de ruta. Esto significa que cuando un usuario navega a una nueva ruta, el navegador no recarga la página, y solo los segmentos de ruta que cambian se vuelven a renderizar, mejorando la experiencia de navegación y el rendimiento.

### 1. División de Código (Code Splitting)

La división de código permite dividir el código de su aplicación en paquetes más pequeños para que el navegador los descargue y ejecute. Esto reduce la cantidad de datos transferidos y el tiempo de ejecución por cada solicitud, mejorando el rendimiento.

Los [Componentes del Servidor](/docs/app/getting-started/server-and-client-components) permiten que su código de aplicación se divida automáticamente por segmentos de ruta. Esto significa que solo se carga el código necesario para la ruta actual durante la navegación.

### 2. Precarga (Prefetching)

La precarga es una forma de cargar una ruta en segundo plano antes de que el usuario la visite.

Hay dos formas en que las rutas se precargan en Next.js:

- **Componente `<Link>`**: Las rutas se precargan automáticamente cuando son visibles en el viewport del usuario. La precarga ocurre cuando la página se carga por primera vez o cuando entra en vista al desplazarse.
- **`router.prefetch()`**: El hook `useRouter` puede usarse para precargar rutas programáticamente.

El comportamiento predeterminado de precarga de `<Link>` (es decir, cuando la propiedad `prefetch` no se especifica o se establece en `null`) varía según el uso de [`loading.js`](/docs/app/api-reference/file-conventions/loading). Solo el diseño compartido, hacia abajo en el "árbol" de componentes renderizados hasta el primer archivo `loading.js`, se precarga y almacena en caché durante `30s`. Esto reduce el costo de obtener una ruta dinámica completa y significa que puede mostrar un [estado de carga instantánea](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) para una mejor retroalimentación visual a los usuarios.

Puede desactivar la precarga estableciendo la propiedad `prefetch` en `false`. Alternativamente, puede precargar los datos completos de la página más allá de los límites de carga estableciendo la propiedad `prefetch` en `true`.

Consulte la [referencia de API de `<Link>`](/docs/app/api-reference/components/link) para más información.

> **Importante**:
>
> - La precarga no está activada en desarrollo, solo en producción.

### 3. Almacenamiento en Caché (Caching)

Next.js tiene una **caché del lado del cliente en memoria** llamada [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache). A medida que los usuarios navegan por la aplicación, la carga útil del Componente del Servidor React de los segmentos de ruta [precargados](#2-prefetching) y las rutas visitadas se almacenan en la caché.

Esto significa que durante la navegación, la caché se reutiliza tanto como sea posible, en lugar de hacer una nueva solicitud al servidor, mejorando el rendimiento al reducir el número de solicitudes y datos transferidos.

Aprenda más sobre cómo funciona el [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache) y cómo configurarlo.

### 4. Renderizado Parcial (Partial Rendering)

El renderizado parcial significa que solo los segmentos de ruta que cambian durante la navegación se vuelven a renderizar en el cliente, y cualquier segmento compartido se preserva.

Por ejemplo, al navegar entre dos rutas hermanas, `/dashboard/settings` y `/dashboard/analytics`, la página `settings` se desmontará, la página `analytics` se montará con estado fresco, y el diseño compartido `dashboard` se preservará. Este comportamiento también está presente entre dos rutas en el mismo segmento dinámico, por ejemplo con `/blog/[slug]/page` y navegando de `/blog/first` a `/blog/second`.

<Image
  alt="Cómo funciona el renderizado parcial"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

Sin el renderizado parcial, cada navegación causaría que toda la página se vuelva a renderizar en el cliente. Renderizar solo el segmento que cambia reduce la cantidad de datos transferidos y el tiempo de ejecución, mejorando el rendimiento.

### 5. Navegación Suave (Soft Navigation)

Los navegadores realizan una "navegación dura" al moverse entre páginas. El App Router de Next.js habilita la "navegación suave" entre páginas, asegurando que solo los segmentos de ruta que han cambiado se vuelvan a renderizar (renderizado parcial). Esto permite que el estado React del cliente se preserve durante la navegación.

### 6. Navegación Atrás y Adelante

Por defecto, Next.js mantendrá la posición de desplazamiento para navegaciones hacia atrás y adelante, y reutilizará segmentos de ruta en el [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache).

### 7. Enrutamiento entre `pages/` y `app/`

Al migrar incrementalmente de `pages/` a `app/`, el router de Next.js manejará automáticamente la navegación dura entre ambos. Para detectar transiciones de `pages/` a `app/`, hay un filtro de router del cliente que utiliza comprobación probabilística de rutas de app, lo que ocasionalmente puede resultar en falsos positivos. Por defecto, tales ocurrencias deberían ser muy raras, ya que configuramos la probabilidad de falso positivo en un 0.01%. Esta probabilidad puede personalizarse mediante la opción `experimental.clientRouterFilterAllowedRate` en `next.config.js`. Es importante notar que reducir la tasa de falsos positivos aumentará el tamaño del filtro generado en el paquete del cliente.

Alternativamente, si prefiere desactivar completamente este manejo y administrar manualmente el enrutamiento entre `pages/` y `app/`, puede establecer `experimental.clientRouterFilter` en false en `next.config.js`. Cuando esta característica está desactivada, cualquier ruta dinámica en pages que coincida con rutas de app no se navegará correctamente por defecto.