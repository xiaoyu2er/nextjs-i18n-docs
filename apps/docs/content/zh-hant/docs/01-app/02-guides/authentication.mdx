---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-01T22:32:40.509Z
title: 如何在 Next.js 中實現身份驗證
nav_title: 身份驗證
description: 了解如何在您的 Next.js 應用程式中實現身份驗證功能。
---

理解身份驗證對於保護應用程式資料至關重要。本頁將引導您了解應使用哪些 React 和 Next.js 功能來實現驗證機制。

開始之前，可先將流程分解為三個概念：

1. **[身份驗證 (Authentication)](#authentication)**：驗證使用者是否為其所聲稱的身份。要求使用者透過他們擁有的憑證（如用戶名和密碼）來證明身份。
2. **[會話管理 (Session Management)](#session-management)**：跨請求追蹤使用者的驗證狀態。
3. **[授權 (Authorization)](#authorization)**：決定使用者可以存取哪些路由和資料。

以下圖表展示使用 React 和 Next.js 功能的驗證流程：

<Image
  alt="展示使用 React 和 Next.js 功能的驗證流程圖表"
  srcLight="/docs/light/authentication-overview.png"
  srcDark="/docs/dark/authentication-overview.png"
  width="1600"
  height="1383"
/>

本頁範例將以教學目的展示基本的用戶名和密碼驗證。雖然您可以實現自訂驗證方案，但為了提升安全性和簡化流程，我們建議使用驗證函式庫。這些函式庫提供內建的驗證、會話管理和授權解決方案，以及額外功能如社交登入、多因素驗證和基於角色的存取控制。您可以在[驗證函式庫](#auth-libraries)章節找到相關列表。

## 身份驗證

<AppOnly>

### 註冊與登入功能

您可以使用 [`<form>`](https://react.dev/reference/react-dom/components/form) 元素搭配 React 的[伺服器操作 (Server Actions)](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) 和 `useActionState` 來獲取使用者憑證、驗證表單欄位，並呼叫您的驗證提供者 API 或資料庫。

由於伺服器操作始終在伺服器端執行，因此為處理驗證邏輯提供了安全的環境。

以下是實現註冊/登入功能的步驟：

#### 1. 獲取使用者憑證

要獲取使用者憑證，請建立一個在提交時調用伺服器操作的表單。例如，一個接受使用者姓名、電子郵件和密碼的註冊表單：

```tsx filename="app/ui/signup-form.tsx" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">姓名</label>
        <input id="name" name="name" placeholder="姓名" />
      </div>
      <div>
        <label htmlFor="email">電子郵件</label>
        <input id="email" name="email" type="email" placeholder="電子郵件" />
      </div>
      <div>
        <label htmlFor="password">密碼</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">註冊</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher
import { signup } from '@/app/actions/auth'

export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">姓名</label>
        <input id="name" name="name" placeholder="姓名" />
      </div>
      <div>
        <label htmlFor="email">電子郵件</label>
        <input id="email" name="email" type="email" placeholder="電子郵件" />
      </div>
      <div>
        <label htmlFor="password">密碼</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">註冊</button>
    </form>
  )
}
```

```tsx filename="app/actions/auth.ts" switcher
export async function signup(formData: FormData) {}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(formData) {}
```

#### 2. 在伺服器端驗證表單欄位

使用伺服器操作來驗證伺服器端的表單欄位。如果您的驗證提供者不提供表單驗證，可以使用模式驗證函式庫如 [Zod](https://zod.dev/) 或 [Yup](https://github.com/jquense/yup)。

以 Zod 為例，您可以定義一個帶有適當錯誤訊息的表單模式：

```ts filename="app/lib/definitions.ts" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '姓名長度至少為 2 個字元。' })
    .trim(),
  email: z.string().email({ message: '請輸入有效的電子郵件。' }).trim(),
  password: z
    .string()
    .min(8, { message: '長度至少為 8 個字元' })
    .regex(/[a-zA-Z]/, { message: '至少包含一個字母。' })
    .regex(/[0-9]/, { message: '至少包含一個數字。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '至少包含一個特殊字元。',
    })
    .trim(),
})

export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

```js filename="app/lib/definitions.js" switcher
import { z } from 'zod'

export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: '姓名長度至少為 2 個字元。' })
    .trim(),
  email: z.string().email({ message: '請輸入有效的電子郵件。' }).trim(),
  password: z
    .string()
    .min(8, { message: '長度至少為 8 個字元' })
    .regex(/[a-zA-Z]/, { message: '至少包含一個字母。' })
    .regex(/[0-9]/, { message: '至少包含一個數字。' })
    .regex(/[^a-zA-Z0-9]/, {
      message: '至少包含一個特殊字元。',
    })
    .trim(),
})
```

為避免不必要的驗證提供者 API 或資料庫呼叫，如果任何表單欄位不符合定義的模式，您可以在伺服器操作中提前 `return`。

```ts filename="app/actions/auth.ts" switcher
import { SignupFormSchema, FormState } from '@/app/lib/definitions'

export async function signup(state: FormState, formData: FormData) {
  // 驗證表單欄位
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // 如果有任何欄位無效，提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 呼叫提供者或資料庫建立使用者...
}
```

```js filename="app/actions/auth.js" switcher
import { SignupFormSchema } from '@/app/lib/definitions'

export async function signup(state, formData) {
  // 驗證表單欄位
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })

  // 如果有任何欄位無效，提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 呼叫提供者或資料庫建立使用者...
}
```

回到您的 `<SignupForm />`，可以使用 React 的 `useActionState` 鉤子在表單提交時顯示驗證錯誤：

```tsx filename="app/ui/signup-form.tsx" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">姓名</label>
        <input id="name" name="name" placeholder="姓名" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">電子郵件</label>
        <input id="email" name="email" placeholder="電子郵件" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">密碼</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>密碼必須：</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        註冊
      </button>
    </form>
  )
}
```

```jsx filename="app/ui/signup-form.js" switcher highlight={7,15,21,27-36}
'use client'

import { signup } from '@/app/actions/auth'
import { useActionState } from 'react'

export default function SignupForm() {
  const [state, action, pending] = useActionState(signup, undefined)

  return (
    <form action={action}>
      <div>
        <label htmlFor="name">姓名</label>
        <input id="name" name="name" placeholder="姓名" />
      </div>
      {state?.errors?.name && <p>{state.errors.name}</p>}

      <div>
        <label htmlFor="email">電子郵件</label>
        <input id="email" name="email" placeholder="電子郵件" />
      </div>
      {state?.errors?.email && <p>{state.errors.email}</p>}

      <div>
        <label htmlFor="password">密碼</label>
        <input id="password" name="password" type="password" />
      </div>
      {state?.errors?.password && (
        <div>
          <p>密碼必須：</p>
          <ul>
            {state.errors.password.map((error) => (
              <li key={error}>- {error}</li>
            ))}
          </ul>
        </div>
      )}
      <button disabled={pending} type="submit">
        註冊
      </button>
    </form>
  )
}
```

> **須知事項：**
>
> - 在 React 19 中，`useFormStatus` 包含返回物件上的其他鍵，如 data、method 和 action。如果您未使用 React 19，則僅有 `pending` 鍵可用。
> - 在變更資料之前，您應始終確保使用者也有權執行該操作。請參閱[身份驗證與授權](#authorization)。

</AppOnly>

#### 3. 建立使用者或驗證使用者憑證

驗證表單欄位後，您可以透過呼叫驗證提供者的 API 或資料庫來建立新使用者帳戶或檢查使用者是否存在。

延續先前的範例：

```tsx filename="app/actions/auth.tsx" switcher
export async function signup(state: FormState, formData: FormData) {
  // 1. 驗證表單欄位
  // ...

  // 2. 準備插入資料庫的資料
  const { name, email, password } = validatedFields.data
  // 例如：在儲存前雜湊使用者的密碼
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. 將使用者插入資料庫或呼叫驗證函式庫的 API
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: '建立帳戶時發生錯誤',
    }
  }

  // 待辦事項：
  // 4. 建立使用者工作階段
  // 5. 重新導向使用者
}
```

```jsx filename="app/actions/auth.js" switcher
export async function signup(state, formData) {
  // 1. 驗證表單欄位
  // ...

  // 2. 準備插入資料庫的資料
  const { name, email, password } = validatedFields.data
  // 例如：在儲存前雜湊使用者的密碼
  const hashedPassword = await bcrypt.hash(password, 10)

  // 3. 將使用者插入資料庫或呼叫函式庫 API
  const data = await db
    .insert(users)
    .values({
      name,
      email,
      password: hashedPassword,
    })
    .returning({ id: users.id })

  const user = data[0]

  if (!user) {
    return {
      message: '建立帳戶時發生錯誤',
    }
  }

  // 待辦事項：
  // 4. 建立使用者工作階段
  // 5. 重新導向使用者
}
```

成功建立使用者帳戶或驗證使用者憑證後，您可以建立工作階段來管理使用者的驗證狀態。根據您的工作階段管理策略，工作階段可以儲存在 cookie 或資料庫中，或兩者皆有。請繼續閱讀[工作階段管理](#session-management)章節以了解更多。

> **提示：**
>
> - 上述範例為了教學目的詳細分解了驗證步驟，因此顯得冗長。這突顯了實作自己的安全解決方案可能很快變得複雜。考慮使用[驗證函式庫](#auth-libraries)來簡化流程。
> - 為了改善使用者體驗，您可能希望在註冊流程的早期檢查重複的電子郵件或使用者名稱。例如，當使用者輸入使用者名稱或輸入欄位失去焦點時。這可以避免不必要的表單提交，並立即提供回饋給使用者。您可以使用如 [use-debounce](https://www.npmjs.com/package/use-debounce) 這樣的函式庫來管理這些檢查的頻率。

</AppOnly>

<PagesOnly>

以下是實作註冊和/或登入表單的步驟：

1. 使用者透過表單提交他們的憑證。
2. 表單發送請求，由 API 路由處理。
3. 驗證成功後，流程完成，表示使用者已成功驗證。
4. 如果驗證失敗，則顯示錯誤訊息。

考慮一個登入表單，使用者可以輸入他們的憑證：

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // 處理錯誤
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="電子郵件" required />
      <input type="password" name="password" placeholder="密碼" required />
      <button type="submit">登入</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // 處理錯誤
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="電子郵件" required />
      <input type="password" name="password" placeholder="密碼" required />
      <button type="submit">登入</button>
    </form>
  )
}
```

上述表單有兩個輸入欄位，用於捕捉使用者的電子郵件和密碼。提交時，它會觸發一個函式，向 API 路由 (`/api/auth/login`) 發送 POST 請求。

然後您可以在 API 路由中呼叫驗證提供者的 API 來處理驗證：

```ts filename="pages/api/auth/login.ts" switcher
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無效的憑證' })
    } else {
      res.status(500).json({ error: '發生錯誤' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: '無效的憑證' })
    } else {
      res.status(500).json({ error: '發生錯誤' })
    }
  }
}
```

</PagesOnly>

## 工作階段管理

工作階段管理確保使用者的驗證狀態在請求之間保持。它涉及建立、儲存、更新和刪除工作階段或令牌。

有兩種類型的工作階段：

1. [**無狀態 (Stateless)**](#stateless-sessions)：工作階段資料（或令牌）儲存在瀏覽器的 cookie 中。cookie 會隨每個請求發送，允許在伺服器上驗證工作階段。這種方法較簡單，但如果未正確實作，可能較不安全。
2. [**資料庫 (Database)**](#database-sessions)：工作階段資料儲存在資料庫中，使用者的瀏覽器僅接收加密的工作階段 ID。這種方法較安全，但可能較複雜且使用更多伺服器資源。

> **須知：** 雖然您可以使用任一方法或兩者，但我們建議使用工作階段管理函式庫，例如 [iron-session](https://github.com/vvo/iron-session) 或 [Jose](https://github.com/panva/jose)。

### 無狀態工作階段

<AppOnly>

要建立和管理無狀態工作階段，您需要遵循以下步驟：

1. 產生一個密鑰，用於簽署您的工作階段，並將其儲存為[環境變數](/docs/app/guides/environment-variables)。
2. 使用工作階段管理函式庫編寫加密/解密工作階段資料的邏輯。
3. 使用 Next.js [`cookies`](/docs/app/api-reference/functions/cookies) API 管理 cookie。

除了上述步驟，考慮新增功能在使用者返回應用程式時[更新（或刷新）](#updating-or-refreshing-sessions)工作階段，並在使用者登出時[刪除](#deleting-the-session)工作階段。

> **須知：** 檢查您的[驗證函式庫](#auth-libraries)是否包含工作階段管理功能。

#### 1. 產生密鑰

有幾種方法可以產生用於簽署工作階段的密鑰。例如，您可以在終端機中使用 `openssl` 命令：

```bash filename="terminal"
openssl rand -base64 32
```

此命令產生一個 32 字元的隨機字串，您可以將其用作密鑰並儲存在[環境變數檔案](/docs/app/guides/environment-variables)中：

```bash filename=".env"
SESSION_SECRET=your_secret_key
```

然後您可以在工作階段管理邏輯中引用此密鑰：

```js filename="app/lib/session.js"
const secretKey = process.env.SESSION_SECRET
```

#### 2. 加密和解密工作階段

接下來，您可以使用您偏好的[工作階段管理函式庫](#session-management-libraries)來加密和解密工作階段。延續先前的範例，我們將使用 [Jose](https://www.npmjs.com/package/jose)（與 [Edge Runtime](/docs/app/api-reference/edge) 相容）和 React 的 [`server-only`](https://www.npmjs.com/package/server-only) 套件，以確保您的工作階段管理邏輯僅在伺服器上執行。

```tsx filename="app/lib/session.ts" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'
import { SessionPayload } from '@/app/lib/definitions'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload: SessionPayload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session: string | undefined = '') {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('驗證工作階段失敗')
  }
}
```

```jsx filename="app/lib/session.js" switcher
import 'server-only'
import { SignJWT, jwtVerify } from 'jose'

const secretKey = process.env.SESSION_SECRET
const encodedKey = new TextEncoder().encode(secretKey)

export async function encrypt(payload) {
  return new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(encodedKey)
}

export async function decrypt(session) {
  try {
    const { payload } = await jwtVerify(session, encodedKey, {
      algorithms: ['HS256'],
    })
    return payload
  } catch (error) {
    console.log('驗證工作階段失敗')
  }
}
```

> **提示：**
>
> - 負載應包含在後續請求中使用的**最小**、唯一使用者資料，例如使用者的 ID、角色等。不應包含個人識別資訊，如電話號碼、電子郵件地址、信用卡資訊等，或敏感資料如密碼。

#### 3. 設定 cookie（建議選項）

要將工作階段儲存在 cookie 中，請使用 Next.js [`cookies`](/docs/app/api-reference/functions/cookies) API。cookie 應在伺服器上設定，並包含建議的選項：

- **HttpOnly**：防止客戶端 JavaScript 存取 cookie。
- **Secure**：使用 https 發送 cookie。
- **SameSite**：指定 cookie 是否可以與跨站請求一起發送。
- **Max-Age 或 Expires**：在一定時間後刪除 cookie。
- **Path**：定義 cookie 的 URL 路徑。

請參閱 [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) 以獲取有關這些選項的更多資訊。

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function createSession(userId) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  const session = await encrypt({ userId, expiresAt })
  const cookieStore = await cookies()

  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

回到您的伺服器動作中，您可以呼叫 `createSession()` 函式，並使用 [`redirect()`](/docs/app/guides/redirecting) API 將使用者重新導向到適當的頁面：

```ts filename="app/actions/auth.ts" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state: FormState, formData: FormData) {
  // 先前步驟：
  // 1. 驗證表單欄位
  // 2. 準備插入資料庫的資料
  // 3. 將使用者插入資料庫或呼叫函式庫 API

  // 當前步驟：
  // 4. 建立使用者工作階段
  await createSession(user.id)
  // 5. 重新導向使用者
  redirect('/profile')
}
```

```js filename="app/actions/auth.js" switcher
import { createSession } from '@/app/lib/session'

export async function signup(state, formData) {
  // 先前步驟：
  // 1. 驗證表單欄位
  // 2. 準備插入資料庫的資料
  // 3. 將使用者插入資料庫或呼叫函式庫 API

  // 當前步驟：
  // 4. 建立使用者工作階段
  await createSession(user.id)
  // 5. 重新導向使用者
  redirect('/profile')
}
```

> **提示：**
>
> - **Cookie 應在伺服器上設定**以防止客戶端篡改。
> - 🎥 觀看：了解更多關於無狀態工作階段和 Next.js 驗證 → [YouTube (11 分鐘)](https://www.youtube.com/watch?v=DJvM2lSPn6w)。

#### 更新（或刷新）工作階段

您也可以延長工作階段的過期時間。這對於在使用者再次存取應用程式時保持登入狀態很有用。例如：

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export async function updateSession() {
  const session = (await cookies()).get('session')?.value
  const payload = await decrypt(session)

  if (!session || !payload) {
    return null
  }

  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)(
    await cookies()
  ).set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expires,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **提示：** 檢查您的驗證函式庫是否支援刷新令牌，可用於延長使用者的工作階段。

#### 刪除工作階段 (session)

要刪除工作階段，您可以刪除 cookie：

```ts filename="app/lib/session.ts" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

```js filename="app/lib/session.js" switcher
import 'server-only'
import { cookies } from 'next/headers'

export async function deleteSession() {
  const cookieStore = await cookies()
  cookieStore.delete('session')
}
```

然後您可以在應用程式中重複使用 `deleteSession()` 函式，例如在登出時：

```ts filename="app/actions/auth.ts" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

```js filename="app/actions/auth.js" switcher
import { cookies } from 'next/headers'
import { deleteSession } from '@/app/lib/session'

export async function logout() {
  await deleteSession()
  redirect('/login')
}
```

</AppOnly>

<PagesOnly>

#### 設定與刪除 cookies

您可以使用 [API 路由 (API Routes)](/docs/pages/building-your-application/routing/api-routes) 在伺服器端將工作階段設定為 cookie：

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'
import { encrypt } from '@/app/lib/session'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // 一週
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

### 資料庫工作階段 (Database Sessions)

要建立和管理資料庫工作階段，您需要遵循以下步驟：

1. 在資料庫中建立一個表格來儲存工作階段和資料（或檢查您的驗證函式庫是否處理此功能）。
2. 實作插入、更新和刪除工作階段的功能
3. 將工作階段 ID 加密後儲存在使用者的瀏覽器中，並確保資料庫和 cookie 保持同步（這是可選的，但建議用於 [中介軟體 (Middleware)](#optimistic-checks-with-middleware-optional) 中的樂觀驗證檢查）。

<AppOnly>

例如：

```ts filename="app/lib/session.ts" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id: number) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. 在資料庫中建立工作階段
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // 回傳工作階段 ID
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. 加密工作階段 ID
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 將工作階段儲存在 cookie 中以進行樂觀驗證檢查
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

```js filename="app/lib/session.js" switcher
import cookies from 'next/headers'
import { db } from '@/app/lib/db'
import { encrypt } from '@/app/lib/session'

export async function createSession(id) {
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)

  // 1. 在資料庫中建立工作階段
  const data = await db
    .insert(sessions)
    .values({
      userId: id,
      expiresAt,
    })
    // 回傳工作階段 ID
    .returning({ id: sessions.id })

  const sessionId = data[0].id

  // 2. 加密工作階段 ID
  const session = await encrypt({ sessionId, expiresAt })

  // 3. 將工作階段儲存在 cookie 中以進行樂觀驗證檢查
  const cookieStore = await cookies()
  cookieStore.set('session', session, {
    httpOnly: true,
    secure: true,
    expires: expiresAt,
    sameSite: 'lax',
    path: '/',
  })
}
```

> **提示**：
>
> - 為了更快的存取速度，您可以考慮為工作階段的生命週期添加伺服器快取。您也可以將工作階段資料保留在主資料庫中，並合併資料請求以減少查詢次數。
> - 您可以選擇使用資料庫工作階段來處理更進階的使用案例，例如追蹤使用者最後登入時間、活躍裝置數量，或讓使用者能夠登出所有裝置。

實作工作階段管理後，您需要添加授權邏輯來控制使用者在應用程式中可以存取和執行的操作。繼續閱讀 [授權 (Authorization)](#authorization) 章節以了解更多。

</AppOnly>

<PagesOnly>

**在伺服器上建立工作階段**：

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

## 授權 (Authorization)

當使用者通過驗證並建立工作階段後，您可以實作授權來控制使用者在應用程式中可以存取和執行的操作。

授權檢查主要有兩種類型：

1. **樂觀檢查 (Optimistic)**：使用儲存在 cookie 中的工作階段資料檢查使用者是否有權存取路由或執行操作。這些檢查適用於快速操作，例如顯示/隱藏 UI 元素或根據權限或角色重新導向使用者。
2. **安全檢查 (Secure)**：使用儲存在資料庫中的工作階段資料檢查使用者是否有權存取路由或執行操作。這些檢查更安全，適用於需要存取敏感資料或操作的場合。

對於這兩種情況，我們建議：

- 建立一個 [資料存取層 (Data Access Layer)](#creating-a-data-access-layer-dal) 來集中您的授權邏輯
- 使用 [資料傳輸物件 (Data Transfer Objects, DTO)](#using-data-transfer-objects-dto) 僅回傳必要的資料
- 可選地使用 [中介軟體 (Middleware)](#optimistic-checks-with-middleware-optional) 來執行樂觀檢查。

### 使用中介軟體進行樂觀檢查（可選）

在某些情況下，您可能希望使用 [中介軟體 (Middleware)](/docs/app/building-your-application/routing/middleware) 並根據權限重新導向使用者：

- 執行樂觀檢查。由於中介軟體在每個路由上執行，這是集中重新導向邏輯和預先過濾未授權使用者的好方法。
- 保護在使用者之間共享資料的靜態路由（例如付費牆後的內容）。

然而，由於中介軟體在每個路由上執行，包括 [預取 (prefetched)](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) 的路由，重要的是僅從 cookie 中讀取工作階段（樂觀檢查），並避免資料庫檢查以防止效能問題。

例如：

```tsx filename="middleware.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 指定受保護和公開路由
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req: NextRequest) {
  // 2. 檢查目前路由是受保護還是公開
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. 從 cookie 中解密工作階段
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 4. 如果使用者未通過驗證，重新導向至 /login
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 5. 如果使用者已通過驗證，重新導向至 /dashboard
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// 中介軟體不應執行的路由
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'
import { decrypt } from '@/app/lib/session'
import { cookies } from 'next/headers'

// 1. 指定受保護和公開路由
const protectedRoutes = ['/dashboard']
const publicRoutes = ['/login', '/signup', '/']

export default async function middleware(req) {
  // 2. 檢查目前路由是受保護還是公開
  const path = req.nextUrl.pathname
  const isProtectedRoute = protectedRoutes.includes(path)
  const isPublicRoute = publicRoutes.includes(path)

  // 3. 從 cookie 中解密工作階段
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  // 5. 如果使用者未通過驗證，重新導向至 /login
  if (isProtectedRoute && !session?.userId) {
    return NextResponse.redirect(new URL('/login', req.nextUrl))
  }

  // 6. 如果使用者已通過驗證，重新導向至 /dashboard
  if (
    isPublicRoute &&
    session?.userId &&
    !req.nextUrl.pathname.startsWith('/dashboard')
  ) {
    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
  }

  return NextResponse.next()
}

// 中介軟體不應執行的路由
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

雖然中介軟體對於初始檢查很有用，但它不應該是保護資料的唯一防線。大多數安全檢查應盡可能靠近資料來源執行，請參閱 [資料存取層 (Data Access Layer)](#creating-a-data-access-layer-dal) 以了解更多資訊。

> **提示**：
>
> - 在中介軟體中，您也可以使用 `req.cookies.get('session').value` 讀取 cookies。
> - 中介軟體使用 [Edge Runtime](/docs/app/api-reference/edge)，請檢查您的驗證函式庫和工作階段管理函式庫是否相容。
> - 您可以使用中介軟體中的 `matcher` 屬性來指定中介軟體應執行的路由。儘管如此，對於驗證，建議中介軟體在所有路由上執行。

<AppOnly>

### 建立資料存取層 (Data Access Layer, DAL)

我們建議建立一個 DAL 來集中您的資料請求和授權邏輯。

DAL 應包含一個函式，在使用者與應用程式互動時驗證其工作階段。至少，該函式應檢查工作階段是否有效，然後重新導向或回傳使用者資訊以進行後續請求。

例如，為您的 DAL 建立一個單獨的檔案，其中包含一個 `verifySession()` 函式。然後使用 React 的 [cache](https://react.dev/reference/react/cache) API 在 React 渲染過程中記憶化函式的回傳值：

```tsx filename="app/lib/dal.ts" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session?.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

```js filename="app/lib/dal.js" switcher
import 'server-only'

import { cookies } from 'next/headers'
import { decrypt } from '@/app/lib/session'

export const verifySession = cache(async () => {
  const cookie = (await cookies()).get('session')?.value
  const session = await decrypt(cookie)

  if (!session.userId) {
    redirect('/login')
  }

  return { isAuth: true, userId: session.userId }
})
```

然後您可以在資料請求、伺服器操作 (Server Actions)、路由處理器 (Route Handlers) 中呼叫 `verifySession()` 函式：

```tsx filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // 明確回傳您需要的欄位，而不是整個使用者物件
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

```jsx filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  try {
    const data = await db.query.users.findMany({
      where: eq(users.id, session.userId),
      // 明確回傳您需要的欄位，而不是整個使用者物件
      columns: {
        id: true,
        name: true,
        email: true,
      },
    })

    const user = data[0]

    return user
  } catch (error) {
    console.log('Failed to fetch user')
    return null
  }
})
```

> **提示**：
>
> - DAL 可用於保護在請求時取得的資料。然而，對於在使用者之間共享資料的靜態路由，資料將在建置時取得，而不是在請求時。使用 [中介軟體 (Middleware)](#optimistic-checks-with-middleware-optional) 來保護靜態路由。
> - 對於安全檢查，您可以通過比較工作階段 ID 與資料庫來檢查工作階段是否有效。使用 React 的 [cache](https://react.dev/reference/react/cache) 函式來避免在渲染過程中對資料庫進行不必要的重複請求。
> - 您可能希望將相關資料請求合併到一個 JavaScript 類別中，該類別在任何方法之前執行 `verifySession()`。

### 使用資料傳輸物件 (DTO)

當檢索資料時，建議只返回應用程式中會用到的必要資料，而非整個物件。例如，當獲取使用者資料時，可能只需返回使用者的 ID 和名稱，而不是包含密碼、電話號碼等的整個使用者物件。

然而，如果您無法控制返回的資料結構，或是在團隊合作中想避免將整個物件傳遞給客戶端，可以使用一些策略，例如指定哪些欄位可以安全地暴露給客戶端。

```tsx filename="app/lib/dto.ts" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer: User) {
  return true
}

function canSeePhoneNumber(viewer: User, team: string) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug: string) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 在此返回特定欄位
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // 或在此僅返回查詢特定的內容
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

```js filename="app/lib/dto.js" switcher
import 'server-only'
import { getUser } from '@/app/lib/dal'

function canSeeUsername(viewer) {
  return true
}

function canSeePhoneNumber(viewer, team) {
  return viewer.isAdmin || team === viewer.team
}

export async function getProfileDTO(slug) {
  const data = await db.query.users.findMany({
    where: eq(users.slug, slug),
    // 在此返回特定欄位
  })
  const user = data[0]

  const currentUser = await getUser(user.id)

  // 或在此僅返回查詢特定的內容
  return {
    username: canSeeUsername(currentUser) ? user.username : null,
    phonenumber: canSeePhoneNumber(currentUser, user.team)
      ? user.phonenumber
      : null,
  }
}
```

透過將資料請求和授權邏輯集中在資料存取層 (DAL) 並使用 DTO，您可以確保所有資料請求都是安全且一致的，這使得應用程式在擴展時更容易維護、審計和除錯。

> **須知**：
>
> - 有幾種不同的方式可以定義 DTO，從使用 `toJSON()` 到像上面範例中的獨立函式，或是 JS 類別。由於這些是 JavaScript 模式而非 React 或 Next.js 的功能，建議您進行一些研究以找到最適合您應用程式的模式。
> - 在我們的 [Next.js 安全性文章](/blog/security-nextjs-server-components-actions) 中了解更多安全性最佳實踐。

### 伺服器元件 (Server Components)

在 [伺服器元件](/docs/app/getting-started/server-and-client-components) 中進行權限檢查對於基於角色的存取非常有用。例如，根據使用者角色條件式渲染元件：

```tsx filename="app/dashboard/page.tsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session?.user?.role // 假設 'role' 是 session 物件的一部分

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
import { verifySession } from '@/app/lib/dal'

export default function Dashboard() {
  const session = await verifySession()
  const userRole = session.role // 假設 'role' 是 session 物件的一部分

  if (userRole === 'admin') {
    return <AdminDashboard />
  } else if (userRole === 'user') {
    return <UserDashboard />
  } else {
    redirect('/login')
  }
}
```

在這個範例中，我們使用 DAL 中的 `verifySession()` 函式來檢查 'admin'、'user' 和未授權角色。這種模式確保每位使用者只能與其角色相符的元件互動。

### 佈局與權限檢查

由於 [部分渲染 (Partial Rendering)](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering)，在 [佈局 (Layouts)](/docs/app/api-reference/file-conventions/layout) 中進行檢查時需謹慎，因為這些檢查不會在導航時重新渲染，這意味著使用者 session 不會在每次路由變更時被檢查。

相反，您應該在資料來源附近或將被條件式渲染的元件中進行檢查。

例如，考慮一個共享佈局會獲取使用者資料並在導航中顯示使用者圖片。與其在佈局中進行權限檢查，您應該在佈局中獲取使用者資料 (`getUser()`)，並在 DAL 中進行權限檢查。

這確保了無論在應用程式的何處呼叫 `getUser()`，都會執行權限檢查，並防止開發者忘記檢查使用者是否有權存取資料。

```tsx filename="app/layout.tsx" switcher
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```jsx filename="app/layout.js" switcher
export default async function Layout({ children }) {
  const user = await getUser();

  return (
    // ...
  )
}
```

```ts filename="app/lib/dal.ts" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // 從 session 中獲取使用者 ID 並取得資料
})
```

```js filename="app/lib/dal.js" switcher
export const getUser = cache(async () => {
  const session = await verifySession()
  if (!session) return null

  // 從 session 中獲取使用者 ID 並取得資料
})
```

> **須知：**
>
> - 在 SPA 中，常見的模式是在佈局或頂層元件中 `return null` 如果使用者未獲授權。這種模式 **不推薦**，因為 Next.js 應用程式有多個入口點，這不會阻止巢狀路由區段和伺服器動作 (Server Actions) 被存取。

### 伺服器動作 (Server Actions)

對待 [伺服器動作 (Server Actions)](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) 時，應採用與對外 API 端點相同的安全性考量，並驗證使用者是否被允許執行變更。

在以下範例中，我們在允許動作繼續之前檢查使用者的角色：

```ts filename="app/lib/actions.ts" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction(formData: FormData) {
  const session = await verifySession()
  const userRole = session?.user?.role

  // 如果使用者未獲授權執行此動作，則提前返回
  if (userRole !== 'admin') {
    return null
  }

  // 為獲授權的使用者繼續執行動作
}
```

```js filename="app/lib/actions.js" switcher
'use server'
import { verifySession } from '@/app/lib/dal'

export async function serverAction() {
  const session = await verifySession()
  const userRole = session.user.role

  // 如果使用者未獲授權執行此動作，則提前返回
  if (userRole !== 'admin') {
    return null
  }

  // 為獲授權的使用者繼續執行動作
}
```

### 路由處理器 (Route Handlers)

對待 [路由處理器 (Route Handlers)](/docs/app/building-your-application/routing/route-handlers) 時，應採用與對外 API 端點相同的安全性考量，並驗證使用者是否被允許存取路由處理器。

例如：

```ts filename="app/api/route.ts" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // 使用者驗證和角色檢查
  const session = await verifySession()

  // 檢查使用者是否已驗證
  if (!session) {
    // 使用者未驗證
    return new Response(null, { status: 401 })
  }

  // 檢查使用者是否具有 'admin' 角色
  if (session.user.role !== 'admin') {
    // 使用者已驗證但不具有正確權限
    return new Response(null, { status: 403 })
  }

  // 為獲授權的使用者繼續執行
}
```

```js filename="app/api/route.js" switcher
import { verifySession } from '@/app/lib/dal'

export async function GET() {
  // 使用者驗證和角色檢查
  const session = await verifySession()

  // 檢查使用者是否已驗證
  if (!session) {
    // 使用者未驗證
    return new Response(null, { status: 401 })
  }

  // 檢查使用者是否具有 'admin' 角色
  if (session.user.role !== 'admin') {
    // 使用者已驗證但不具有正確權限
    return new Response(null, { status: 403 })
  }

  // 為獲授權的使用者繼續執行
}
```

上面的範例展示了一個具有兩層安全性檢查的路由處理器。它首先檢查有效的 session，然後驗證登入的使用者是否為 'admin'。

## 上下文提供者 (Context Providers)

由於 [交錯渲染 (interleaving)](/docs/app/getting-started/server-and-client-components#examples#interleaving-server-and-client-components)，使用上下文提供者進行驗證是可行的。然而，React `context` 在伺服器元件中不受支援，因此僅適用於客戶端元件。

這種方式可行，但任何子伺服器元件會先在伺服器上渲染，且無法存取上下文提供者的 session 資料：

```tsx filename="app/layout.ts" switcher
import { ContextProvider } from 'auth-lib'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ContextProvider>{children}</ContextProvider>
      </body>
    </html>
  )
}
```

```tsx filename="app/ui/profile.ts switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

```jsx filename="app/ui/profile.js switcher
'use client';

import { useSession } from "auth-lib";

export default function Profile() {
  const { userId } = useSession();
  const { data } = useSWR(`/api/user/${userId}`, fetcher)

  return (
    // ...
  );
}
```

如果客戶端元件需要 session 資料（例如用於客戶端資料獲取），請使用 React 的 [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue) API 來防止敏感的 session 資料暴露給客戶端。

</AppOnly>

<PagesOnly>

### 建立資料存取層 (DAL)

#### 保護 API 路由

Next.js 中的 API 路由對於處理伺服器端邏輯和資料管理至關重要。保護這些路由以確保只有授權使用者可以存取特定功能非常重要。這通常涉及驗證使用者的驗證狀態和其基於角色的權限。

以下是保護 API 路由的範例：

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // 檢查使用者是否已驗證
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // 檢查使用者是否具有 'admin' 角色
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // 為獲授權的使用者繼續執行路由
  // ... API 路由的實作
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // 檢查使用者是否已驗證
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // 檢查使用者是否具有 'admin' 角色
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // 為獲授權的使用者繼續執行路由
  // ... API 路由的實作
}
```

這個範例展示了一個具有兩層安全性檢查的 API 路由，用於驗證和授權。它首先檢查有效的 session，然後驗證登入的使用者是否為 'admin'。這種方法確保了安全的存取，僅限於已驗證和授權的使用者，保持了請求處理的穩健安全性。

</PagesOnly>

## 資源

現在您已經了解了 Next.js 中的驗證，以下是一些 Next.js 相容的函式庫和資源，可幫助您實現安全的驗證和 session 管理：

### 驗證函式庫

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Better Auth](https://www.better-auth.com/docs/integrations/next)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Logto](https://docs.logto.io/quick-starts/next-app-router)
- [NextAuth.js](https://authjs.dev/getting-started/installation?framework=next.js)
- [Ory](https://www.ory.sh/docs/getting-started/integrate-auth/nextjs)
- [Stack Auth](https://docs.stack-auth.com/getting-started/setup)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [WorkOS](https://workos.com/docs/user-management/nextjs)

### Session 管理函式庫

- [Iron Session](https://github.com/vvo/iron-session)
- [Jose](https://github.com/panva/jose)

## 延伸閱讀

要繼續學習驗證和安全性，請查看以下資源：

- [如何在 Next.js 中思考安全性](/blog/security-nextjs-server-components-actions)
- [理解 XSS 攻擊](https://vercel.com/guides/understanding-xss-attacks)
- [理解 CSRF 攻擊](https://vercel.com/guides/understanding-csrf-attacks)
- [The Copenhagen Book](https://thecopenhagenbook.com/)
