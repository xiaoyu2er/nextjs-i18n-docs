---
source-updated-at: 2025-05-21T18:33:43.000Z
translation-updated-at: 2025-05-25T20:59:08.830Z
title: 資料獲取與快取
nav_title: 資料獲取與快取
description: 學習在 Next.js 中於伺服器或客戶端獲取資料的最佳實踐。
---

<details>
  <summary>範例</summary>

- [Next.js Commerce](https://vercel.com/templates/next.js/nextjs-commerce)
- [On-Demand ISR](https://on-demand-isr.vercel.app)
- [Next.js Forms](https://github.com/vercel/next.js/tree/canary/examples/next-forms)

</details>

本指南將帶您了解 Next.js 中資料獲取與快取的基礎知識，並提供實用範例與最佳實踐。

以下是一個在 Next.js 中進行資料獲取的簡易範例：

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

此範例展示了在非同步 React 伺服器元件中使用 `fetch` API 進行基本的伺服器端資料獲取。

## 參考資料

- [`fetch`](/docs/app/api-reference/functions/fetch)
- React [`cache`](https://react.dev/reference/react/cache)
- Next.js [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)

### 使用 ORM 或資料庫快取資料

您可以在執行 `next build` 時使用 `unstable_cache` API 來快取回應。

```tsx filename="app/page.tsx" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/page.js" switcher
import { unstable_cache } from 'next/cache'
import { db, posts } from '@/lib/db'

const getPosts = unstable_cache(
  async () => {
    return await db.select().from(posts)
  },
  ['posts'],
  { revalidate: 3600, tags: ['posts'] }
)

export default async function Page() {
  const allPosts = await getPosts()

  return (
    <ul>
      {allPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

此範例將資料庫查詢結果快取 1 小時（3600 秒）。同時添加了快取標籤 `posts`，之後可透過[增量靜態再生 (Incremental Static Regeneration)](/docs/app/guides/incremental-static-regeneration) 來使其失效。

### 在多個函式間重複使用資料

Next.js 使用了如 `generateMetadata` 和 `generateStaticParams` 這樣的 API，您需要在 `page` 中使用相同的獲取資料。

如果您使用 `fetch`，可以透過添加 `cache: 'force-cache'` 來[記憶化 (memoize)](/docs/app/deep-dive/caching#request-memoization) 請求。這意味著您可以安全地使用相同的 URL 和選項進行呼叫，且只會發送一次請求。

> **須知：**
>
> - 在舊版 Next.js 中，使用 `fetch` 的預設 `cache` 值為 `force-cache`。這在版本 15 中變更為預設 `cache: no-store`。

```tsx filename="app/blog/[id]/page.tsx" switcher
import { notFound } from 'next/navigation'

interface Post {
  id: string
  title: string
  content: string
}

async function getPost(id: string) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`, {
    cache: 'force-cache',
  })
  const post: Post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog', {
    cache: 'force-cache',
  }).then((res) => res.json())

  return posts.map((post: Post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

```jsx filename="app/blog/[id]/page.js" switcher
import { notFound } from 'next/navigation'

async function getPost(id) {
  const res = await fetch(`https://api.vercel.app/blog/${id}`)
  const post = await res.json()
  if (!post) notFound()
  return post
}

export async function generateStaticParams() {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )

  return posts.map((post) => ({
    id: String(post.id),
  }))
}

export async function generateMetadata({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return {
    title: post.title,
  }
}

export default async function Page({ params }) {
  const { id } = await params
  const post = await getPost(id)

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

如果您**沒有**使用 `fetch`，而是直接使用 ORM 或資料庫，可以使用 React 的 `cache` 函式來包裝您的資料獲取。這將進行去重處理，只會發送一次查詢。

```jsx
import { cache } from 'react'
import { db, posts, eq } from '@/lib/db' // 使用 Drizzle ORM 的範例
import { notFound } from 'next/navigation'

export const getPost = cache(async (id) => {
  const post = await db.query.posts.findFirst({
    where: eq(posts.id, parseInt(id)),
  })

  if (!post) notFound()
  return post
})
```

### 重新驗證快取資料

了解更多關於使用[增量靜態再生 (Incremental Static Regeneration)](/docs/app/guides/incremental-static-regeneration) 重新驗證快取資料的資訊。