---
source-updated-at: 2025-05-25T15:16:02.000Z
translation-updated-at: 2025-05-25T21:03:11.599Z
title: 伺服器操作與資料異動
nav_title: 伺服器操作與資料異動
description: 學習如何使用 Next.js 處理表單提交與資料異動。
related:
  description: 了解如何在 Next.js 中設定伺服器操作
  links:
    - app/api-reference/config/next-config-js/serverActions
---

[伺服器操作 (Server Actions)](https://react.dev/reference/rsc/server-actions) 是在伺服器端執行的**非同步函式**。可在伺服器與客戶端元件中呼叫，用於處理 Next.js 應用程式中的表單提交與資料異動。

> **🎥 觀看影片：** 深入了解使用伺服器操作進行資料異動 → [YouTube (10 分鐘)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg)。

## 慣例

伺服器操作可使用 React 的 [`"use server"`](https://react.dev/reference/react/use-server) 指令定義。您可將指令置於 `async` 函式頂端標記該函式為伺服器操作，或置於獨立檔案頂端標記該檔案所有匯出為伺服器操作。

### 伺服器元件

伺服器元件可使用行內函式層級或模組層級的 `"use server"` 指令。若要行內定義伺服器操作，請在函式主體頂端加入 `"use server"`：

```tsx filename="app/page.tsx" switcher
export default function Page() {
  // 伺服器操作
  async function create() {
    'use server'
    // 異動資料
  }

  return '...'
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  // 伺服器操作
  async function create() {
    'use server'
    // 異動資料
  }

  return '...'
}
```

### 客戶端元件

要在客戶端元件中呼叫[伺服器函式](/docs/app/getting-started/updating-data#server-functions)，請建立新檔案並在頂端加入 `"use server"` 指令。檔案內所有匯出函式將被標記為可在客戶端與伺服器元件中重複使用的伺服器函式：

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {}
```

```tsx filename="app/button.tsx" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>建立</button>
}
```

```jsx filename="app/button.js" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>建立</button>
}
```

### 將操作作為屬性傳遞

您也可將伺服器操作作為屬性傳遞給客戶端元件：

```jsx
<ClientComponent updateItemAction={updateItem} />
```

```tsx filename="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

```jsx filename="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

通常 Next.js TypeScript 插件會標記 `client-component.tsx` 中的 `updateItemAction`，因為這通常是無法在客戶端-伺服器邊界序列化的函式。但名稱以 `action` 結尾或命名為 `Action` 的屬性會被假定為接收伺服器操作。這僅是啟發式規則，因為 TypeScript 插件實際上無法判斷是否接收伺服器操作或普通函式。執行時類型檢查仍會確保您不會意外將函式傳遞給客戶端元件。

## 行為

- 伺服器操作可透過 [`<form>` 元素](#forms)的 `action` 屬性呼叫：
  - 伺服器元件預設支援漸進增強，意味著即使 JavaScript 尚未載入或停用，表單仍會提交。
  - 在客戶端元件中，呼叫伺服器操作的表單若 JavaScript 尚未載入，會排隊提交，優先處理客戶端水合。
  - 水合後，瀏覽器不會在表單提交時重新整理。
- 伺服器操作不限於 `<form>`，可從事件處理程序、`useEffect`、第三方函式庫及其他表單元素如 `<button>` 呼叫。
- 伺服器操作與 Next.js [快取與重新驗證](/docs/app/deep-dive/caching)架構整合。當操作被呼叫時，Next.js 可在單次伺服器往返中同時回傳更新的 UI 與新資料。
- 底層實作中，操作使用 `POST` 方法，且僅此 HTTP 方法可呼叫它們。
- 伺服器操作的參數與回傳值必須可被 React 序列化。請參閱 React 文件了解[可序列化參數與值](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)清單。
- 伺服器操作是函式，意味著可在應用程式中任何地方重複使用。
- 伺服器操作繼承使用它們的頁面或佈局的執行環境。
- 伺服器操作繼承使用它們的頁面或佈局的[路由區段設定](/docs/app/api-reference/file-conventions/route-segment-config)，包括 `maxDuration` 等欄位。

## 範例

### 表單

React 擴充了 HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) 元素，允許透過 `action` 屬性呼叫伺服器操作。

在表單中呼叫時，操作會自動接收 [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData) 物件。您無需使用 React `useState` 管理欄位，而是可使用原生 [`FormData 方法](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods)提取資料：

```tsx filename="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // 異動資料
    // 重新驗證快取
  }

  return <form action={createInvoice}>...</form>
}
```

```jsx filename="app/invoices/page.js" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // 異動資料
    // 重新驗證快取
  }

  return <form action={createInvoice}>...</form>
}
```

> **小知識：**
>
> - 範例：[含載入與錯誤狀態的表單](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - 處理含多欄位的表單時，可考慮使用 [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) 方法搭配 JavaScript 的 [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)。例如：`const rawFormData = Object.fromEntries(formData)`。需注意 `formData` 會包含額外的 `$ACTION_` 屬性。
> - 參閱 [React `<form>` 文件](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action)了解更多。

### 傳遞額外參數

您可使用 JavaScript 的 `bind` 方法傳遞額外參數給伺服器操作。

```tsx filename="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">更新使用者名稱</button>
    </form>
  )
}
```

```jsx filename="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">更新使用者名稱</button>
    </form>
  )
}
```

伺服器操作將接收 `userId` 參數以及表單資料：

```ts filename="app/actions.ts" switcher
'use server'

export async function updateUser(userId: string, formData: FormData) {}
```

```js filename="app/actions.js" switcher
'use server'

export async function updateUser(userId, formData) {}
```

> **小知識：**
>
> - 替代方案是將參數作為隱藏輸入欄位傳遞（如 `<input type="hidden" name="userId" value={userId} />`）。但該值會成為渲染 HTML 的一部分且不會被編碼。
> - `.bind` 在伺服器與客戶端元件中均可使用，也支援漸進增強。

### 巢狀表單元素

您也可在 `<form>` 內巢狀元素如 `<button>`、`<input type="submit">` 和 `<input type="image">` 中呼叫伺服器操作。這些元素接受 `formAction` 屬性或[事件處理程序](#event-handlers)。

這在需要於單一表單中呼叫多個伺服器操作時很有用。例如，除了發布按鈕外，可建立特定 `<button>` 元素用於儲存文章草稿。詳見 [React `<form>` 文件](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)。

### 程式化表單提交

您可使用 [`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) 方法以程式方式觸發表單提交。例如，當使用者使用 `⌘` + `Enter` 鍵盤快捷鍵提交表單時，可監聽 `onKeyDown` 事件：

```tsx filename="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

```jsx filename="app/entry.js" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

這將觸發最近 `<form>` 祖先的提交，從而呼叫伺服器操作。

### 伺服器端表單驗證

您可使用 HTML 屬性如 `required` 和 `type="email"` 進行基本客戶端表單驗證。

對於更進階的伺服器端驗證，可使用如 [zod](https://zod.dev/) 的函式庫在異動資料前驗證表單欄位：

```tsx filename="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無效的電子郵件',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // 若表單資料無效則提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 異動資料
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '無效的電子郵件',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // 若表單資料無效則提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 異動資料
}
```

在伺服器端驗證欄位後，您可在操作中回傳可序列化物件，並使用 React `useActionState` 鉤子向使用者顯示訊息。

- 透過將操作傳遞給 `useActionState`，操作的函式簽名會變更，接收新的 `prevState` 或 `initialState` 參數作為第一個引數。
- `useActionState` 是 React 鉤子，因此必須在客戶端元件中使用。

```tsx filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '請輸入有效的電子郵件' }
  }

  redirect('/dashboard')
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '請輸入有效的電子郵件' }
  }

  redirect('/dashboard')
}
```

接著，您可將操作傳遞給 `useActionState` 鉤子，並使用回傳的 `state` 顯示錯誤訊息。

```tsx filename="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">電子郵件</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>註冊</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">電子郵件</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>註冊</button>
    </form>
  )
}
```

### 待處理狀態

[`useActionState`](https://react.dev/reference/react/useActionState) 鉤子提供了一個 `pending` 布林值，可用於在動作執行時顯示載入指示器。

或者，你也可以使用 [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) 鉤子在動作執行時顯示載入指示器。使用此鉤子時，需要建立一個獨立的元件來渲染載入指示器。例如，在動作待處理時禁用按鈕：

```tsx filename="app/ui/button.tsx" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      註冊
    </button>
  )
}
```

```jsx filename="app/ui/button.js" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      註冊
    </button>
  )
}
```

然後可以將 `SubmitButton` 元件嵌套在表單中：

```tsx filename="app/ui/signup.tsx" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* 其他表單元素 */}
      <SubmitButton />
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* 其他表單元素 */}
      <SubmitButton />
    </form>
  )
}
```

> **須知事項：** 在 React 19 中，`useFormStatus` 返回的物件包含更多鍵值，如 data、method 和 action。如果未使用 React 19，則僅有 `pending` 鍵可用。

### 樂觀更新

你可以使用 React 的 [`useOptimistic`](https://react.dev/reference/react/useOptimistic) 鉤子在伺服器動作完成執行前樂觀地更新 UI，而不需等待回應：

```tsx filename="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  const formAction = async (formData: FormData) => {
    const message = formData.get('message') as string
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m, i) => (
        <div key={i}>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">發送</button>
      </form>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  const formAction = async (formData) => {
    const message = formData.get('message')
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">發送</button>
      </form>
    </div>
  )
}
```

### 事件處理器

雖然通常在 `<form>` 元素中使用伺服器動作，但它們也可以透過事件處理器如 `onClick` 來觸發。例如，增加按讚計數：

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>總按讚數: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        按讚
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>總按讚數: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        按讚
      </button>
    </>
  )
}
```

你也可以為表單元素添加事件處理器，例如在 `onChange` 時儲存表單欄位：

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">發布</button>
    </form>
  )
}
```

對於這種可能快速觸發多次事件的情況，我們建議使用**防抖** (debouncing) 來避免不必要的伺服器動作調用。

### `useEffect`

你可以使用 React 的 [`useEffect`](https://react.dev/reference/react/useEffect) 鉤子在元件掛載或依賴項變化時調用伺服器動作。這對於依賴全局事件或需要自動觸發的變更非常有用。例如，`onKeyDown` 處理應用快捷鍵、無限滾動的交集觀察器鉤子，或在元件掛載時更新瀏覽次數：

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    startTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // 可以使用 `isPending` 向用戶提供反饋
  return <p>總瀏覽次數: {views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    starTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // 可以使用 `isPending` 向用戶提供反饋
  return <p>總瀏覽次數: {views}</p>
}
```

請記住考慮 [`useEffect` 的行為與注意事項](https://react.dev/reference/react/useEffect#caveats)。

### 錯誤處理

當錯誤被拋出時，它會被客戶端最近的 `error.js` 或 `<Suspense>` 邊界捕獲。詳情請參閱[錯誤處理](/docs/app/building-your-application/routing/error-handling)。

> **須知事項：**
>
> - 除了拋出錯誤外，你也可以返回一個物件供 `useActionState` 處理。請參閱[伺服器端表單驗證與錯誤處理](#server-side-form-validation)。

### 重新驗證資料

你可以在伺服器動作中使用 [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) API 重新驗證 [Next.js 快取](/docs/app/deep-dive/caching)：

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

或者使用 [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) 透過快取標籤使特定資料獲取失效：

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### 重新導向

如果希望在伺服器動作完成後將用戶重新導向到不同路由，可以使用 [`redirect`](/docs/app/api-reference/functions/redirect) API。`redirect` 需要在 `try/catch` 區塊外調用：

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // 更新快取文章
  redirect(`/post/${id}`) // 導向新文章頁面
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // 更新快取文章
  redirect(`/post/${id}`) // 導向新文章頁面
}
```

### Cookies

你可以使用 [`cookies`](/docs/app/api-reference/functions/cookies) API 在伺服器動作中 `get`、`set` 和 `delete` cookies：

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // 獲取 cookie
  cookieStore.get('name')?.value

  // 設定 cookie
  cookieStore.set('name', 'Delba')

  // 刪除 cookie
  cookieStore.delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // 獲取 cookie
  const cookieStore = await cookies()

  // 獲取 cookie
  cookieStore.get('name')?.value

  // 設定 cookie
  cookieStore.set('name', 'Delba')

  // 刪除 cookie
  cookieStore.delete('name')
}
```

參閱[其他範例](/docs/app/api-reference/functions/cookies#deleting-cookies)了解如何從伺服器動作刪除 cookies。

## 安全性

預設情況下，當建立並匯出一個伺服器動作時，它會建立一個公開的 HTTP 端點，應以相同的安全假設和授權檢查來對待。這意味著，即使伺服器動作或工具函數未在程式碼其他地方導入，它仍然是公開可訪問的。

為提升安全性，Next.js 具有以下內建功能：

- **安全動作 ID：** Next.js 建立加密、非確定性的 ID，允許客戶端引用和調用伺服器動作。這些 ID 會在構建之間定期重新計算以增強安全性。
- **死碼消除：** 未使用的伺服器動作（由其 ID 引用）會從客戶端套件中移除，避免第三方公開訪問。

> **須知事項：**
>
> ID 在編譯期間建立，並快取最多 14 天。它們會在啟動新構建或構建快取失效時重新生成。
> 此安全改進降低了在缺少驗證層的情況下的風險。然而，你仍應將伺服器動作視為公開 HTTP 端點。

```jsx
// app/actions.js
'use server'

// 此動作**有**在我們的應用程式中使用，因此 Next.js
// 會建立一個安全 ID 以允許客戶端引用
// 並調用伺服器動作。
export async function updateUserAction(formData) {}

// 此動作**未**在我們的應用程式中使用，因此 Next.js
// 會在 `next build` 時自動移除此程式碼
// 並且不會建立公開端點。
export async function deleteUserAction(formData) {}
```

### 驗證與授權

你應確保用戶有權執行該動作。例如：

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('你必須登入才能執行此動作')
  }

  // ...
}
```

### 閉包與加密

在元件內定義伺服器動作會建立一個[閉包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)，使動作能訪問外部函數的作用域。例如，`publish` 動作能訪問 `publishVersion` 變數：

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('按下發布後版本已變更');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>發布</button>
    </form>
  );
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('按下發布後版本已變更');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>發布</button>
    </form>
  );
}
```

閉包在需要捕捉資料的_快照_（如 `publishVersion`）以便在動作調用時使用時非常有用。

然而，為實現這一點，捕捉的變數會被發送到客戶端並在動作調用時返回伺服器。為防止敏感資料暴露給客戶端，Next.js 會自動加密閉包變數。每次構建 Next.js 應用時，都會為每個動作生成一個新的私鑰。這意味著動作只能在特定構建中調用。

> **須知事項：** 我們不建議僅依賴加密來防止敏感值暴露在客戶端。相反，你應使用 [React taint API](/docs/app/api-reference/config/next-config-js/taint) 主動防止特定資料發送到客戶端。

### 覆寫加密金鑰（進階）

當在多個伺服器上自託管 Next.js 應用時，每個伺服器實例可能最終使用不同的加密金鑰，導致潛在的不一致。

為緩解此問題，你可以使用 `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY` 環境變數覆寫加密金鑰。指定此變數可確保加密金鑰在構建之間保持持久性，且所有伺服器實例使用相同的金鑰。此變數**必須**使用 AES-GCM 加密。

這是一個進階使用情境，其中跨多個部署的一致加密行為對你的應用至關重要。你應考慮標準安全實踐，如金鑰輪換和簽名。

> **須知事項：** 部署到 Vercel 的 Next.js 應用會自動處理此問題。

### 允許的來源 (進階)

由於伺服器動作 (Server Actions) 可以在 `<form>` 元素中調用，這使得它們容易受到 [CSRF 攻擊](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) 的影響。

在底層，伺服器動作使用 `POST` 方法，且僅允許此 HTTP 方法來調用它們。這在現代瀏覽器中防止了大多數 CSRF 漏洞，特別是當 [SameSite cookies](https://web.dev/articles/samesite-cookies-explained) 成為預設值時。

作為額外的保護措施，Next.js 中的伺服器動作還會比較 [Origin 標頭](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) 與 [Host 標頭](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host) (或 `X-Forwarded-Host`)。如果這些標頭不匹配，請求將被中止。換句話說，伺服器動作只能在與託管它的頁面相同的主機上調用。

對於使用反向代理或多層後端架構 (其中伺服器 API 與生產網域不同) 的大型應用程式，建議使用配置選項 [`serverActions.allowedOrigins`](/docs/app/api-reference/config/next-config-js/serverActions) 來指定安全來源的清單。該選項接受一個字串陣列。

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

了解更多關於 [安全性與伺服器動作](https://nextjs.org/blog/security-nextjs-server-components-actions) 的資訊。

## 其他資源

如需更多資訊，請查看以下 React 文件：

- [伺服器動作 (Server Actions)](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
