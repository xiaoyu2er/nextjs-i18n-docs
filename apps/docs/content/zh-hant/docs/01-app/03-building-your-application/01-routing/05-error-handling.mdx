---
source-updated-at: 2025-05-21T18:33:43.000Z
translation-updated-at: 2025-05-25T21:00:45.767Z
title: 錯誤處理
description: 了解如何顯示預期錯誤並處理未捕獲的例外情況。
related:
  links:
    - app/api-reference/file-conventions/error
---

錯誤可分為兩類：**預期錯誤** 和 **未捕獲例外**：

- **將預期錯誤建模為回傳值**：在伺服器動作 (Server Actions) 中避免對預期錯誤使用 `try`/`catch`。使用 [`useActionState`](https://react.dev/reference/react/useActionState) 來管理這些錯誤並將其回傳至客戶端。
- **對意外錯誤使用錯誤邊界 (Error Boundaries)**：透過 `error.tsx` 和 `global-error.tsx` 檔案實作錯誤邊界，處理意外錯誤並提供備用 UI。

## 處理預期錯誤

預期錯誤是指在應用程式正常運作期間可能發生的錯誤，例如來自[伺服器端表單驗證](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation)或失敗請求的錯誤。這些錯誤應明確處理並回傳至客戶端。

### 處理來自伺服器動作的預期錯誤

使用 `useActionState` 鉤子 (hook) 來管理伺服器動作的狀態，包括處理錯誤。此方法避免了對預期錯誤使用 `try`/`catch` 區塊，這些錯誤應建模為回傳值而非拋出的例外。

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: 'Please enter a valid email' }
  }

  redirect('/dashboard')
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: 'Please enter a valid email' }
  }

  redirect('/dashboard')
}
```

接著，您可以將動作傳遞給 `useActionState` 鉤子，並使用回傳的 `state` 來顯示錯誤訊息。

```tsx filename="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>Sign up</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">Email</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>Sign up</button>
    </form>
  )
}
```

您也可以使用回傳的狀態來顯示客戶端元件 (Client Component) 的提示訊息。

### 處理來自伺服器元件的預期錯誤

在伺服器元件 (Server Component) 內擷取資料時，您可以使用回應來條件式渲染錯誤訊息或 [`redirect`](/docs/app/building-your-application/routing/redirecting#redirect-function)。

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const res = await fetch(`https://...`)
  const data = await res.json()

  if (!res.ok) {
    return 'There was an error.'
  }

  return '...'
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const res = await fetch(`https://...`)
  const data = await res.json()

  if (!res.ok) {
    return 'There was an error.'
  }

  return '...'
}
```

## 未捕獲例外

未捕獲例外是指示錯誤或問題的意外錯誤，這些問題不應在應用程式的正常流程中發生。這些應透過拋出錯誤來處理，然後由錯誤邊界捕獲。

- **常見**：使用 `error.js` 處理根佈局 (root layout) 下的未捕獲錯誤。
- **可選**：使用巢狀 `error.js` 檔案（例如 `app/dashboard/error.js`）處理細粒度的未捕獲錯誤。
- **不常見**：使用 `global-error.js` 處理根佈局中的未捕獲錯誤。

### 使用錯誤邊界

Next.js 使用錯誤邊界來處理未捕獲例外。錯誤邊界會捕獲其子元件中的錯誤，並顯示備用 UI 而非崩潰的元件樹。

透過在路由區段內新增 `error.tsx` 檔案並匯出 React 元件來建立錯誤邊界：

```tsx filename="app/dashboard/error.tsx" switcher
'use client' // 錯誤邊界必須是客戶端元件

import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // 將錯誤記錄到錯誤報告服務
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>發生錯誤！</h2>
      <button
        onClick={
          // 嘗試透過重新渲染區段來恢復
          () => reset()
        }
      >
        重試
      </button>
    </div>
  )
}
```

```jsx filename="app/dashboard/error.js" switcher
'use client' // 錯誤邊界必須是客戶端元件

import { useEffect } from 'react'

export default function Error({ error, reset }) {
  useEffect(() => {
    // 將錯誤記錄到錯誤報告服務
    console.error(error)
  }, [error])

  return (
    <div>
      <h2>發生錯誤！</h2>
      <button
        onClick={
          // 嘗試透過重新渲染區段來恢復
          () => reset()
        }
      >
        重試
      </button>
    </div>
  )
}
```

如果您希望錯誤冒泡至父錯誤邊界，可以在渲染 `error` 元件時 `throw`。

### 處理巢狀路由中的錯誤

錯誤會冒泡至最近的父錯誤邊界。這允許透過在[路由階層](/docs/app/getting-started/project-structure#component-hierarchy)的不同層級放置 `error.tsx` 檔案來實現細粒度的錯誤處理。

<Image
  alt="巢狀錯誤元件階層"
  srcLight="/docs/light/nested-error-component-hierarchy.png"
  srcDark="/docs/dark/nested-error-component-hierarchy.png"
  width="1600"
  height="687"
/>

### 處理全域錯誤

雖然較不常見，但您可以使用位於根應用程式目錄中的 `app/global-error.js` 來處理根佈局中的錯誤，即使在使用[國際化](/docs/app/guides/internationalization)時也是如此。全域錯誤 UI 必須定義自己的 `<html>` 和 `<body>` 標籤，因為它在啟用時會取代根佈局或模板。

```tsx filename="app/global-error.tsx" switcher
'use client' // 錯誤邊界必須是客戶端元件

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    // global-error 必須包含 html 和 body 標籤
    <html>
      <body>
        <h2>發生錯誤！</h2>
        <button onClick={() => reset()}>重試</button>
      </body>
    </html>
  )
}
```

```jsx filename="app/global-error.js" switcher
'use client' // 錯誤邊界必須是客戶端元件

export default function GlobalError({ error, reset }) {
  return (
    // global-error 必須包含 html 和 body 標籤
    <html>
      <body>
        <h2>發生錯誤！</h2>
        <button onClick={() => reset()}>重試</button>
      </body>
    </html>
  )
}
```