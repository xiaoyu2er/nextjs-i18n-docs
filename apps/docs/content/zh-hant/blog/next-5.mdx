---
source-updated-at: 2025-05-29T18:05:49.000Z
translation-updated-at: 2025-05-29T19:53:42.113Z
title: 'Next.js 5：通用 Webpack、CSS 導入、插件與區域功能'
description: 'Next.js 5 聚焦於更強的擴展性、大型應用組合能力與效能提升'
author:
  - name: Arunoda Susiripala
    image: /static/team/arunoda.jpg
  - name: Tim Neutkens
    image: /static/team/tim.jpg
date: 2018-02-05T19:10:43.056Z
image: 'https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-5/twitter-card.png'
---

我們非常高興向世界介紹 Next.js 5.0，現已立即在 npm 上提供。升級請執行：

```bash filename="終端機"
npm i next@latest react@latest react-dom@latest
```

> 除了升級 Next.js 外，我們也同時升級了 peer dependencies 的 `react` 和 `react-dom`

Next.js 是一套用於通用型、伺服器渲染（或靜態預渲染）React.js 應用的工具包。開始開發任何規模的應用都像執行 `next` 一樣簡單。（[了解更多](https://vercel.com/blog/next)）

在每個新版本中，我們都致力於保持向後兼容性，提供簡單的升級路徑，並只在絕對必要時進行 API 變更。Next.js 5.0 也不例外。

然而在底層，Next.js 經歷了根本性的變革，以實現強大的新用例和擴展性。我們首先讓 Next.js 共享一個通用的 Webpack 管道，同時處理伺服器和客戶端程式碼。

[通用 Webpack 與 Next 插件](#universal-webpack-and-next-plugins)
-------------------------------------------------------------------------

Next.js 利用現有的強大工具如 Webpack、Babel 和 Uglify，為終端用戶提供極簡介面：`next`（開發用）、`next build`（生產準備）、`next start`（運行服務）或 `next export`（預渲染為靜態檔案）。

我們早期的一個決策是為這些工具的配置提供極強的擴展點。我們不僅追求易用性，更希望讓您能靈活擴展工具包。

例如，您可以通過在 `next.config.js` 中設置 `webpack` 屬性來[擴展 Next.js 的 webpack 配置](https://github.com/vercel/next.js#customizing-webpack-config)。

由於 webpack 在生產和開發環境下的執行方式不同，我們當時決定讓它成為**一個函數**，用於修飾我們的預設 webpack 配置：

```js filename="next.config.js"
module.exports = {
  webpack(config, { dev }) {
    // 修改配置！
    return config;
  },
};
```

> 可選的 `next.config.js` 檔案範例

然而，Webpack 只會在客戶端（瀏覽器）套件上執行，您將無法在伺服器渲染中使用這個強大的工具鏈。

我們很高興宣布，我們已全面重構程式碼庫，**讓 Webpack 實現通用化運行**。

從您的角度來看，唯一的變化是上述裝飾函數會多接收一個 `isServer` 屬性。但新的語意意味著您現在可以使用豐富的 Webpack 生態系統加載器。

### [CSS、LESS、SASS、SCSS 與 CSS 模組](#css-less-sass-scss-and-css-modules)

我們最常被請求的功能之一就是能夠導入 CSS 檔案並利用 Webpack 加載器：

```
import './index.css';
 
export default function Index() {
  return (
    <div>
      <p>我愛 CSS！</p>
    </div>
  );
}
```

> 一個頁面範例（`pages/index.js`），利用通用 Webpack 實現 CSS 導入

要實現此功能，您可以將需要的加載器作為 peer dependencies 引入：

```bash filename="終端機"
npm i --save css-loader style-loader postcss-loader
```

> Next.js 讓您可以自由選擇需要的加載器，並隨時升級到不同版本。

然後擴展配置來設置您的加載器。在 `next.config.js` 中：

```js filename="next.config.js"
module.exports = {
  webpack(config, options) {
    const { dev, isServer } = options;
    const extractCSSPlugin = new ExtractTextPlugin({
      filename: 'static/style.css',
      disable: dev,
    });
    config.module.rules.push({
      test: /\\.css$/,
      use: cssLoaderConfig(extractCSSPlugin, {
        cssModules,
        dev,
        isServer,
      }),
    });
    return config;
  },
};
```

> 擴展原始 webpack 配置賦予您極大的靈活性和控制權

雖然我們一般推薦使用元件本地樣式解決方案，如[內建的 `styled-jsx` babel 插件](https://github.com/vercel/next.js#built-in-css-support)，但我們認為 CSS 加載器有許多重要優勢，例如易於重用現有 CSS 程式碼庫，並大大簡化將舊程式碼庫遷移到 Next.js 的過程。

與其預設啟用所有可能的功能和加載器，我們引入了 [**Next.js 插件**](https://github.com/vercel/next-plugins)，它們是_修飾配置的簡單函數_。與上述手動擴展配置設置加載器不同，您只需：

```
const withCss = require('next-css');
module.exports = withCss({
  /* 額外的可選配置 */
});
```

> 只需引入 `next-css` 即可啟用 `.css` 檔案導入

了解更多關於 [CSS 加載器](https://github.com/vercel/next-plugins/tree/master/packages/next-css) 在 Next.JS 中的使用，或參考我們已為您創建的一些套件：

加載器

套件

CSS

[next-css](https://github.com/vercel/next-plugins/tree/master/packages/next-css)

LESS

[next-less](https://github.com/vercel/next-plugins/tree/master/packages/next-less)

SASS

[next-sass](https://github.com/vercel/next-plugins/tree/master/packages/next-sass)

我們的目標是讓社區能夠開發和成長一個實用簡單的擴展生態系統。為此，我們開放 [next-plugins](https://github.com/vercel/next-plugins) monorepo 供 Next.js 社區維護。歡迎所有 PR！

### [TypeScript 支援](#typescript-support)

TypeScript 是 JavaScript 生態系統中[增長最快的技術](https://stateofjs.com/2017/flavors/results)之一。它的發展如此迅速，以至於 [Babel 7 官方支援](https://github.com/babel/babel/tree/master/packages/babel-preset-typescript)它，這意味著只需[自訂您的 .babelrc](https://github.com/vercel/next.js#customizing-babel-config)，它自然就會被 Next.js 支援。

與此同時，得益於我們新的通用 Webpack 支援，您_現在_就可以獲得完整的 TypeScript 支援！

您可以像這樣擴展您的 webpack 配置：

```js filename="next.config.js"
module.exports = {
  webpack(config, options) {
    const { dir, defaultLoaders } = options;
    config.resolve.extensions.push('.ts', '.tsx');
    config.module.rules.push({
      test: /\\.+(ts|tsx)$/,
      include: [dir],
      exclude: /node_modules/,
      use: [
        defaultLoaders.babel,
        { loader: 'ts-loader', options: { transpileOnly: true } },
      ],
    });
    return config;
  },
};
```

> 我們只需啟用 `ts-loader`

與 CSS 加載器和預處理器一樣，TypeScript 是最常被請求的功能之一。為了讓它像其他加載器一樣容易整合到專案中，我們現在有一個 [`next-typescript` 插件](/) 可以包含在您的 `next.config.js` 檔案中：

```js filename="next.config.js"
const withTs = require('next-typescript');
module.exports = withTs({
  /* 額外配置 */
});
```

> 插件可以輕鬆組合：它們只是函數

### [更好的 React 替代庫與模組覆載支援](#better-support-for-react-altlibs--module-overloading)

隨著時間推移，出現了許多 React 的替換實現。其中一些值得注意的有 [`preact`](https://preactjs.com/)、[`nervjs`](https://github.com/NervJS/nerv) 和 [`inferno`](https://github.com/infernojs/inferno)。

其他庫專注於替換 DOM 渲染器，如 [`react-dom-lite`](https://github.com/jquense/react-dom-lite)，它通過在瀏覽器兼容性上做出一些微小妥協，來實現更小的 React 構建。

通用 Webpack 支援讓**將這些庫作為替換方案整合的過程更加容易**。與其他插件一樣，這就是使用 Next.js 與 preact 所需做的全部：

```bash filename="終端機"
npm i @zeit/next-preact preact preact-compat
```

> 我們安裝 preact 插件和必要的 peer dependencies

```
const withPreact = require('@zeit/next-preact');
module.exports = withPreact();
```

> 我們新的 `next.config.js` 已準備好用於 preact

查看非常簡單的 [@zeit/next-preact](https://github.com/vercel/next-plugins/tree/master/packages/next-preact) 模組或創建您自己的！

### [可選的生產環境外部源碼映射 (Optional External Sourcemaps in Production)](#optional-external-sourcemaps-in-production)

現在 Next.js 同時使用 webpack 處理客戶端和伺服器端程式碼，只需對配置進行小幅調整即可在生產環境建置中啟用源碼映射 (source maps)。

開發環境中源碼映射會自動啟用，因此我們針對生產環境進行了不同的配置：

```js filename="next.config.js"
module.exports = {
  webpack(config, { dev }) {
    if (!dev) {
      config.devtool = 'source-map';
    }
    return config;
  },
};
```

> 我們只需在非開發環境時對 `devtool` 選項進行不同的配置

[區域 (Zones)](#zones)
---------------

Next.js 從一開始就設定的[核心目標](https://deck.vercel.app)之一，是恢復並保持 Web 的簡潔性。

伺服器渲染 (SSR)、簡單且無關框架的資料獲取方式，以及基於檔案系統結構的宣告式頁面，都是我們根據這一理念引入的功能。

網路服務和網站經常被忽視的一個特性是它們「天然的可組合性和可擴展性」。

舉例來說，`mydomain.com/settings` 和 `mydomain.com/` 可以是兩個完全獨立的應用程式，各自獨立部署、獨立擴展，甚至運行相同軟體的不同版本。

要將它們「黏合」成終端用戶的統一體驗，只需對後端路由層或負載均衡器進行[簡單配置](/docs/pages/building-your-application/configuring/absolute-imports-and-module-aliases)。我們很高興現在能夠提供**組合多個 Next.js 應用程式**的能力，這些應用程式可以使用普通的 `<Link>` 元件連接在一起。我們稱此功能為**區域 (Zones)**。

例如，考慮這兩個部署在 [Vercel](https://vercel.com) 上的獨立 Next.js 應用程式：

*   [https://front.vercel.app](https://front.vercel.app)
*   [https://zeit-docs-zbqbsrucga.vercel.app/docs](https://zeit-docs-zbqbsrucga.vercel.app/docs) [https://zeit-docs-zbqbsrucga.vercel.app/api](https://zeit-docs-zbqbsrucga.vercel.app/api)

![我們的頁面擁有無縫體驗，但它們屬於不同的應用程式](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-5/zones.png)

當我們改版文件時，希望讓社群貢獻變得盡可能簡單。

我們決定將文件「迷你網站」拆分到[自己的儲存庫](https://github.com/vercel/docs)。此外，每當有拉取請求 (PR) 提交並提出變更時，我們會自動將其獨立部署：

![每當 PR 中有變更時，我們的機器人會自動部署它](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-5/github.png)

最終我們得到了兩個區域，它們通過我們的[路徑別名功能](/docs/pages/building-your-application/configuring/absolute-imports-and-module-aliases)整合到父網域 `https://vercel.com` 中。配置如下：

```
{
  "rules": [
    { "pathname": "/docs", "dest": "our-docs.vercel.app" },
    { "pathname": "/api", "dest": "our-docs.vercel.app" },
    { "dest": "my-main-website.vercel.app" }
  ]
}
```

> 這些簡單規則讓您可以組合微服務和區域

最後只需執行 `now alias` 指令：

```bash filename="Terminal"
now alias -r rules.json my-domain.com
```

我們的使命是讓部署盡可能普及和開放。為了協助本地開發，我們最近開源了 `micro-proxy`，這是一個使用上述相同配置格式的工具。

您同樣可以使用 Nginx、HAProxy 或 API Gateway 等其他解決方案來連接區域。

[更快的生產環境建置時間 (Faster Production Build Times)](#faster-production-build-times)
---------------------------------------------------------------

我們認為開發者體驗和使用者體驗相輔相成。變更的編寫、測試和部署效率越高，新功能添加速度越快，錯誤修復越快，整體使用者體驗就越好。

因此，我們持續專注於優化系統最基本構建塊的性能表現。

在 Next.js 5.0 中，我們有機會重新審視 `next build` 指令，這是您在部署到生產環境或將 Next.js 應用程式[導出為靜態網站](/docs/pages/building-your-application/deploying/static-exports)之前運行的指令。

我們很高興地報告，對於由數千個元件組成的 React 應用程式 vercel.com，Next.js 5.0 帶來了顯著的改進，**生產環境建置時間減少了 23.6%**：

![我們的主要應用程式生產建置現在減少了 38 秒](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-5/build.png)

[動態導入的改進快取 (Improved Caching for Dynamic Imports)](#improved-caching-for-dynamic-imports)
-----------------------------------------------------------------------------

當您使用動態 `import()` 時，這會向 WebPack 發出信號，表明存在新的代碼分割入口點。

在建置時，這意味著為相應的模組子樹生成特定的包。

在 Next.js 5.0 之前，動態包會獲得類似以下 URL：

```
/_next/1517592683901/webpack/chunks/components_hello1_1345d10fc951cd6717c5676c467579a6.js
```

現在，我們已將動態導入轉換為子樹內容的內容可尋址雜湊：

```
/_next/webpack/chunks/components_hello1_1345d10fc951cd6717c5676c467579a6-b7874680a9e21fb6eb89.js
```

這意味著跨部署時，您的用戶和客戶無需重新下載已經使用過的代碼。

[片段 (Fragments)](#fragments)
-----------------------

Next.js 建置了一個頂層 `<Document>` 元件，該元件會與每個頁面一起進行伺服器渲染。[重載此元件](/)讓您可以完全控制標記，實現許多[進階用例](https://github.com/vercel/next.js/tree/canary/examples)。

初始標記的一部分是 Next.js 需要在客戶端評估的腳本列表。自訂的 `_document` 如下所示：

```js filename="pages/_document.js"
import Document, { Head, Main, NextScript } from 'next/document';
export default class extends Document {
  render() {
    return (
      <html>
        <Head />
        <body>
          <Main />
          <NextScript />
        </body>
      </html>
    );
  }
}
```

> `Document` 允許您自訂頁面的整個伺服器渲染輸出

直到最近，我們還被迫將腳本包裹在 `<div>` 中。

在 Next.js 5.0 中，我們現在利用了新的 `Fragment` 支援，這轉化為**更輕量的頁面**和對頁面樣式的完全控制，沒有多餘的標記。

[更準確的錯誤訊息 (More Accurate Errors)](#more-accurate-errors)
---------------------------------------------

Node.js 不支援源碼映射，伺服器端發生的錯誤會伴隨指向編譯後代碼的堆疊追蹤。

在 Next 5 中，我們改進了伺服器端的源碼映射支援。伺服器渲染時發生的錯誤現在會指向正確的函數和行號。

![錯誤現在顯示正確的行號、檔案和函數名稱](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-5/errors.png)

[結論 (Conclusion)](#conclusion)
-------------------------

Universal Webpack 鞏固了 Next.js 的基礎，使其更具未來性。總的來說，不再有人為區分哪些插件或加載器適用於 Next.js，哪些不適用。

秉承「零配置」的精神，我們很高興推出 [Next Plugins](https://github.com/vercel/next-plugins)，這是一個社群儲存庫，包含自動擴展 Next.js 功能的配方，無需調整特定選項。

通過這一點，我們現在支援所有 CSS 解決方案、編譯到 JS 的語言（如 TypeScript）和 React 替代方案（如 [Nerve](https://github.com/NervJS/nerv)），只需引入額外模組並在 `next.config.js` 中明確包含它們即可。簡單而不隱晦。

區域允許互連不在同一儲存庫甚至同一伺服器上的 Next.js 應用程式。我們認為這是「團隊可擴展性」改進類別中非常重要的一個里程碑。

因此，Next.js 成為由多個團隊維護的大型應用程式的絕佳選擇。他們現在可以並發部署改進，減少錯誤面，提高迭代速度，甚至嘗試除我們核心之外的各種不同技術，例如[多種不同方法](https://github.com/vercel/next.js/tree/canary/examples)的狀態管理或資料獲取。

我們要藉此機會感謝 Deep Varma 和 [Trulia](https://trulia.com) 工程團隊貢獻的關鍵見解、代碼和測試，這些促成了此功能的設計。

一如既往，如果沒有眾多開源貢獻者和我們優秀的社群，這個版本是不可能實現的。
