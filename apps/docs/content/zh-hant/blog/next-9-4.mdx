Next.js 是一個用於構建全端網頁應用程式的 React 框架。您可以使用 React 元件來建構使用者介面，並透過 Next.js 獲得額外的功能與優化。

它還會自動配置像打包工具 (bundler) 和編譯器 (compiler) 這類底層工具。如此一來，您便能專注於產品開發並快速交付。

無論您是獨立開發者或是團隊成員，Next.js 都能協助您建構互動式、動態且快速的 React 應用程式。

<AppOnly>
</AppOnly>

<PagesOnly>
</PagesOnly>---
source-updated-at: 2025-05-29T19:07:21.000Z
translation-updated-at: 2025-05-29T19:27:01.929Z
title: Next.js 9.4
description: >-
  Next.js 9.4 帶來了 React Fast Refresh、增量靜態再生 (Incremental Static Regeneration)、新環境變數支援、內建 Fetch 等多項功能！
author:
  - name: JJ Kasper
    image: /static/team/jj.jpg
  - name: Joe Haddad
    image: /static/team/timer.jpg
  - name: Luis Alvarez
    image: /static/team/lfades.jpg
  - name: Shu Uesugi
    image: /static/team/chibicode.jpg
  - name: Tim Neutkens
    image: /static/team/tim.jpg
date: 2020-05-11T15:00:00.479Z
image: >-
  https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/twitter-card.png
---

我們非常興奮地向您介紹 Next.js 9.4，主要功能包括：

*   **[Fast Refresh](#fast-refresh)**：快速可靠的即時編輯體驗，已在 [Facebook 規模](https://twitter.com/dan_abramov/status/1152689338553131008) 得到驗證
*   **[增量靜態再生 (beta)](#incremental-static-regeneration-beta)**：部署後以毫秒級速度重新構建靜態頁面
*   **[CMS 範例](#cms-examples)**：提供 [Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape) 的範例，使用我們新的 [次世代靜態網站生成](/blog/next-9-3)
*   **[新環境變數支援](#new-environment-variables-support)**：內建支援 `.env` 和 `NEXT_PUBLIC_` 前綴，如同在 CRA 中所見
*   **[改進的內建 Fetch 支援](#improved-built-in-fetch-support)**：棄用 `node-fetch` 和 `isomorphic-fetch`，改用內建的 `fetch` polyfill，適用於 Node.js 和所有瀏覽器（建置時和執行時）
*   **[整合式 Web Vitals 報告](#integrated-web-vitals-reporting)**：從真實流量中捕捉影響 Lighthouse 分數的 [指標](https://web.dev/vitals/)
*   **[絕對路徑導入與別名](#absolute-imports-and-aliases)**：更清晰簡短的導入語句，避免 `../../../` 的混亂
*   **[可配置的 Sass 支援](#configurable-sass-support)**：[配置 `includePaths`](https://sass-lang.com/documentation/js-api#includepaths) 和我們 [內建 Sass 支援](/docs/pages/building-your-application/styling#sass-support) 的其他選項
*   **[改進的日誌輸出](#improved-log-output)**：更易讀、格式一致且減少重複的終端機輸出

[Fast Refresh](#fast-refresh)
-----------------------------

Fast Refresh 是一種新的熱重新載入體驗，可讓您在編輯 React 元件時獲得即時反饋。現在 Next.js 9.4 或更新版本的所有專案都 **預設啟用** 此功能。

熱重新載入功能 [已存在很長時間](https://github.com/gaearon/react-hot-loader)，但 [歷史上一直](https://github.com/gaearon/react-hot-loader/blob/master/docs/Troubleshooting.md) [過於脆弱](https://github.com/gaearon/react-hot-loader/issues?q=is%3Aissue)，無法預設在工作流程中使用。因此，Next.js 之前實現了一種粗略的熱重新載入形式，會重置整個應用程式的狀態。

舊的熱重新載入實現在編譯或執行時錯誤時不夠穩健，如果您在編輯 CSS 或 JavaScript 時打錯字，它會完全重新載入您的應用程式。這不夠理想且會打斷您的思路。

Fast Refresh 深度整合到 React 本身（[透過 React Refresh](https://github.com/facebook/react/tree/master/packages/react-refresh)），使 Next.js 能夠對 React 元件樹執行精確的預測性更新。

這意味著 Next.js 只會更新您編輯的文件中的程式碼，並且僅重新渲染該元件，**而不會丟失元件狀態**。這包括樣式（行內、CSS-in-JS 或 CSS/Sass Modules）、標記、事件處理程序和效果（透過 `useEffect`）。

一個包含編譯和執行時錯誤（快速恢復）以及保留狀態的編輯過程。

作為此體驗的一部分，我們完全重新設計了錯誤覆蓋層，使其更有幫助並使您的應用程式對拼寫錯誤或執行時錯誤更具韌性。這包括但不限於：

*   **準確的錯誤位置**，解析為您的程式碼在編譯前的 **原始行和列**
*   上下文相關的 **原始碼片段**，並能 **點擊在編輯器中開啟**
*   修復語法錯誤後 **恢復開發階段**，**不丟失應用程式狀態**
*   修復錯誤時 **自動解除** 未處理的執行時錯誤

我們要感謝 [Dan Abramov](https://twitter.com/dan_abramov) 在實現此功能時提供的寶貴貢獻和協助。

[增量靜態再生 (beta)](#incremental-static-regeneration-beta)
-------------------------------------------------------------------------------

Next.js 在 9.3 版本中引入了靜態網站生成方法，目標明確：我們應該獲得 [靜態的優勢](https://rauchg.com/2020/2019-in-review#static-is-the-new-dynamic)（始終快速、始終在線、[全球分發](https://rauchg.com/2020/static-hoisting#hoist-to-the-edge)），同時對動態數據提供出色的支援，這也是 Next.js 的知名特色。

為了兼得兩者的優勢，Next.js 支援 **增量靜態生成**，在您已經建構網站後更新靜態內容。例如，在 9.3 版本中，我們引入了 `getStaticPaths` 中的 `fallback: true` 選項，允許您在執行時新增 **新頁面**。

我們最近 [整理了一個範例](https://on-demand-isr.vercel.app/) 展示 Next.js 如何以這種方式靜態預渲染無限數量的頁面。

今天，我們還引入了 **增量靜態再生 (beta)**，這是一種 **更新現有頁面** 的機制，透過在背景中隨著流量進入重新渲染它們。受 [stale-while-revalidate](https://tools.ietf.org/html/rfc5861) 啟發，這確保流量不間斷地提供服務，始終靜態地提供，並且新構建的頁面僅在生成完成後推送。

```js filename="pages/blog/[slug].js"
export async function getStaticProps() {
  return {
    props: await getDataFromCMS(),
    // 我們將嘗試重新生成頁面：
    // - 當請求進入時
    // - 最多每秒一次
    unstable_revalidate: 1,
  };
}
```

與 SSR 不同，增量靜態再生確保您保留靜態的優勢：

*   沒有延遲峰值。頁面始終快速提供。
*   頁面永遠不會離線。如果背景頁面重新生成失敗，舊頁面保持不變。
*   低數據庫和後端負載。頁面最多同時重新計算一次。

這兩種增量功能（新增頁面和懶惰更新它們）以及 [預覽模式](/docs/pages/building-your-application/configuring/preview-mode)，已經完全支援 `next start` 和 [Vercel 邊緣平台](https://vercel.com) 開箱即用。

接下來，我們將制定一個補充 RFC 來解決兩個額外的增量靜態生成功能：

*   同時重新生成和失效多個頁面（如您的部落格索引和特定部落格文章）
*   透過監聽事件（如 CMS webhook）在用戶流量之前重新生成

[CMS 範例](#cms-examples)
-----------------------------

在我們宣布 [次世代靜態網站生成](/blog/next-9-3#next-gen-static-site-generation-ssg-support) 後，我們想分享從 Headless CMS API 獲取內容並將其渲染為 Next.js HTML 的真實場景。

我們與世界上一些最佳 CMS 系統的創建者合作：[Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape)，還有更多在路上。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/blog.png)

這些範例不僅可以立即使用且 100% 開源並採用 MIT 許可證，而且還整合了可用的最佳實踐：

![DatoCMS 因其內建的圖片優化支援而取得了無可挑剔的成果。](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/lighthouse.png)

DatoCMS 因其內建的圖片優化支援而取得了無可挑剔的成果。

我們還與 TinaCMS 合作開發了一個令人興奮的 CMS 新方向：**頁面內內容編輯**。[查看他們的指南](https://tinacms.org/guides/nextjs/github-open-authoring/initial-setup) 了解如何為您的專案實現它。

[新環境變數支援](#new-environment-variables-support)
-----------------------------------------------------------------------

我們從使用 Next.js 的公司那裡得到的一個常見反饋是，不清楚環境變數何時會被內聯到瀏覽器套件中，何時僅在 Node.js 環境中可用。

今天我們宣布兩項完全向後相容的功能，將幫助簡化此過程。

首先，您現在可以在環境變數前加上 `NEXT_PUBLIC_` 前綴，將其暴露給瀏覽器。當使用該環境變數時，它將被內聯到瀏覽器 JavaScript 套件中。

您不再需要添加 `next.config.js` 並添加 `env` 鍵來暴露這些變數。

```js filename="pages/index.js"
// 環境變數將暴露給瀏覽器
console.log('我的應用程式版本', process.env.NEXT_PUBLIC_VERSION);
 
export default function HomePage() {
  return <h1>Hello World</h1>;
}
```

第二個變化是 Next.js 現在預設支援 `.env` 載入。允許您輕鬆定義開發和生產環境變數。

您可以在 [環境變數文件](/docs/pages/building-your-application/configuring/environment-variables) 中閱讀更多關於 `.env` 載入的資訊。

這些新功能將透過以下慣例簡化環境變數的使用：

*   環境變數預設僅在 Node.js 環境中可用
*   前綴為 `NEXT_PUBLIC_` 的環境變數會暴露給瀏覽器

[改進的內建 Fetch 支援](#improved-built-in-fetch-support)
-------------------------------------------------------------------

在 [Next.js 9.1.7](https://nextjs.org/blog/next-9-1-7#new-built-in-polyfills-fetch-url-and-objectassign) 中，我們宣布了在瀏覽器中對 [`fetch()`](https://developer.mozilla.org/docs/Web/API/Fetch_API) API 的 polyfill。今天，這個 polyfill 也已擴展到 Node.js 環境。

實際上，您不再需要使用任何類型的伺服器端 fetch polyfill（例如 `isomorphic-unfetch` 或 `node-fetch`），因為 Next.js 將在所有環境中自動提供 `fetch()`。

例如，在使用 `getStaticProps` 時，它會在構建時由 Next.js 執行：

```js filename="pages/blog.js"
export async function getStaticProps() {
  // 不再需要從 isomorphic-unfetch 導入 fetch
  const res = await fetch('https://.../posts');
  const posts = await res.json();
 
  return {
    props: {
      posts,
    },
  };
}
 
function Blog({ posts }) {
  // 渲染文章...
}
 
export default Blog;
```

[整合式 Web Vitals 報告](#integrated-web-vitals-reporting)
-------------------------------------------------------------------

上週 Google Chrome 團隊推出了 [Core Web Vitals](https://web.dev/vitals/)。Core Web Vitals 是提供出色網路 UX 的關鍵質量信號，[著名的 Lighthouse 報告](https://twitter.com/rauchg/status/1259701306387656704) 就是基於此建立的。

如果您希望您的網站或網路應用程式盡可能快速，追蹤這些指標非常有用，這也是 Next.js 的核心目標之一。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/core-web-vitals.jpg)

Chrome 團隊發布了一個 [Core Web Vitals Chrome 擴充功能](https://twitter.com/addyosmani/status/1258416376433131520)，允許您作為開發人員獲得有關頁面性能的視覺反饋。

在構建生產網路應用程式時，您還想知道您的網站對訪客和（潛在）客戶的表現如何。您甚至可能希望追蹤這些指標隨時間的改進或回歸，以查看您的變更是否對觀眾產生了預期影響。

為了幫助將 Core Web Vitals 報告到您的分析服務，我們 [與 Google 合作](https://www.techrepublic.com/article/insiders-look-at-googles-web-framework-contributions-to-next-js-and-more/)，引入了一個名為 `reportWebVitals` 的新方法，可以從 `pages/_app.js` 導出：

```js filename="pages/_app.js"
// 每個需要報告的指標都會調用一次。
export function reportWebVitals(metric) {
  // 這些指標可以發送到任何分析服務
  console.log(metric);
}
 
function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
 
export default MyApp;
```

要將此方法與您的分析服務結合使用，請參考文件中的 [「發送結果到分析」](/docs/pages/building-your-application/optimizing/analytics#sending-results-to-analytics) 部分。如果您想了解更多關於 Core Web Vitals 的資訊，可以參考 [web.dev/vitals](https://web.dev/vitals/)。

[絕對路徑導入與別名](#absolute-imports-and-aliases)
-------------------------------------------------------------

如果您正在處理一個大型專案，一些 `import` 語句可能會受到 `../../../` 混亂的困擾：

```
import Button from '../../../../components/button';
```

在這種情況下，我們可能希望使用 **絕對路徑導入** 而不是相對導入。假設 `components` 目錄存在於根目錄，我們可能希望 `import` 語句看起來像：

```
import Button from 'components/button';
```

我們很高興地宣布，Next.js 9.4 使得為 JavaScript 和 TypeScript 專案設置絕對路徑導入變得非常簡單。您只需要將 `baseUrl` 配置添加到 [`jsconfig.json`（JS 專案）](https://code.visualstudio.com/docs/languages/jsconfig#_jsconfig-options) 或 [`tsconfig.json`（TS 專案）](https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url)。

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

這將允許從 `.`（根目錄）進行絕對路徑導入。它還與 VSCode 和其他編輯器集成，支援代碼導航和其他編輯器功能。

**注意：** 如果您之前修改了 [Webpack 模組別名配置](https://webpack.js.org/configuration/resolve/#resolvealias) 以啟用絕對路徑導入，現在可以移除該配置。

此外，Next.js 9.4 還支援 `paths` 選項，允許您創建自定義模組別名。例如，以下允許您使用 `@/design-system` 代替 `components/design-system`：

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/design-system/*": ["components/design-system/*"]
    }
  }
}
```

然後您可以像這樣使用您的別名：

```
// 導入 'components/design-system/button'
import Button from '@/design-system/button';
```

如果您指定 `paths`，則必須指定 `baseUrl`。您可以在 [TypeScript 文件](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) 中了解更多關於 `paths` 選項的資訊。

[可配置的 Sass 支援](#configurable-sass-support)
-------------------------------------------------------

當內建 Sass 支援在 [Next.js 9.3](https://nextjs.org/blog/next-9-3#built-in-sass-support-for-global-stylesheets) 中推出時，我們得到了一部分用戶的反饋，他們希望配置 sass 編譯器。例如配置 `includePaths`。

現在可以透過在 `next.config.js` 中使用 `sassOptions` 鍵來實現：

```js filename="next.config.js"
const path = require('path');
 
module.exports = {
  sassOptions: {
    includePaths: [path.join(__dirname, 'styles')],
  },
};
```

[改進的日誌輸出](#improved-log-output)
-------------------------------------------

我們重新設計了命令列輸出，使其更加一致並減少重複數據的輸出，例如部署 URL、等待開發伺服器啟動等。我們還更改了消息類型的間距，使其在消息之間保持一致，這意味著它們不再從一行跳到另一行。

在 9.4 之前的版本上運行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-previous.png)

在 9.4 上運行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-new.png)

[社群](#community)
-----------------------

我們很高興看到 Next.js 的採用持續增長：

*   我們已經有超過 **1066** 位獨立貢獻者。
*   在 GitHub 上，該專案已經獲得了超過 **48,000** 次星標。

加入 [GitHub Discussions](https://github.com/vercel/next.js/discussions) 上的 Next.js 社群。Discussions 是一個社群空間，允許您與其他 Next.js 用戶聯繫並提問。

如果您正在使用 Next.js，請隨時 [分享您的專案網址](https://github.com/vercel/next.js/discussions/10640) 與社群。

我們感謝我們的社群以及所有幫助塑造此版本的外部反饋和貢獻。
