---
source-updated-at: 2025-05-29T18:05:49.000Z
translation-updated-at: 2025-05-29T19:50:40.393Z
title: 数据变更
headline: '应用路由 (App Router)：数据变更'
description: '使用 React 服务端操作 (Server Actions) 变更数据，并重新验证 Next.js 缓存。'
image: 'https://nextjs.org/api/learn-og?title=Mutating%20Data&amp;chapter=12'
---

在上一章节中，您通过 URL 搜索参数和 Next.js API 实现了搜索与分页功能。现在让我们继续完善发票页面，添加创建、更新和删除发票的功能！

[什么是服务端操作 (Server Actions)？](#what-are-server-actions)
----------------------------------------------------

React 服务端操作允许您直接在服务端运行异步代码，无需创建专门的 API 端点来变更数据。您只需编写可在服务端执行的异步函数，即可从客户端或服务端组件调用这些函数。

安全性是 Web 应用的首要考量，因为应用可能面临多种威胁。服务端操作通过加密闭包、严格的输入检查、错误消息哈希、主机限制等特性，显著提升了应用安全性。

[在表单中使用服务端操作](#using-forms-with-server-actions)
-------------------------------------------------------------------

在 React 中，您可以使用 `<form>` 元素的 `action` 属性来调用操作。操作会自动接收包含捕获数据的原生 [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) 对象。

例如：

```
// 服务端组件
export default function Page() {
  // 操作
  async function create(formData: FormData) {
    'use server';
 
    // 数据变更逻辑...
  }
 
  // 通过 "action" 属性调用操作
  return <form action={create}>...</form>;
}
```

在服务端组件中调用服务端操作的优势在于渐进增强 —— 即使客户端 JavaScript 尚未加载，表单仍可正常工作（例如在网络连接较慢的情况下）。

[Next.js 与服务端操作](#nextjs-with-server-actions)
----------------------------------------------------------

服务端操作与 Next.js [缓存](https://nextjs.org/docs/app/building-your-application/caching)深度集成。通过服务端操作提交表单时，您不仅可以变更数据，还能使用 `revalidatePath` 和 `revalidateTag` 等 API 重新验证相关缓存。

让我们看看它们如何协同工作！

[创建发票](#creating-an-invoice)
-------------------------------------------

以下是创建新发票的步骤：

1.  创建表单以捕获用户输入
2.  创建服务端操作并从表单调用
3.  在操作中从 `formData` 对象提取数据
4.  验证并准备要插入数据库的数据
5.  插入数据并处理可能的错误
6.  重新验证缓存并重定向用户回发票页面

### [1\. 创建新路由和表单](#1-create-a-new-route-and-form)

首先，在 `/invoices` 文件夹中添加名为 `/create` 的路由段，并创建 `page.tsx` 文件：

<Image
  alt="包含嵌套 create 文件夹的 Invoices 目录，内含 page.tsx 文件"
  srcLight="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/light/create-invoice-route.png"
  srcDark="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/dark/create-invoice-route.png"
  width="1600"
  height="363"
/>

此路由用于创建新发票。将以下代码粘贴到 `page.tsx` 文件中并仔细研究：

```tsx filename="/dashboard/invoices/create/page.tsx"
import Form from '@/app/ui/invoices/create-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  const customers = await fetchCustomers();
 
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: '发票', href: '/dashboard/invoices' },
          {
            label: '创建发票',
            href: '/dashboard/invoices/create',
            active: true,
          },
        ]}
      />
      <Form customers={customers} />
    </main>
  );
}
```

该页面是服务端组件，会获取 `customers` 数据并传递给 `<Form>` 组件。为节省时间，我们已为您准备好 `<Form>` 组件。

查看 `<Form>` 组件，您会发现表单包含：
*   一个带有客户列表的 `<select>`（下拉）元素
*   一个 `type="number"` 的金额 `<input>` 元素
*   两个 `type="radio"` 的状态 `<input>` 元素
*   一个 `type="submit"` 的按钮

访问 [http://localhost:3000/dashboard/invoices/create](http://localhost:3000/dashboard/invoices/create) 将看到以下界面：

<Image
  alt="创建发票页面，包含面包屑导航和表单"
  srcLight="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/light/create-invoice-page.png"
  srcDark="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/dark/create-invoice-page.png"
  width="960"
  height="563"
/>

### [2\. 创建服务端操作](#2-create-a-server-action)

现在创建表单提交时将调用的服务端操作。

在 `lib/` 目录创建 `actions.ts` 文件，并在文件顶部添加 React 的 [`use server`](https://react.dev/reference/react/use-server) 指令：

```ts filename="/app/lib/actions.ts"
'use server';
```

添加 `'use server'` 后，文件内所有导出函数都将被标记为服务端操作。这些函数可被导入并在客户端或服务端组件中使用。文件中未使用的函数会被自动从最终应用包中移除。

您也可以直接在服务端组件中添加 `"use server"` 来编写服务端操作。但在本教程中，我们会将它们组织在单独文件中。我们建议为操作创建单独文件。

在 `actions.ts` 中创建接收 `formData` 的异步函数：

```ts {3} filename="/app/lib/actions.ts"
'use server';
 
export async function createInvoice(formData: FormData) {}
```

然后在 `<Form>` 组件中导入 `createInvoice` 操作，为 `<form>` 元素添加 `action` 属性并调用 `createInvoice`：

```tsx {10,18} filename="/app/ui/invoices/create-form.tsx"
import { CustomerField } from '@/app/lib/definitions';
import Link from 'next/link';
import {
  CheckIcon,
  ClockIcon,
  CurrencyDollarIcon,
  UserCircleIcon,
} from '@heroicons/react/24/outline';
import { Button } from '@/app/ui/button';
import { createInvoice } from '@/app/lib/actions';
 
export default function Form({
  customers,
}: {
  customers: CustomerField[];
}) {
  return (
    <form action={createInvoice}>
      // ...
  )
}
```

> **注意**：在 HTML 中，您需要向 `action` 属性传递 URL，该 URL 是表单数据的提交目标（通常是 API 端点）。
> 
> 但在 React 中，`action` 被视为特殊属性 —— React 在其基础上扩展，允许直接调用操作。
> 
> 在底层，服务端操作会创建 `POST` API 端点，这就是为什么使用服务端操作时无需手动创建 API 端点。

### [3\. 从 `formData` 提取数据](#3-extract-the-data-from-formdata)

在 `actions.ts` 文件中，您需要使用 [多种方法](https://developer.mozilla.org/en-US/docs/Web/API/FormData) 从 `formData` 提取值。本例中我们使用 [`.get(name)`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/get) 方法。

```ts {3,4,5,6,7,8,9,10} filename="/app/lib/actions.ts"
'use server';
 
export async function createInvoice(formData: FormData) {
  const rawFormData = {
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  };
  // 测试输出：
  console.log(rawFormData);
}
```

> **提示**：如果表单字段较多，可以考虑使用 [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) 方法配合 JavaScript 的 [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)。

提交表单后，您应该在终端（而非浏览器）中看到刚输入的表单数据。

现在数据已转换为对象格式，操作起来会更加方便。

### [4\. 验证并准备数据](#4-validate-and-prepare-the-data)

将表单数据发送到数据库前，需确保其格式和类型正确。回想课程前面的内容，发票表期望以下格式的数据：

```ts filename="/app/lib/definitions.ts"
export type Invoice = {
  id: string; // 将在数据库创建
  customer_id: string;
  amount: number; // 以分为单位存储
  status: 'pending' | 'paid';
  date: string;
};
```

目前您只有表单中的 `customer_id`、`amount` 和 `status`。

#### [类型验证与强制转换](#type-validation-and-coercion)

验证表单数据是否符合数据库预期类型非常重要。例如，如果在操作中添加：

```
console.log(typeof rawFormData.amount);
```

您会发现 `amount` 是 `string` 类型而非 `number`。这是因为 `type="number"` 的输入元素实际返回字符串而非数字！

虽然可以手动验证类型，但使用类型验证库能节省时间。本例中我们将使用 [Zod](https://zod.dev/)，这是一个 TypeScript 优先的验证库。

在 `actions.ts` 中导入 Zod 并定义与表单对象结构匹配的模式，该模式会在数据存入数据库前验证 `formData`：

```ts {3,5,6,7,8,9,10,11,13} filename="/app/lib/actions.ts"
'use server';
 
import { z } from 'zod';
 
const FormSchema = z.object({
  id: z.string(),
  customerId: z.string(),
  amount: z.coerce.number(),
  status: z.enum(['pending', 'paid']),
  date: z.string(),
});
 
const CreateInvoice = FormSchema.omit({ id: true, date: true });
 
export async function createInvoice(formData: FormData) {
  // ...
}
```

`amount` 字段专门设置为从字符串强制转换为数字并验证类型。

然后将 `rawFormData` 传递给 `CreateInvoice` 进行类型验证：

```ts {3} filename="/app/lib/actions.ts"
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
}
```

#### [以分为单位存储值](#storing-values-in-cents)

通常建议在数据库中以分为单位存储金额，以避免 JavaScript 浮点数错误并提高精度。

将金额转换为分：

```ts {8} filename="/app/lib/actions.ts"
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
  const amountInCents = amount * 100;
}
```

#### [创建新日期](#creating-new-dates)

最后，为发票创建日期创建格式为 "YYYY-MM-DD" 的新日期：

```ts {9} filename="/app/lib/actions.ts"
// ...
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
  const amountInCents = amount * 100;
  const date = new Date().toISOString().split('T')[0];
}
```

### [5\. 将数据插入数据库](#5-inserting-the-data-into-your-database)

现在您已拥有数据库所需的所有值，可以创建 SQL 查询将新发票插入数据库并传入变量：

```ts {2,15,16,17,18} filename="/app/lib/actions.ts"
import { z } from 'zod';
import postgres from 'postgres';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
 
// ...
 
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
  const amountInCents = amount * 100;
  const date = new Date().toISOString().split('T')[0];
 
  await sql`
    INSERT INTO invoices (customer_id, amount, status, date)
    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
  `;
}
```

目前我们尚未处理任何错误，这将在下一章节讨论。现在让我们继续下一步。

### [6. 重新验证与重定向](#6-revalidate-and-redirect)

Next.js 拥有一个客户端路由缓存，可在用户浏览器中临时存储路由片段。结合[预获取](/docs/app/building-your-application/routing/linking-and-navigating#1-prefetching)功能，该缓存能确保用户在路由间快速导航，同时减少向服务器发出的请求次数。

由于您需要更新发票路由中显示的数据，因此需要清除此缓存并触发向服务器的新请求。您可以使用 Next.js 的 [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) 函数实现：

```ts {4,25} filename="/app/lib/actions.ts"
'use server';
 
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import postgres from 'postgres';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
 
// ...
 
export async function createInvoice(formData: FormData) {
  const { customerId, amount, status } = CreateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
  const amountInCents = amount * 100;
  const date = new Date().toISOString().split('T')[0];
 
  await sql`
    INSERT INTO invoices (customer_id, amount, status, date)
    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
  `;
 
  revalidatePath('/dashboard/invoices');
}
```

数据库更新后，`/dashboard/invoices` 路径将被重新验证，并从服务器获取最新数据。

此时，您还需要将用户重定向回 `/dashboard/invoices` 页面。可以使用 Next.js 的 [`redirect`](/docs/app/api-reference/functions/redirect) 函数实现：

```ts {6,14} filename="/app/lib/actions.ts"
'use server';
 
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import postgres from 'postgres';
 
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
 
// ...
 
export async function createInvoice(formData: FormData) {
  // ...
 
  revalidatePath('/dashboard/invoices');
  redirect('/dashboard/invoices');
}
```

恭喜！您已成功实现第一个服务端操作 (Server Action)。通过添加新发票来测试功能，如果一切正常：

1. 提交后应重定向至 `/dashboard/invoices` 路由
2. 应在表格顶部看到新增发票

[更新发票](#updating-an-invoice)
-------------------------------------------

更新发票表单与创建发票表单类似，区别在于需要传递发票 `id` 以更新数据库记录。以下是更新发票的步骤：

1. 创建包含发票 `id` 的动态路由片段
2. 从页面参数中读取发票 `id`
3. 从数据库获取特定发票数据
4. 用发票数据预填充表单
5. 更新数据库中的发票数据

### [1. 创建包含发票 `id` 的动态路由片段](#1-create-a-dynamic-route-segment-with-the-invoice-id)

Next.js 允许创建[动态路由片段](/docs/app/building-your-application/routing/dynamic-routes)，适用于需要基于数据创建路由的场景（如博客标题、产品页面等）。通过在文件夹名称外添加方括号可创建动态路由，例如 `[id]`、`[post]` 或 `[slug]`。

在 `/invoices` 文件夹中创建名为 `[id]` 的动态路由，然后新建包含 `page.tsx` 文件的 `edit` 路由。文件结构应如下：

<Image
  alt="包含嵌套[id]文件夹和edit文件夹的发票目录结构"
  srcLight="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/light/edit-invoice-route.png"
  srcDark="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/dark/edit-invoice-route.png"
  width="1600"
  height="444"
/>

在 `<Table>` 组件中，注意 `<UpdateInvoice />` 按钮会接收来自表格记录的发票 `id`。

```tsx {11} filename="/app/ui/invoices/table.tsx"
export default async function InvoicesTable({
  query,
  currentPage,
}: {
  query: string;
  currentPage: number;
}) {
  return (
    // ...
    <td className="flex justify-end gap-2 whitespace-nowrap px-6 py-4 text-sm">
      <UpdateInvoice id={invoice.id} />
      <DeleteInvoice id={invoice.id} />
    </td>
    // ...
  );
}
```

导航至 `<UpdateInvoice />` 组件，更新 `Link` 的 `href` 以接收 `id` 属性。可使用模板字面量链接到动态路由片段：

```tsx {9} filename="/app/ui/invoices/buttons.tsx"
import { PencilIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';
 
// ...
 
export function UpdateInvoice({ id }: { id: string }) {
  return (
    <Link
      href={`/dashboard/invoices/${id}/edit`}
      className="rounded-md border p-2 hover:bg-gray-100"
    >
      <PencilIcon className="w-5" />
    </Link>
  );
}
```

### [2. 从页面参数读取发票 `id`](#2-read-the-invoice-id-from-page-params)

在 `<Page>` 组件中粘贴以下代码：

```tsx filename="/app/dashboard/invoices/[id]/edit/page.tsx"
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Edit Invoice',
            href: `/dashboard/invoices/${id}/edit`,
            active: true,
          },
        ]}
      />
      <Form invoice={invoice} customers={customers} />
    </main>
  );
}
```

注意此处与创建发票页面的相似性，区别在于导入了来自 `edit-form.tsx` 的不同表单。该表单应预填充客户名称、发票金额和状态的 `defaultValue`。要预填充表单字段，需使用 `id` 获取特定发票。

除了 `searchParams`，页面组件还接受 `params` 属性用于访问 `id`。更新 `<Page>` 组件以接收该属性：

```tsx {5,6} filename="/app/dashboard/invoices/[id]/edit/page.tsx"
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = params.id;
  // ...
}
```

### [3. 获取特定发票](#3-fetch-the-specific-invoice)

接着：
* 导入名为 `fetchInvoiceById` 的新函数并传递 `id` 参数
* 导入 `fetchCustomers` 以获取下拉菜单的客户名称

使用 `Promise.all` 并行获取发票和客户数据：

```tsx {3,8,9,10,11} filename="/dashboard/invoices/[id]/edit/page.tsx"
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';
 
export default async function Page(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = params.id;
  const [invoice, customers] = await Promise.all([
    fetchInvoiceById(id),
    fetchCustomers(),
  ]);
  // ...
}
```

终端中可能会看到关于 `invoice` 属性的临时 TypeScript 错误（因为 `invoice` 可能为 `undefined`）。暂时无需担心，后续添加错误处理时将解决此问题。

测试功能是否正常：访问 [http://localhost:3000/dashboard/invoices](http://localhost:3000/dashboard/invoices) 并点击铅笔图标编辑发票。导航后应看到预填充发票详情的表单：

<Image
  alt="包含面包屑导航和表单的编辑发票页面"
  srcLight="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/light/edit-invoice-page.png"
  srcDark="https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/learn/dark/edit-invoice-page.png"
  width="960"
  height="563"
/>

URL 也应更新为包含 `id` 的格式：`http://localhost:3000/dashboard/invoice/uuid/edit`

> **UUID 对比自增键**
> 
> 我们使用 UUID 而非自增键（如1、2、3等）。虽然会使 URL 变长，但 UUID 能消除 ID 冲突风险，具有全局唯一性，并减少枚举攻击风险——非常适合大型数据库。
> 
> 但如果您偏好简洁的 URL，可以选择使用自增键。

### [4. 将 `id` 传递给服务端操作](#4-pass-the-id-to-the-server-action)

最后，将 `id` 传递给服务端操作以更新数据库中的正确记录。不能直接传递 `id` 作为参数：

```tsx filename="/app/ui/invoices/edit-form.tsx"
// 直接传递id作为参数无效
<form action={updateInvoice(id)}>
```

但可以使用 JS 的 `bind` 方法传递 `id`，确保传递给服务端操作的值被正确编码。

```tsx {2,11,13} filename="/app/ui/invoices/edit-form.tsx"
// ...
import { updateInvoice } from '@/app/lib/actions';
 
export default function EditInvoiceForm({
  invoice,
  customers,
}: {
  invoice: InvoiceForm;
  customers: CustomerField[];
}) {
  const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);
 
  return <form action={updateInvoiceWithId}>{/* ... */}</form>;
}
```

> **注意：** 在表单中使用隐藏输入字段也可实现（如 `<input type="hidden" name="id" value={invoice.id} />`）。但值会以明文形式出现在HTML源码中，不适合敏感数据。

然后在 `actions.ts` 文件中创建新的 `updateInvoice` 操作：

```ts filename="/app/lib/actions.ts"
// 使用Zod更新预期类型
const UpdateInvoice = FormSchema.omit({ id: true, date: true });
 
// ...
 
export async function updateInvoice(id: string, formData: FormData) {
  const { customerId, amount, status } = UpdateInvoice.parse({
    customerId: formData.get('customerId'),
    amount: formData.get('amount'),
    status: formData.get('status'),
  });
 
  const amountInCents = amount * 100;
 
  await sql`
    UPDATE invoices
    SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}
    WHERE id = ${id}
  `;
 
  revalidatePath('/dashboard/invoices');
  redirect('/dashboard/invoices');
}
```

与 `createInvoice` 操作类似，此处：
1. 从 `formData` 提取数据
2. 使用 Zod 验证类型
3. 将金额转换为分
4. 将变量传递给 SQL 查询
5. 调用 `revalidatePath` 清除客户端缓存并发起新服务器请求
6. 调用 `redirect` 重定向用户至发票页面

通过编辑发票测试功能。提交表单后应重定向至发票页面，且发票数据应已更新。

[删除发票](#deleting-an-invoice)
-------------------------------------------

要使用服务端操作删除发票，将删除按钮包裹在 `<form>` 元素中，并通过 `bind` 将 `id` 传递给服务端操作：

```tsx {1,6,9} filename="/app/ui/invoices/buttons.tsx"
import { deleteInvoice } from '@/app/lib/actions';
 
// ...
 
export function DeleteInvoice({ id }: { id: string }) {
  const deleteInvoiceWithId = deleteInvoice.bind(null, id);
 
  return (
    <form action={deleteInvoiceWithId}>
      <button type="submit" className="rounded-md border p-2 hover:bg-gray-100">
        <span className="sr-only">Delete</span>
        <TrashIcon className="w-4" />
      </button>
    </form>
  );
}
```

在 `actions.ts` 文件中创建名为 `deleteInvoice` 的新操作：

```ts filename="/app/lib/actions.ts"
export async function deleteInvoice(id: string) {
  await sql`DELETE FROM invoices WHERE id = ${id}`;
  revalidatePath('/dashboard/invoices');
}
```

由于该操作在 `/dashboard/invoices` 路径下调用，无需调用 `redirect`。调用 `revalidatePath` 将触发新服务器请求并重新渲染表格。

[延伸阅读](#further-reading)
-----------------------------------

本章学习了如何使用服务端操作变更数据，以及如何使用 `revalidatePath` API 重新验证 Next.js 缓存，并通过 `redirect` 重定向用户至新页面。

您还可以阅读[服务端操作的安全性](https://nextjs.org/blog/security-nextjs-server-components-actions)了解更多内容。
