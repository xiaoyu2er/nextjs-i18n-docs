```mdx
---
source-updated-at: 2025-05-29T19:07:21.000Z
translation-updated-at: 2025-05-29T19:49:27.375Z
title: 静态资源（`public` 目录）
description: 了解如何在 `public` 目录中托管静态资源，如图片和字体文件。
---

Next.js 是一个用于构建全栈 Web 应用的 React 框架。您可以使用 React 组件构建用户界面，并借助 Next.js 获得额外的功能与优化。

它还自动配置了诸如打包工具和编译器之类的底层工具。这样您就可以专注于产品开发并快速交付。

无论您是独立开发者还是团队一员，Next.js 都能帮助您构建交互式、动态且快速的 React 应用。

## 静态文件服务

Next.js 可以通过 `public` 目录提供静态资源，如：
- 图片
- 字体文件
- 其他不需要构建处理的文件

### 使用方式

1. 在项目根目录创建 `public` 文件夹
2. 将静态文件放入该目录
3. 通过 `/` 开头的路径直接引用

示例：
```jsx
function MyComponent() {
  return <img src="/logo.png" alt="Logo" />;
}
```

### 注意事项

- 不要将 `public` 目录重命名
- 该目录中的文件不会被 Webpack 处理
- 文件名应包含哈希值以实现缓存

<AppOnly>
## 仅适用于 App Router 的特性

使用 App Router 时，您还可以：
- 将静态资源放在 `app` 目录中
- 使用新的 `next/image` 组件优化图片
</AppOnly>

<PagesOnly>
## 仅适用于 Pages Router 的特性

使用 Pages Router 时：
- 静态资源必须放在 `public` 目录
- 推荐使用 `next/image` 组件处理图片
</PagesOnly>

## 最佳实践

1. 对于小图标，考虑使用内联 SVG
2. 大文件建议使用 CDN
3. 定期清理未使用的资源

## 故障排除

如果资源无法加载：
1. 检查文件是否确实存在于 `public` 目录
2. 确认引用路径是否正确
3. 确保文件名没有拼写错误
```---
title: Next.js 9.4 版本发布
description: >-
  Next.js 9.4 引入了 React 快速刷新 (Fast Refresh)、增量静态再生 (Incremental Static Regeneration)、
  新环境变量支持、内置 Fetch 等多项功能！
author:
  - name: JJ Kasper
    image: /static/team/jj.jpg
  - name: Joe Haddad
    image: /static/team/timer.jpg
  - name: Luis Alvarez
    image: /static/team/lfades.jpg
  - name: Shu Uesugi
    image: /static/team/chibicode.jpg
  - name: Tim Neutkens
    image: /static/team/tim.jpg
date: 2020-05-11T15:00:00.479Z
image: >-
  https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/twitter-card.png
---

今天我们激动地宣布 Next.js 9.4 版本发布，主要特性包括：

*   **[快速刷新 (Fast Refresh)](#fast-refresh)**：提供快速可靠的实时编辑体验，已在 [Facebook 规模的项目中得到验证](https://twitter.com/dan_abramov/status/1152689338553131008)
*   **[增量静态再生 (beta)](#incremental-static-regeneration-beta)**：部署后以毫秒级速度重建静态页面
*   **[CMS 集成示例](#cms-examples)**：提供与 [Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape) 等 CMS 集成的示例，采用新一代[静态站点生成技术](/blog/next-9-3)
*   **[新环境变量支持](#new-environment-variables-support)**：内置支持 `.env` 文件和 `NEXT_PUBLIC_` 前缀，与 CRA 类似
*   **[改进的内置 Fetch 支持](#improved-built-in-fetch-support)**：无需再导入 `node-fetch` 或 `isomorphic-fetch`，Node.js 和所有浏览器（构建时和运行时）均内置 `fetch` polyfill
*   **[集成的 Web 核心指标报告](#integrated-web-vitals-reporting)**：从真实用户访问中捕获影响 [Lighthouse 评分的关键指标](https://web.dev/vitals/)
*   **[绝对路径导入与别名](#absolute-imports-and-aliases)**：更清晰简洁的导入方式，告别 `../../../` 路径混乱
*   **[可配置的 Sass 支持](#configurable-sass-support)**：可[配置 `includePaths`](https://sass-lang.com/documentation/js-api#includepaths) 等选项，扩展[内置 Sass 支持](/docs/pages/building-your-application/styling#sass-support)的功能
*   **[改进的日志输出](#improved-log-output)**：更易读、格式统一且减少重复信息的控制台输出

[快速刷新 (Fast Refresh)](#fast-refresh)
-----------------------------

快速刷新是一种新的热重载体验，可即时反馈对 React 组件所做的编辑。从 Next.js 9.4 开始，**所有项目默认启用**此功能。

热重载技术[已存在多年](https://github.com/gaearon/react-hot-loader)，但[历史上一直存在](https://github.com/gaearon/react-hot-loader/blob/master/docs/Troubleshooting.md)[稳定性问题](https://github.com/gaearon/react-hot-loader/issues?q=is%3Aissue)，难以作为默认工作流。因此，Next.js 之前实现了一种粗粒度的热重载方案，会在编辑时重置整个应用状态。

旧的热重载实现无法优雅处理编译或运行时错误，当编辑 CSS 或 JavaScript 出现拼写错误时会导致应用完全刷新。这种体验不够理想，会打断开发思路。

快速刷新深度集成到 React 内部（[通过 React Refresh](https://github.com/facebook/react/tree/master/packages/react-refresh)），使 Next.js 能够对 React 组件树执行精确的可预测更新。

这意味着 Next.js 只会更新您编辑的文件中的代码，并且仅重新渲染该组件，**同时保留组件状态**。这包括样式（内联样式、CSS-in-JS 或 CSS/Sass Modules）、标记、事件处理程序和效果（通过 `useEffect`）。

演示包含编译错误、运行时错误（快速恢复）以及保留状态的编辑过程。

作为此体验的一部分，我们完全重新设计了错误覆盖层，使其更具帮助性，并使应用能够抵御拼写错误或运行时错误。具体包括但不限于：

*   **精确的错误定位**，解析到编译前代码的**原始行号和列号**
*   上下文相关的**源代码片段**，支持**点击在编辑器中打开**
*   修复语法错误后**自动恢复开发会话**，**不丢失应用状态**
*   修复错误后**自动消除**未处理的运行时错误

我们要特别感谢 [Dan Abramov](https://twitter.com/dan_abramov) 在实现此功能过程中做出的宝贵贡献和协助。

[增量静态再生 (beta)](#incremental-static-regeneration-beta)
-------------------------------------------------------------------------------

Next.js 在 9.3 版本引入静态站点生成方法时就有明确目标：既要获得[静态化的优势](https://rauchg.com/2020/2019-in-review#static-is-the-new-dynamic)（始终快速、始终在线、[全球分发](https://rauchg.com/2020/static-hoisting#hoist-to-the-edge)），又要保持 Next.js 擅长的优秀动态数据支持。

为了兼顾两者，Next.js 支持**增量静态生成**，即在构建站点后更新静态内容。例如，9.3 版本引入的 `getStaticPaths` 中的 `fallback: true` 选项允许在运行时**添加新页面**。

我们最近[发布了一个示例](https://on-demand-isr.vercel.app/)，展示 Next.js 如何通过这种方式静态预渲染无限数量的页面。

今天，我们还推出了**增量静态再生 (beta)**，这是一种**更新现有页面**的机制，通过在有访问流量时在后台重新渲染页面。受 [stale-while-revalidate](https://tools.ietf.org/html/rfc5861) 启发，此机制确保流量不间断地始终获得静态服务，新构建的页面仅在生成完成后推送。

```js filename="pages/blog/[slug].js"
export async function getStaticProps() {
  return {
    props: await getDataFromCMS(),
    // 我们将尝试重新生成页面：
    // - 当有请求进入时
    // - 最多每秒一次
    unstable_revalidate: 1,
  };
}
```

与 SSR 不同，增量静态再生确保您保留静态化的优势：

*   无延迟峰值。页面始终保持快速响应。
*   页面永不离线。如果后台页面重新生成失败，旧页面保持不变。
*   数据库和后端负载低。页面最多同时重新计算一次。

增量功能（添加页面和延迟更新）以及[预览模式](/docs/pages/building-your-application/configuring/preview-mode)都已完全支持 `next start` 和 [Vercel 边缘平台](https://vercel.com)。

接下来，我们将制定补充 RFC 以解决两项额外的增量静态生成能力：

*   同时重新生成和失效多个页面（如博客索引和特定博客文章）
*   通过监听事件（如 CMS webhooks）在用户访问前重新生成

[CMS 集成示例](#cms-examples)
-----------------------------

在宣布[新一代静态站点生成](/blog/next-9-3#next-gen-static-site-generation-ssg-support)后，我们希望分享从 Headless CMS API 获取内容并将其渲染为 Next.js HTML 的实际场景。

我们与世界顶级 CMS 系统的创建者合作：[Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape)，更多集成即将推出。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/blog.png)

这些示例不仅开箱即用、100% 开源且采用 MIT 许可，还融入了最佳实践：

![DatoCMS 因其内置的图像优化支持而获得完美结果。](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/lighthouse.png)

我们还与 TinaCMS 合作探索了 CMS 的新方向：**页面内内容编辑**。[查看他们的指南](https://tinacms.org/guides/nextjs/github-open-authoring/initial-setup)了解如何在您的项目中实现。

[新环境变量支持](#new-environment-variables-support)
-----------------------------------------------------------------------

从使用 Next.js 的公司获得的常见反馈是，不清楚环境变量何时会内联到浏览器 bundle 中，何时仅在 Node.js 环境中可用。

今天我们宣布两项完全向后兼容的功能来简化此流程。

首先，您现在可以在环境变量前添加 `NEXT_PUBLIC_` 前缀以将其暴露给浏览器。使用该环境变量时，它将被内联到浏览器 JavaScript bundle 中。

您不再需要添加 `next.config.js` 并通过 `env` 键来暴露这些变量。

```js filename="pages/index.js"
// 环境变量将暴露给浏览器
console.log('应用版本', process.env.NEXT_PUBLIC_VERSION);
 
export default function HomePage() {
  return <h1>Hello World</h1>;
}
```

第二个变化是 Next.js 现在默认支持加载 `.env` 文件，方便您定义开发和生产环境变量。

您可以在[环境变量文档](/docs/pages/building-your-application/configuring/environment-variables)中了解更多关于 `.env` 加载的信息。

这些新功能通过以下约定简化了环境变量的使用：

*   默认情况下，环境变量仅在 Node.js 环境中可用
*   以 `NEXT_PUBLIC_` 为前缀的环境变量会暴露给浏览器

[改进的内置 Fetch 支持](#improved-built-in-fetch-support)
-------------------------------------------------------------------

在 [Next.js 9.1.7](https://nextjs.org/blog/next-9-1-7#new-built-in-polyfills-fetch-url-and-objectassign) 中，我们宣布在浏览器中 polyfill [`fetch()`](https://developer.mozilla.org/docs/Web/API/Fetch_API) API。今天，此 polyfill 已扩展到 Node.js 环境。

实际上，您不再需要使用任何服务端 fetch polyfill（如 `isomorphic-unfetch` 或 `node-fetch`），因为 Next.js 将在所有环境中自动提供 `fetch()`。

例如，在使用 `getStaticProps` 时（在构建时由 Next.js 执行）：

```js filename="pages/blog.js"
export async function getStaticProps() {
  // 不再需要从 isomorphic-unfetch 导入 fetch
  const res = await fetch('https://.../posts');
  const posts = await res.json();
 
  return {
    props: {
      posts,
    },
  };
}
 
function Blog({ posts }) {
  // 渲染文章...
}
 
export default Blog;
```

[集成的 Web 核心指标报告](#integrated-web-vitals-reporting)
-------------------------------------------------------------------

上周 Google Chrome 团队推出了[核心 Web 指标 (Core Web Vitals)](https://web.dev/vitals/)。核心 Web 指标是提供出色 Web 用户体验的关键质量信号，著名的 [Lighthouse 报告](https://twitter.com/rauchg/status/1259701306387656704)即基于此构建。

如果您希望网站或 Web 应用尽可能快，跟踪这些指标非常有用，这也是 Next.js 的核心目标之一。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/core-web-vitals.jpg)

Chrome 团队发布了[核心 Web 指标 Chrome 扩展](https://twitter.com/addyosmani/status/1258416376433131520)，让开发者能够直观了解页面性能。

构建生产级 Web 应用时，您还需要了解访问者和（潜在）客户的实际体验。您可能希望跟踪这些指标随时间的改进或退化，以查看更改是否对受众产生了预期影响。

为了帮助将核心 Web 指标报告给分析服务，我们[与 Google 合作](https://www.techrepublic.com/article/insiders-look-at-googles-web-framework-contributions-to-next-js-and-more/)引入了名为 `reportWebVitals` 的新方法，可从 `pages/_app.js` 导出：

```js filename="pages/_app.js"
// 每个需要报告的指标都会调用一次此方法
export function reportWebVitals(metric) {
  // 这些指标可以发送到任何分析服务
  console.log(metric);
}
 
function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
 
export default MyApp;
```

要结合分析服务使用此方法，请参考文档中的["发送结果到分析服务"](/docs/pages/building-your-application/optimizing/analytics#sending-results-to-analytics)部分。要了解更多关于核心 Web 指标的信息，请访问 [web.dev/vitals](https://web.dev/vitals/)。

[绝对路径导入与别名](#absolute-imports-and-aliases)
-------------------------------------------------------------

如果您正在开发大型项目，某些 `import` 语句可能会陷入 `../../../` 的混乱：

```
import Button from '../../../../components/button';
```

在这种情况下，我们可能希望使用**绝对路径导入**而非相对导入。假设 `components` 目录存在于根目录，我们希望 `import` 语句看起来像：

```
import Button from 'components/button';
```

我们很高兴地宣布，Next.js 9.4 使得为 JavaScript 和 TypeScript 项目设置绝对路径导入变得非常简单。您只需将 `baseUrl` 配置添加到 [`jsconfig.json`（JS 项目）](https://code.visualstudio.com/docs/languages/jsconfig#_jsconfig-options) 或 [`tsconfig.json`（TS 项目）](https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url) 中。

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

这将允许从 `.`（根目录）进行绝对路径导入。同时与 VSCode 和其他编辑器集成，支持代码导航和其他编辑器功能。

**注意：** 如果您之前修改过 [Webpack 模块别名配置](https://webpack.js.org/configuration/resolve/#resolvealias) 以启用绝对路径导入，现在可以移除该配置。

此外，Next.js 9.4 还支持 `paths` 选项，允许创建自定义模块别名。例如，以下配置允许使用 `@/design-system` 替代 `components/design-system`：

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/design-system/*": ["components/design-system/*"]
    }
  }
}
```

然后可以像这样使用别名：

```
// 导入 'components/design-system/button'
import Button from '@/design-system/button';
```

如果指定 `paths`，则必须指定 `baseUrl`。您可以在 [TypeScript 文档](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) 中了解更多关于 `paths` 选项的信息。

[可配置的 Sass 支持](#configurable-sass-support)
-------------------------------------------------------

在 [Next.js 9.3](https://nextjs.org/blog/next-9-3#built-in-sass-support-for-global-stylesheets) 中推出内置 Sass 支持后，我们收到部分用户希望配置 sass 编译器的反馈，例如配置 `includePaths`。

现在可以通过在 `next.config.js` 中使用 `sassOptions` 键实现：

```js filename="next.config.js"
const path = require('path');
 
module.exports = {
  sassOptions: {
    includePaths: [path.join(__dirname, 'styles')],
  },
};
```

[改进的日志输出](#improved-log-output)
-------------------------------------------

我们重新设计了命令行输出，使其更加一致，并减少重复数据的输出，如部署 URL、等待开发服务器启动等。我们还统一了消息类型的间距，使它们不再在行间跳跃。

在 9.4 之前版本运行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-previous.png)

在 9.4 版本运行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-new.png)

[社区](#community)
-----------------------

我们很高兴看到 Next.js 的采用持续增长：

*   已有超过 **1066** 位独立贡献者。
*   在 GitHub 上，项目已获得超过 **48,000** 次 star。

加入 Next.js 社区 [GitHub Discussions](https://github.com/vercel/next.js/discussions)。Discussions 是一个社区空间，您可以与其他 Next.js 用户联系并提问。

如果您正在使用 Next.js，欢迎[分享您的项目 URL](https://github.com/vercel/next.js/discussions/10640) 给社区。

我们感谢社区以及所有帮助塑造此版本的外部反馈和贡献。
