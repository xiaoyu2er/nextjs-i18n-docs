---
source-updated-at: 2025-05-29T19:07:21.000Z
translation-updated-at: 2025-05-29T19:22:49.912Z
title: 关于 Next.js
description: Next.js 是一个用于构建全栈 Web 应用程序的 React 框架。您可以使用 React 组件构建用户界面，并利用 Next.js 提供的额外功能和优化。
---

Next.js 是一个基于 React 的全栈 Web 应用开发框架。您可以使用 React 组件构建用户界面，并通过 Next.js 获得更多功能和优化。

该框架还会自动配置底层工具，如打包工具 (bundlers) 和编译器 (compilers)。这样您就可以专注于产品开发并快速交付。

无论您是独立开发者还是团队一员，Next.js 都能帮助您构建交互式、动态且高效的 React 应用程序。

<AppOnly>
### 仅限 App 路由模式
这部分内容仅适用于使用 App 路由模式的应用。
</AppOnly>

<PagesOnly>
### 仅限 Pages 路由模式
这部分内容仅适用于使用 Pages 路由模式的应用。
</PagesOnly>---
title: Next.js 9.4 版本发布
description: >-
  Next.js 9.4 引入了 React Fast Refresh、增量静态再生 (ISR)、新环境变量支持、内置 Fetch 等多项功能！
author:
  - name: JJ Kasper
    image: /static/team/jj.jpg
  - name: Joe Haddad
    image: /static/team/timer.jpg
  - name: Luis Alvarez
    image: /static/team/lfades.jpg
  - name: Shu Uesugi
    image: /static/team/chibicode.jpg
  - name: Tim Neutkens
    image: /static/team/tim.jpg
date: 2020-05-11T15:00:00.479Z
image: >-
  https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/twitter-card.png
---

今天我们激动地发布 Next.js 9.4，主要特性包括：

*   **[快速刷新 (Fast Refresh)](#fast-refresh)**：提供快速可靠的实时编辑体验，已在 [Facebook 规模的项目](https://twitter.com/dan_abramov/status/1152689338553131008) 中得到验证
*   **[增量静态再生 (ISR)（测试版）](#incremental-static-regeneration-beta)**：部署后以毫秒级速度重建静态页面
*   **[CMS 集成示例](#cms-examples)**：提供 [Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape) 的示例，采用新一代 [静态站点生成技术](/blog/next-9-3)
*   **[新环境变量支持](#new-environment-variables-support)**：内置支持 `.env` 文件和 `NEXT_PUBLIC_` 前缀（与 CRA 类似）
*   **[增强的内置 Fetch 支持](#improved-built-in-fetch-support)**：无需再导入 `node-fetch` 或 `isomorphic-fetch`，Node.js 和所有浏览器（构建时和运行时）均已内置 `fetch` polyfill
*   **[集成 Web 核心指标报告](#integrated-web-vitals-reporting)**：从真实用户流量中捕获影响 [Lighthouse 评分](https://web.dev/vitals/) 的关键指标
*   **[绝对导入与路径别名](#absolute-imports-and-aliases)**：更清晰简洁的导入方式，告别 `../../../` 路径混乱
*   **[可配置的 Sass 支持](#configurable-sass-support)**：支持 [配置 `includePaths`](https://sass-lang.com/documentation/js-api#includepaths) 等 [内置 Sass 功能](/docs/pages/building-your-application/styling#sass-support) 的参数
*   **[优化的日志输出](#improved-log-output)**：更易读、格式统一且去重化的控制台输出

[快速刷新 (Fast Refresh)](#fast-refresh)
-----------------------------

快速刷新是一种新的热重载体验，可即时反馈对 React 组件所做的编辑。从 Next.js 9.4 开始，该功能已**默认启用**。

热重载技术 [由来已久](https://github.com/gaearon/react-hot-loader)，但 [历史上存在](https://github.com/gaearon/react-hot-loader/blob/master/docs/Troubleshooting.md) [诸多问题](https://github.com/gaearon/react-hot-loader/issues?q=is%3Aissue)，难以作为默认工作流。因此 Next.js 此前采用了一种粗略的热重载实现，会在编辑时重置整个应用状态。

旧版热重载对编译或运行时错误不够健壮，当编辑 CSS 或 JavaScript 出现拼写错误时会导致应用完全刷新。这种体验不够理想，会打断开发思路。

快速刷新深度集成到 React 内部（[通过 React Refresh](https://github.com/facebook/react/tree/master/packages/react-refresh)），使 Next.js 能够对 React 组件树执行精确的预测性更新。

这意味着 Next.js 只会更新您编辑的文件代码，并且仅重新渲染该组件，**同时保持组件状态不变**。这包括样式（行内样式、CSS-in-JS 或 CSS/Sass Modules）、标记、事件处理程序和效果（通过 `useEffect`）。

演示包含编译与运行时错误（快速恢复）以及保持状态的编辑会话。

作为该体验的一部分，我们完全重新设计了错误覆盖层，使其更具帮助性，并使应用对拼写错误或运行时错误更具弹性。具体包括但不限于：

*   **精确的错误定位**，解析为编译前代码的**原始行列位置**
*   上下文相关的**源代码片段**，支持**点击在编辑器中打开**
*   修复语法错误后**自动恢复开发会话**，**不丢失应用状态**
*   修复错误后**自动消除**未处理的运行时错误

我们要特别感谢 [Dan Abramov](https://twitter.com/dan_abramov) 在实现此功能过程中做出的宝贵贡献。

[增量静态再生 (ISR)（测试版）](#incremental-static-regeneration-beta)
-------------------------------------------------------------------------------

Next.js 在 9.3 版本引入静态站点生成方法时就设定了一个明确目标：既要获得 [静态化的优势](https://rauchg.com/2020/2019-in-review#static-is-the-new-dynamic)（始终快速、始终在线、[全球分布式](https://rauchg.com/2020/static-hoisting#hoist-to-the-edge)），又要保持 Next.js 擅长的动态数据优秀支持。

为了兼顾两者，Next.js 支持**增量静态生成**，即在构建站点后仍能更新静态内容。例如在 9.3 版本中，我们引入了 `getStaticPaths` 的 `fallback: true` 选项，允许在运行时添加**新页面**。

我们最近 [发布了一个示例](https://on-demand-isr.vercel.app/)，展示 Next.js 如何通过这种方式静态预渲染无限数量的页面。

今天，我们还推出了**增量静态再生（测试版）**，这是一种**更新现有页面**的机制，通过在有流量访问时在后台重新渲染页面。受 [stale-while-revalidate](https://tools.ietf.org/html/rfc5861) 启发，该机制确保流量不间断地获得静态服务，并且仅在生成完成后推送新构建的页面。

```js filename="pages/blog/[slug].js"
export async function getStaticProps() {
  return {
    props: await getDataFromCMS(),
    // 我们将尝试重新生成页面：
    // - 当有请求进入时
    // - 最多每秒一次
    unstable_revalidate: 1,
  };
}
```

与 SSR 不同，增量静态再生确保您保留静态化的优势：

*   无延迟峰值。页面始终保持快速响应。
*   页面永不离线。如果后台页面重新生成失败，旧页面保持不变。
*   数据库和后端负载低。页面最多同时重新计算一次。

增量功能（添加页面和延迟更新）以及 [预览模式](/docs/pages/building-your-application/configuring/preview-mode) 都已完全支持 `next start` 和 [Vercel 边缘平台](https://vercel.com) 开箱即用。

接下来，我们将制定补充性 RFC 以解决两项额外的增量静态生成能力：

*   同时重新生成和失效多个页面（如博客索引和特定博文）
*   通过监听事件（如 CMS webhooks）在用户访问前重新生成

[CMS 集成示例](#cms-examples)
-----------------------------

在我们宣布 [新一代静态站点生成](/blog/next-9-3#next-gen-static-site-generation-ssg-support) 后，我们希望分享从 Headless CMS API 获取内容并将其渲染为 Next.js HTML 的实际场景。

我们与世界顶级 CMS 系统的创建者合作：[Contentful](https://github.com/vercel/next.js/tree/canary/examples/cms-contentful)、[DatoCMS](https://github.com/vercel/next.js/tree/canary/examples/cms-datocms)、[Prismic](https://github.com/vercel/next.js/tree/canary/examples/cms-prismic)、[Sanity](https://github.com/vercel/next.js/tree/canary/examples/cms-sanity) 和 [TakeShape](https://github.com/vercel/next.js/tree/canary/examples/cms-takeshape)，更多集成即将推出。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/blog.png)

这些示例不仅开箱即用、100% 开源且采用 MIT 许可，还融入了当前最佳实践：

![DatoCMS 因其内置的图像优化支持而获得完美结果。](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/lighthouse.png)

我们还与 TinaCMS 合作探索了 CMS 的新方向：**页面内内容编辑**。[查看他们的指南](https://tinacms.org/guides/nextjs/github-open-authoring/initial-setup) 了解如何在您的项目中实现。

[新环境变量支持](#new-environment-variables-support)
-----------------------------------------------------------------------

我们从使用 Next.js 的公司获得的常见反馈是：很难判断环境变量何时会被内联到浏览器 bundle 中，何时仅在 Node.js 环境中可用。

今天我们宣布两项完全向后兼容的功能来简化这一流程。

首先，您现在可以通过给环境变量添加 `NEXT_PUBLIC_` 前缀来将其暴露给浏览器。使用该环境变量时，它将被内联到浏览器 JavaScript bundle 中。

您不再需要添加 `next.config.js` 并通过 `env` 键来暴露这些变量。

```js filename="pages/index.js"
// 该环境变量将暴露给浏览器
console.log('应用版本', process.env.NEXT_PUBLIC_VERSION);
 
export default function HomePage() {
  return <h1>Hello World</h1>;
}
```

第二个变化是 Next.js 现在默认支持加载 `.env` 文件，方便您定义开发和生产环境变量。

您可以在 [环境变量文档](/docs/pages/building-your-application/configuring/environment-variables) 中了解更多关于 `.env` 加载的信息。

这些新功能通过以下约定简化了环境变量的使用：

*   默认情况下环境变量仅在 Node.js 环境中可用
*   带有 `NEXT_PUBLIC_` 前缀的环境变量会暴露给浏览器

[增强的内置 Fetch 支持](#improved-built-in-fetch-support)
-------------------------------------------------------------------

在 [Next.js 9.1.7](https://nextjs.org/blog/next-9-1-7#new-built-in-polyfills-fetch-url-and-objectassign) 中，我们宣布在浏览器中 polyfill [`fetch()`](https://developer.mozilla.org/docs/Web/API/Fetch_API) API。现在这一 polyfill 已扩展到 Node.js 环境。

实际上，您不再需要使用任何服务端 fetch polyfill（如 `isomorphic-unfetch` 或 `node-fetch`），因为 Next.js 将在所有环境中自动提供 `fetch()`。

例如，在使用 `getStaticProps` 时（该函数在构建时由 Next.js 执行）：

```js filename="pages/blog.js"
export async function getStaticProps() {
  // 不再需要从 isomorphic-unfetch 导入 fetch
  const res = await fetch('https://.../posts');
  const posts = await res.json();
 
  return {
    props: {
      posts,
    },
  };
}
 
function Blog({ posts }) {
  // 渲染文章...
}
 
export default Blog;
```

[集成 Web 核心指标报告](#integrated-web-vitals-reporting)
-------------------------------------------------------------------

上周 Google Chrome 团队发布了 [核心 Web 指标 (Core Web Vitals)](https://web.dev/vitals/)。核心 Web 指标是提供出色网页用户体验的关键质量信号，著名的 [Lighthouse 报告](https://twitter.com/rauchg/status/1259701306387656704) 正是基于这些指标。

如果您希望网站或 Web 应用尽可能快（这是 Next.js 的核心目标之一），跟踪这些指标将非常有用。

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/core-web-vitals.jpg)

Chrome 团队发布了 [核心 Web 指标 Chrome 扩展](https://twitter.com/addyosmani/status/1258416376433131520)，让开发者能够直观了解页面性能表现。

在构建生产级 Web 应用时，您还需要了解网站对访客和（潜在）客户的性能表现。您甚至可能希望跟踪这些指标随时间的改进或退化，以查看更改是否对受众产生了预期影响。

为了帮助向分析服务报告核心 Web 指标，我们 [与 Google 合作](https://www.techrepublic.com/article/insiders-look-at-googles-web-framework-contributions-to-next-js-and-more/) 引入了一个新方法 `reportWebVitals`，可以从 `pages/_app.js` 导出：

```js filename="pages/_app.js"
// 每个需要报告的指标都会调用一次该方法
export function reportWebVitals(metric) {
  // 这些指标可以发送到任何分析服务
  console.log(metric);
}
 
function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}
 
export default MyApp;
```

要结合您的分析服务使用此方法，请参考文档中的 ["发送结果到分析服务"](/docs/pages/building-your-application/optimizing/analytics#sending-results-to-analytics) 部分。要了解更多关于核心 Web 指标的信息，请访问 [web.dev/vitals](https://web.dev/vitals/)。

[绝对导入与路径别名](#absolute-imports-and-aliases)
-------------------------------------------------------------

如果您正在开发大型项目，某些 `import` 语句可能会陷入 `../../../` 的混乱：

```
import Button from '../../../../components/button';
```

在这种情况下，我们可能希望使用**绝对导入**而非相对导入。假设 `components` 目录存在于根目录下，我们希望 `import` 语句看起来像：

```
import Button from 'components/button';
```

我们很高兴地宣布，Next.js 9.4 使得为 JavaScript 和 TypeScript 项目设置绝对导入变得非常简单。您只需将 `baseUrl` 配置添加到 [`jsconfig.json`（JS 项目）](https://code.visualstudio.com/docs/languages/jsconfig#_jsconfig-options) 或 [`tsconfig.json`（TS 项目）](https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url) 中。

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

这将允许从 `.`（根目录）进行绝对导入。该功能还与 VSCode 和其他编辑器集成，支持代码导航和其他编辑器功能。

**注意：** 如果您之前修改过 [Webpack 模块别名配置](https://webpack.js.org/configuration/resolve/#resolvealias) 以实现绝对导入，现在可以移除该配置。

此外，Next.js 9.4 还支持 `paths` 选项，允许创建自定义模块别名。例如，以下配置允许您使用 `@/design-system` 代替 `components/design-system`：

```json filename="jsconfig.json / tsconfig.json"
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/design-system/*": ["components/design-system/*"]
    }
  }
}
```

然后您可以这样使用别名：

```
// 导入 'components/design-system/button'
import Button from '@/design-system/button';
```

如果指定了 `paths` 则必须指定 `baseUrl`。您可以在 [TypeScript 文档](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) 中了解更多关于 `paths` 选项的信息。

[可配置的 Sass 支持](#configurable-sass-support)
-------------------------------------------------------

当 [Next.js 9.3](https://nextjs.org/blog/next-9-3#built-in-sass-support-for-global-stylesheets) 推出内置 Sass 支持时，我们收到部分用户反馈希望配置 sass 编译器，例如配置 `includePaths`。

现在可以通过在 `next.config.js` 中使用 `sassOptions` 键实现：

```js filename="next.config.js"
const path = require('path');
 
module.exports = {
  sassOptions: {
    includePaths: [path.join(__dirname, 'styles')],
  },
};
```

[优化的日志输出](#improved-log-output)
-------------------------------------------

我们重新设计了命令行输出，使其更加一致，并减少了重复数据的输出，如部署 URL、等待开发服务器启动等。我们还统一了消息类型的间距，使它们不再在不同行之间跳动。

在 9.4 之前版本运行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-previous.png)

在 9.4 版本运行 `next dev`

![](https://h8DxKfmAPhn8O0p3.public.blob.vercel-storage.com/static/blog/next-9-4/log-output-new.png)

[社区](#community)
-----------------------

我们很高兴看到 Next.js 的采用率持续增长：

*   已有超过 **1066** 位独立贡献者。
*   在 GitHub 上，该项目已获得超过 **48,000** 次 star。

加入 [GitHub Discussions](https://github.com/vercel/next.js/discussions) 上的 Next.js 社区。Discussions 是一个社区空间，您可以与其他 Next.js 用户交流并提问。

如果您正在使用 Next.js，欢迎 [分享您的项目链接](https://github.com/vercel/next.js/discussions/10640) 与社区交流。

我们感谢社区以及所有帮助塑造此版本的外部反馈和贡献。
