---
source-updated-at: 2025-05-19T22:31:51.000Z
translation-updated-at: 2025-05-20T22:57:34.085Z
title: 如何从 Vite 迁移到 Next.js
nav_title: Vite
description: 了解如何将现有的 React 应用从 Vite 迁移至 Next.js。
---

本指南将帮助您将现有的 Vite 应用迁移到 Next.js。

## 为何要迁移？

从 Vite 切换到 Next.js 有以下几个原因：

### 初始页面加载缓慢

如果使用 [Vite 默认的 React 插件](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react) 构建应用，您的应用是纯客户端应用。纯客户端应用（也称为单页应用 SPA）通常会遇到初始加载缓慢的问题，原因如下：

1. 浏览器需要等待 React 代码和整个应用包下载并运行后，才能发送请求加载数据。
2. 随着新增功能和依赖项的增加，应用代码会不断膨胀。

### 缺乏自动代码分割

虽然通过代码分割可以缓解加载缓慢的问题，但手动进行代码分割往往会导致性能更差。手动分割容易意外引入网络瀑布流问题。Next.js 的路由器内置了自动代码分割功能。

### 网络瀑布流

当应用需要连续发起客户端-服务器请求来获取数据时，常会导致性能不佳。SPA 中常见的数据获取模式是先渲染占位内容，然后在组件挂载后获取数据。这意味着子组件必须等待父组件完成数据加载后才能开始自己的数据获取。

虽然 Next.js 支持客户端数据获取，但它也提供了将数据获取转移到服务端的选项，从而消除客户端-服务端瀑布流问题。

### 快速且可控的加载状态

通过内置的 [React Suspense 流式传输](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense) 支持，您可以更精确地控制 UI 的加载顺序和优先级，同时避免网络瀑布流。

这能让您构建加载更快的页面，并消除 [布局偏移](https://vercel.com/blog/how-core-web-vitals-affect-seo)。

### 灵活选择数据获取策略

Next.js 允许您根据需求为每个页面和组件选择数据获取策略：构建时获取、服务端请求时获取或客户端获取。例如，您可以从 CMS 获取数据并在构建时渲染博客文章，然后通过 CDN 高效缓存。

### 中间件

[Next.js 中间件](/docs/app/building-your-application/routing/middleware) 可以在请求完成前在服务端运行代码。这对于避免用户在访问需认证页面时闪现未认证内容非常有用（可通过重定向到登录页实现）。中间件还可用于实验功能和 [国际化](/docs/app/building-your-application/routing/internationalization)。

### 内置优化

[图片](/docs/app/api-reference/components/image)、[字体](/docs/app/api-reference/components/font) 和 [第三方脚本](/docs/app/guides/scripts) 通常对应用性能有重大影响。Next.js 提供了自动优化这些资源的内置组件。

## 迁移步骤

本次迁移的目标是快速获得一个可运行的 Next.js 应用，以便后续逐步采用 Next.js 特性。初始阶段我们将保持其为纯客户端应用（SPA），不迁移现有路由，以降低迁移过程中的问题风险和合并冲突。

### 步骤 1：安装 Next.js 依赖

首先需要安装最新版 `next` 依赖：

```bash filename="Terminal"
npm install next@latest
```

### 步骤 2：创建 Next.js 配置文件

在项目根目录创建 `next.config.mjs` 文件，用于配置 [Next.js 选项](/docs/app/api-reference/config/next-config-js)：

```js filename="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // 输出单页应用 (SPA)
  distDir: './dist', // 将构建输出目录改为 `./dist/`
}

export default nextConfig
```

> **须知**：Next.js 配置文件可使用 `.js` 或 `.mjs` 扩展名。

### 步骤 3：更新 TypeScript 配置

如果使用 TypeScript，需要更新 `tsconfig.json` 文件以兼容 Next.js（非 TypeScript 项目可跳过）：

1. 移除对 `tsconfig.node.json` 的 [项目引用](https://www.typescriptlang.org/tsconfig#references)
2. 在 [`include` 数组](https://www.typescriptlang.org/tsconfig#include) 添加 `./dist/types/**/*.ts` 和 `./next-env.d.ts`
3. 在 [`exclude` 数组](https://www.typescriptlang.org/tsconfig#exclude) 添加 `./node_modules`
4. 在 [`compilerOptions.plugins`](https://www.typescriptlang.org/tsconfig#plugins) 添加 `{ "name": "next" }`：`"plugins": [{ "name": "next" }]`
5. 设置 [`esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) 为 `true`：`"esModuleInterop": true`
6. 设置 [`jsx`](https://www.typescriptlang.org/tsconfig#jsx) 为 `preserve`：`"jsx": "preserve"`
7. 设置 [`allowJs`](https://www.typescriptlang.org/tsconfig#allowJs) 为 `true`：`"allowJs": true`
8. 设置 [`forceConsistentCasingInFileNames`](https://www.typescriptlang.org/tsconfig#forceConsistentCasingInFileNames) 为 `true`：`"forceConsistentCasingInFileNames": true`
9. 设置 [`incremental`](https://www.typescriptlang.org/tsconfig#incremental) 为 `true`：`"incremental": true`

配置示例：

```json filename="tsconfig.json"
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "plugins": [{ "name": "next" }]
  },
  "include": ["./src", "./dist/types/**/*.ts", "./next-env.d.ts"],
  "exclude": ["./node_modules"]
}
```

更多 TypeScript 配置信息请参阅 [Next.js 文档](/docs/app/api-reference/config/typescript#ide-plugin)。

### 步骤 4：创建根布局

Next.js [应用路由](/docs/app) 必须包含一个 [根布局文件](/docs/app/building-your-application/routing/layouts-and-templates#root-layout-required)，这是一个 [React 服务端组件](/docs/app/getting-started/server-and-client-components)，用于包裹所有页面。该文件位于 `app` 目录顶层。

Vite 应用中与之最接近的是 [`index.html` 文件](https://vitejs.dev/guide/#index-html-and-project-root)，包含 `<html>`、`<head>` 和 `<body>` 标签。

转换步骤：

1. 在 `src` 文件夹中创建 `app` 目录
2. 在 `app` 目录中创建 `layout.tsx` 文件：

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return '...'
}
```

> **须知**：布局文件可使用 `.js`、`.jsx` 或 `.tsx` 扩展名

3. 将 `index.html` 内容复制到 `<RootLayout>` 组件，并将 `body.div#root` 和 `body.script` 替换为 `<div id="root">{children}</div>`：

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/icon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/icon.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

4. Next.js 默认包含 [meta charset](https://developer.mozilla.org/docs/Web/HTML/Element/meta#charset) 和 [meta viewport](https://developer.mozilla.org/docs/Web/HTML/Viewport_meta_tag) 标签，可从 `<head>` 中移除：

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" type="image/svg+xml" href="/icon.svg" />
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="icon" type="image/svg+xml" href="/icon.svg" />
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

5. 将 [文件元数据](/docs/app/getting-started/metadata-and-og-images#file-based-metadata) 如 `favicon.ico`、`icon.png`、`robots.txt` 移至 `app` 目录顶层后，Next.js 会自动将其添加到 `<head>` 标签，此时可删除对应的 `<link>` 标签：

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <title>My App</title>
        <meta name="description" content="My App is a..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

6. 最后，使用 [元数据 API](/docs/app/getting-started/metadata-and-og-images) 管理剩余的 `<head>` 标签，将元数据信息移至导出的 [`metadata` 对象](/docs/app/api-reference/functions/generate-metadata#metadata-object)：

```tsx filename="app/layout.tsx" switcher
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My App',
  description: 'My App is a...',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export const metadata = {
  title: 'My App',
  description: 'My App is a...',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

通过以上变更，您从在 `index.html` 中声明所有内容转变为使用 Next.js 框架内置的基于约定的方法（[元数据 API](/docs/app/getting-started/metadata-and-og-images)），这能更轻松地提升页面的 SEO 和网络可分享性。

### 步骤 5：创建入口页面

在 Next.js 中，您可以通过创建 `page.tsx` 文件来声明应用的入口点。这与 Vite 中的 `main.tsx` 文件最为接近。本步骤将设置应用的入口点。

1. **在 `app` 目录下创建 `[[...slug]]` 目录**

由于本指南的目标是首先将 Next.js 设置为单页应用 (SPA)，您需要让页面入口捕获应用的所有可能路由。为此，请在 `app` 目录下创建一个新的 `[[...slug]]` 目录。

此目录称为 [可选全捕获路由段](/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments)。Next.js 使用基于文件系统的路由系统，其中文件夹用于定义路由。这个特殊目录将确保应用的所有路由都会定向到其包含的 `page.tsx` 文件。

2. **在 `app/[[...slug]]` 目录中创建一个新的 `page.tsx` 文件，内容如下：**

```tsx filename="app/[[...slug]]/page.tsx" switcher
import '../../index.css'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // 稍后更新此处
}
```

```jsx filename="app/[[...slug]]/page.js" switcher
import '../../index.css'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return '...' // 稍后更新此处
}
```

> **须知**：页面文件可以使用 `.js`、`.jsx` 或 `.tsx` 扩展名。

此文件是一个 [服务端组件 (Server Component)](/docs/app/getting-started/server-and-client-components)。运行 `next build` 时，文件会被预渲染为静态资源，无需任何动态代码。

该文件导入了全局 CSS，并告诉 [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) 我们只会生成一个路由，即根路径 `/`。

接下来，我们将迁移 Vite 应用的其余部分，这部分将仅在客户端运行。

```tsx filename="app/[[...slug]]/client.tsx" switcher
'use client'

import React from 'react'
import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

```jsx filename="app/[[...slug]]/client.js" switcher
'use client'

import React from 'react'
import dynamic from 'next/dynamic'

const App = dynamic(() => import('../../App'), { ssr: false })

export function ClientOnly() {
  return <App />
}
```

此文件是一个 [客户端组件 (Client Component)](/docs/app/getting-started/server-and-client-components)，由 `'use client'` 指令定义。客户端组件在发送到客户端之前仍会在服务器上 [预渲染为 HTML](/docs/app/getting-started/server-and-client-components#how-do-server-and-client-components-work-in-nextjs)。

由于我们目前需要一个纯客户端应用，可以配置 Next.js 从 `App` 组件开始禁用预渲染：

```tsx
const App = dynamic(() => import('../../App'), { ssr: false })
```

现在，更新入口页面以使用新组件：

```tsx filename="app/[[...slug]]/page.tsx" switcher
import '../../index.css'
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

```jsx filename="app/[[...slug]]/page.js" switcher
import '../../index.css'
import { ClientOnly } from './client'

export function generateStaticParams() {
  return [{ slug: [''] }]
}

export default function Page() {
  return <ClientOnly />
}
```

### 步骤 6：更新静态图片导入

Next.js 处理静态图片导入的方式与 Vite 略有不同。在 Vite 中，导入图片文件会返回其公共 URL 字符串：

```tsx filename="App.tsx"
import image from './img.png' // 生产环境中 `image` 会是 '/assets/img.2d8efhg.png'

export default function App() {
  return <img src={image} />
}
```

在 Next.js 中，静态图片导入会返回一个对象。该对象可以直接用于 Next.js 的 [`<Image>` 组件](/docs/app/api-reference/components/image)，也可以通过其 `src` 属性用于现有的 `<img>` 标签。

`<Image>` 组件具有 [自动图片优化](/docs/app/api-reference/components/image) 的额外优势。它会根据图片尺寸自动设置生成的 `<img>` 的 `width` 和 `height` 属性，防止图片加载时的布局偏移。但如果应用中存在仅设置了其中一个尺寸而未将另一个尺寸设为 `auto` 的图片，可能会导致问题。未设置为 `auto` 的尺寸会默认为 `<img>` 尺寸属性的值，可能导致图片显示失真。

保留 `<img>` 标签可以减少应用的改动量并避免上述问题。之后您可以逐步迁移到 `<Image>` 组件，通过 [配置 loader](/docs/app/api-reference/components/image#loader) 或切换到默认的 Next.js 服务器（支持自动图片优化）来优化图片。

1. **将 `/public` 导入的绝对路径转换为相对路径：**

```tsx
// 之前
import logo from '/logo.png'

// 之后
import logo from '../public/logo.png'
```

2. **将图片的 `src` 属性而非整个图片对象传递给 `<img>` 标签：**

```tsx
// 之前
<img src={logo} />

// 之后
<img src={logo.src} />
```

或者，您可以根据文件名引用图片资源的公共 URL。例如，`public/logo.png` 会在应用中通过 `/logo.png` 提供图片，该路径即为 `src` 值。

> **注意**：如果使用 TypeScript，访问 `src` 属性时可能会遇到类型错误。目前可以安全忽略这些错误，本指南后续会修复。

### 步骤 7：迁移环境变量

Next.js 支持与 Vite 类似的 `.env` [环境变量](/docs/app/guides/environment-variables)。主要区别在于客户端暴露环境变量的前缀。

- 将所有 `VITE_` 前缀的环境变量改为 `NEXT_PUBLIC_`。

Vite 在特殊的 `import.meta.env` 对象上暴露了一些内置环境变量，Next.js 不支持这些变量。需要按以下方式更新它们的用法：

- `import.meta.env.MODE` ⇒ `process.env.NODE_ENV`
- `import.meta.env.PROD` ⇒ `process.env.NODE_ENV === 'production'`
- `import.meta.env.DEV` ⇒ `process.env.NODE_ENV !== 'production'`
- `import.meta.env.SSR` ⇒ `typeof window !== 'undefined'`

Next.js 也没有内置的 `BASE_URL` 环境变量。但如果需要，您可以自行配置：

1. **在 `.env` 文件中添加以下内容：**

```bash filename=".env"
# ...
NEXT_PUBLIC_BASE_PATH="/some-base-path"
```

2. **在 `next.config.mjs` 文件中将 [`basePath`](/docs/app/api-reference/config/next-config-js/basePath) 设为 `process.env.NEXT_PUBLIC_BASE_PATH`：**

```js filename="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // 输出为单页应用 (SPA)
  distDir: './dist', // 将构建输出目录改为 `./dist/`
  basePath: process.env.NEXT_PUBLIC_BASE_PATH, // 设置基础路径为 `/some-base-path`
}

export default nextConfig
```

3. **将 `import.meta.env.BASE_URL` 的用法更新为 `process.env.NEXT_PUBLIC_BASE_PATH`**

### 步骤 8：更新 `package.json` 中的脚本

现在您应该可以运行应用以测试是否成功迁移到 Next.js。但在运行之前，需要更新 `package.json` 中的 `scripts` 为 Next.js 相关命令，并将 `.next` 和 `next-env.d.ts` 添加到 `.gitignore`：

```json filename="package.json"
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

```txt filename=".gitignore"
# ...
.next
next-env.d.ts
dist
```

现在运行 `npm run dev` 并打开 [`http://localhost:3000`](http://localhost:3000)，您应该会看到应用已在 Next.js 上运行。

> **示例**：查看 [此拉取请求](https://github.com/inngest/vite-to-nextjs/pull/1) 获取从 Vite 迁移到 Next.js 的完整示例。

### 步骤 9：清理

现在可以清理代码库中与 Vite 相关的文件：

- 删除 `main.tsx`
- 删除 `index.html`
- 删除 `vite-env.d.ts`
- 删除 `tsconfig.node.json`
- 删除 `vite.config.ts`
- 卸载 Vite 依赖项

## 后续步骤

如果一切顺利，您现在已拥有一个作为单页应用运行的 Next.js 应用。但您尚未充分利用 Next.js 的大多数优势，接下来可以逐步进行更改以获取全部收益。以下是建议的后续步骤：

- 从 React Router 迁移到 [Next.js App Router](/docs/app/building-your-application/routing)，以获得：
  - 自动代码拆分
  - [流式服务端渲染 (Streaming Server-Rendering)](/docs/app/building-your-application/routing/loading-ui-and-streaming)
  - [React 服务端组件 (React Server Components)](/docs/app/getting-started/server-and-client-components)
- [使用 `<Image>` 组件优化图片](/docs/app/api-reference/components/image)
- [使用 `next/font` 优化字体](/docs/app/api-reference/components/font)
- [使用 `<Script>` 组件优化第三方脚本](/docs/app/guides/scripts)
- [更新 ESLint 配置以支持 Next.js 规则](/docs/app/api-reference/config/eslint)
