---
source-updated-at: 2025-05-19T22:31:51.000Z
translation-updated-at: 2025-05-19T23:07:33.244Z
title: 如何使用服务端组件与客户端组件
nav_title: 服务端与客户端组件
description: 学习如何利用 React 的服务端组件 (Server Components) 和客户端组件 (Client Components) 在服务端或客户端渲染应用的不同部分。
related:
  title: 后续步骤
  description: 深入了解本页提到的 API。
  links:
    - app/api-reference/directives/use-client
    - app/api-reference/file-conventions/route
---

默认情况下，布局 (layouts) 和页面 (pages) 都是 [服务端组件 (Server Components)](https://react.dev/reference/rsc/server-components)，这允许你在服务端获取数据并渲染部分 UI，可选择缓存结果并流式传输到客户端。当需要交互性或浏览器 API 时，你可以使用 [客户端组件 (Client Components)](https://react.dev/reference/rsc/use-client) 来添加功能。

本页将解释服务端组件和客户端组件在 Next.js 中的工作原理、使用场景以及如何在应用中组合它们。

## 服务端与客户端组件在 Next.js 中如何工作？

### 在服务端

在服务端，Next.js 使用 React 的 API 来协调渲染工作。渲染任务按单个路由段（[布局和页面](/docs/app/getting-started/layouts-and-pages)）拆分为多个部分：

- **服务端组件** 会被渲染为一种特殊的数据格式，称为 React 服务端组件负载 (RSC Payload)。
- **客户端组件** 和 RSC Payload 用于 [预渲染 (prerender)](/docs/app/getting-started/partial-prerendering#how-does-partial-prerendering-work) HTML。

> **什么是 React 服务端组件负载 (RSC)？**
>
> RSC Payload 是渲染后的 React 服务端组件树的紧凑二进制表示形式。React 在客户端使用它来更新浏览器的 DOM。RSC Payload 包含：
>
> - 服务端组件的渲染结果
> - 客户端组件应渲染位置的占位符及其 JavaScript 文件的引用
> - 从服务端组件传递给客户端组件的任何 props

### 在客户端（首次加载）

然后，在客户端：

1. **HTML** 用于立即向用户显示路由的快速非交互式预览。
2. **RSC Payload** 用于协调客户端和服务端组件树。
3. **JavaScript** 用于水合 (hydrate) 客户端组件并使应用具有交互性。

> **什么是水合 (hydration)？**
>
> 水合是 React 将 [事件处理程序 (event handlers)](https://react.dev/learn/responding-to-events) 附加到 DOM 的过程，以使静态 HTML 具有交互性。

### 后续导航

在后续导航中：

- **RSC Payload** 会被预取并缓存以实现即时导航。
- **客户端组件** 完全在客户端渲染，无需服务端渲染的 HTML。

## 何时使用服务端与客户端组件？

客户端和服务端环境具有不同的能力。服务端和客户端组件允许你在各自的环境中运行逻辑，并在同一应用中组合它们。

在以下情况下使用 **客户端组件**：

- 需要 [状态 (state)](https://react.dev/learn/managing-state) 和 [事件处理程序 (event handlers)](https://react.dev/learn/responding-to-events)。例如 `onClick`、`onChange`。
- 需要 [生命周期逻辑 (lifecycle logic)](https://react.dev/learn/lifecycle-of-reactive-effects)。例如 `useEffect`。
- 需要使用浏览器专属 API。例如 `localStorage`、`window`、`Navigator.geolocation` 等。
- 需要使用 [自定义钩子 (custom hooks)](https://react.dev/learn/reusing-logic-with-custom-hooks)。

在以下情况下使用 **服务端组件**：

- 需要从数据库或靠近数据源的 API 获取数据。
- 需要使用 API 密钥、令牌和其他敏感信息而不暴露给客户端。
- 需要减少发送到浏览器的 JavaScript 数量。
- 需要提升 [首次内容绘制 (First Contentful Paint, FCP)](https://web.dev/fcp/) 并逐步将内容流式传输到客户端。

例如，`<Page>` 组件是一个服务端组件，它获取关于帖子的数据，并将其作为 props 传递给处理客户端交互的 `<LikeButton>`。

```tsx filename="app/[id]/page.tsx" highlight={1,12} switcher
import LikeButton from '@/app/ui/like-button'
import { getPost } from '@/lib/data'

export default async function Page({ params }: { params: { id: string } }) {
  const post = await getPost(params.id)

  return (
    <div>
      <main>
        <h1>{post.title}</h1>
        {/* ... */}
        <LikeButton likes={post.likes} />
      </main>
    </div>
  )
}
```

```jsx filename="app/[id]/page.js" highlight={1,12} switcher
import LikeButton from '@/app/ui/like-button'
import { getPost } from '@/lib/data'

export default async function Page({ params }) {
  const post = await getPost(params.id)

  return (
    <div>
      <main>
        <h1>{post.title}</h1>
        {/* ... */}
        <LikeButton likes={post.likes} />
      </main>
    </div>
  )
}
```

```tsx filename="app/ui/like-button.tsx" highlight={1} switcher
'use client'

import { useState } from 'react'

export default function LikeButton({ likes }: { likes: number }) {
  // ...
}
```

```jsx filename="app/ui/like-button.js" highlight={1} switcher
'use client'

import { useState } from 'react'

export default function LikeButton({ likes }) {
  // ...
}
```

## 示例

### 使用客户端组件

你可以通过在文件顶部（导入语句之上）添加 [`"use client"`](https://react.dev/reference/react/use-client) 指令来创建客户端组件。

```tsx filename="app/ui/counter.tsx" highlight={1} switcher
'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>{count} likes</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}
```

```jsx filename="app/ui/counter.tsx" highlight={1} switcher
'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>{count} likes</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}
```

`"use client"` 用于声明服务端和客户端模块图（树）之间的 **边界**。

一旦文件被标记为 `"use client"`，**其所有导入和子组件都将被视为客户端包的一部分**。这意味着你无需为每个客户端组件单独添加该指令。

### 减少 JS 包大小

为了减少客户端 JavaScript 包的大小，请将 `'use client'` 添加到特定的交互式组件，而不是将大部分 UI 标记为客户端组件。

例如，`<Layout>` 组件包含静态元素（如徽标和导航链接），但包含一个交互式搜索栏。`<Search />` 是交互式的，需要是客户端组件，而其余布局可以保持为服务端组件。

```tsx filename="app/ui/search.tsx" highlight={1} switcher
'use client'

export default function Search() {
  // ...
}
```

```tsx filename="app/ui/search.tsx" highlight={1} switcher
'use client'

export default function Search() {
  // ...
}
```

```tsx filename="app/layout.tsx" switcher
// 客户端组件
import Search from './search'
// 服务端组件
import Logo from './logo'

// 默认情况下 Layout 是服务端组件
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <Search />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

```jsx filename="app/layout.js" switcher
// 客户端组件
import Search from './search'
// 服务端组件
import Logo from './logo'

// 默认情况下 Layout 是服务端组件
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <Search />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

### 从服务端组件传递数据到客户端组件

你可以通过 props 将数据从服务端组件传递到客户端组件。

```tsx filename="app/[id]/page.tsx" highlight={1,7} switcher
import LikeButton from '@/app/ui/like-button'
import { getPost } from '@/lib/data'

export default async function Page({ params }: { params: { id: string } }) {
  const post = await getPost(params.id)

  return <LikeButton likes={post.likes} />
}
```

```jsx filename="app/[id]/page.js" highlight={1,7} switcher
import LikeButton from '@/app/ui/like-button'
import { getPost } from '@/lib/data'

export default async function Page({ params }) {
  const post = await getPost(params.id)

  return <LikeButton likes={post.likes} />
}
```

```tsx filename="app/ui/like-button.tsx" highlight={1} switcher
'use client'

export default function LikeButton({ likes }: { likes: number }) {
  // ...
}
```

```jsx filename="app/ui/like-button.js" highlight={1} switcher
'use client'

export default function LikeButton({ likes }) {
  // ...
}
```

或者，你可以使用 [`use` Hook](https://react.dev/reference/react/use) 将数据从服务端组件流式传输到客户端组件。参见 [示例](/docs/app/getting-started/fetching-data#streaming-data-with-the-use-hook)。

> **须知**：传递给客户端组件的 props 需要是 React 可 [序列化 (serializable)](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values) 的。

### 交错使用服务端与客户端组件

你可以将服务端组件作为 prop 传递给客户端组件。这允许你在客户端组件中嵌套服务端渲染的 UI。

一种常见模式是使用 `children` 在 `<ClientComponent>` 中创建一个 **插槽 (slot)**。例如，一个在服务端获取数据的 `<Cart>` 组件，嵌套在使用客户端状态控制可见性的 `<Modal>` 组件中。

```tsx filename="app/ui/modal.tsx" switcher
'use client'

export default function Modal({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}
```

```jsx filename="app/ui/modal.js" switcher
'use client'

export default function Modal({ children }) {
  return <div>{children}</div>
}
```

然后，在父级服务端组件（例如 `<Page>`）中，你可以将 `<Cart>` 作为 `<Modal>` 的子组件传递：

```tsx filename="app/page.tsx"  highlight={7} switcher
import Modal from './ui/modal'
import Cart from './ui/cart'

export default function Page() {
  return (
    <Modal>
      <Cart />
    </Modal>
  )
}
```

```jsx filename="app/page.js" highlight={7} switcher
import Modal from './ui/modal'
import Cart from './ui/cart'

export default function Page() {
  return (
    <Modal>
      <Cart />
    </Modal>
  )
}
```

在这种模式下，所有服务端组件（包括作为 props 传递的组件）都会提前在服务端渲染。生成的 RSC Payload 将包含客户端组件在组件树中的渲染位置引用。

### 上下文提供者

[React 上下文 (context)](https://react.dev/learn/passing-data-deeply-with-context) 通常用于共享全局状态（如当前主题）。然而，React 上下文在服务端组件中不受支持。

要使用上下文，可以创建一个接受 `children` 的客户端组件：

```tsx filename="app/theme-provider.tsx" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({
  children,
}: {
  children: React.ReactNode
}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

```jsx filename="app/theme-provider.js" switcher
'use client'

import { createContext } from 'react'

export const ThemeContext = createContext({})

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

然后，将其导入到服务端组件（例如 `layout`）中：

```tsx filename="app/layout.tsx" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import ThemeProvider from './theme-provider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

现在，你的服务端组件可以直接渲染提供者，而应用中的所有其他客户端组件都可以消费此上下文。

> **须知**：你应该尽可能将提供者渲染在树的深层——注意 `ThemeProvider` 仅包裹 `{children}` 而不是整个 `<html>` 文档。这使得 Next.js 更容易优化服务端组件的静态部分。

### 第三方组件

当使用依赖客户端专属功能的第三方组件时，可以将其包装在客户端组件中以确保其正常工作。

例如，`<Carousel />` 可以从 `acme-carousel` 包中导入。该组件使用了 `useState`，但尚未添加 `"use client"` 指令。

如果在客户端组件中使用 `<Carousel />`，它将按预期工作：

```tsx filename="app/gallery.tsx" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>
      {/* 正常工作，因为 Carousel 在客户端组件中使用 */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

```jsx filename="app/gallery.js" switcher
'use client'

import { useState } from 'react'
import { Carousel } from 'acme-carousel'

export default function Gallery() {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>
      {/* 正常工作，因为 Carousel 在客户端组件中使用 */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

然而，如果直接在服务端组件中使用它，你会看到错误。这是因为 Next.js 不知道 `<Carousel />` 使用了客户端专属功能。

要解决此问题，可以将依赖客户端专属功能的第三方组件包装在你自己的客户端组件中：

```tsx filename="app/carousel.tsx" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

```jsx filename="app/carousel.js" switcher
'use client'

import { Carousel } from 'acme-carousel'

export default Carousel
```

现在，你可以直接在服务端组件中使用 `<Carousel />`：

```tsx filename="app/page.tsx" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>
      {/* 正常工作，因为 Carousel 是客户端组件 */}
      <Carousel />
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
import Carousel from './carousel'

export default function Page() {
  return (
    <div>
      <p>View pictures</p>
      {/* 正常工作，因为 Carousel 是客户端组件 */}
      <Carousel />
    </div>
  )
}
```

> **给库作者的建议**
>
> 如果你正在构建组件库，请将 `"use client"` 指令添加到依赖客户端专属功能的入口点。这样，用户无需创建包装器即可将组件导入到服务端组件中。
>
> 需要注意的是，某些打包工具可能会移除 `"use client"` 指令。你可以在 [React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13) 和 [Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30) 仓库中找到如何配置 esbuild 以包含 `"use client"` 指令的示例。

### 防止环境变量污染

JavaScript 模块可以在服务端组件 (Server Components) 和客户端组件 (Client Components) 之间共享，这意味着可能会意外将仅限服务端的代码导入到客户端。

例如，以下函数：

```js filename="lib/data.js" switcher
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

该函数包含一个绝不应该暴露给客户端的 `API_KEY` 环境变量。

在 Next.js 中，只有以 `NEXT_PUBLIC_` 为前缀的环境变量会被包含在客户端代码包 (client bundle) 中。如果变量没有该前缀，Next.js 会将其替换为空字符串。

因此，即使 `getData()` 可以被导入并在客户端执行，它也不会按预期工作。

为了防止在客户端组件中意外使用这些代码，可以使用 [`server-only` 包](https://www.npmjs.com/package/server-only)。

```bash filename="Terminal"
npm install server-only
```

然后，在包含仅限服务端代码的文件中导入该包：

```js filename="lib/data.js"
import 'server-only'

export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })

  return res.json()
}
```

现在，如果尝试将该模块导入到客户端组件中，将会在构建时抛出错误。

> **须知**：对应的 [`client-only` 包](https://www.npmjs.com/package/client-only) 可用于标记包含仅限客户端代码的模块——例如访问 `window` 对象的代码。
