---
source-updated-at: 2025-05-19T22:31:51.000Z
translation-updated-at: 2025-05-19T23:06:15.558Z
title: 如何使用部分预渲染 (Partial Prerendering)
nav_title: 部分预渲染 (PPR)
description: 学习如何通过部分预渲染 (Partial Prerendering) 结合静态渲染与动态渲染的优势。
version: experimental
related:
  title: 后续步骤
  description: 了解更多关于部分预渲染 (PPR) 的配置选项。
  links:
    - app/api-reference/config/next-config-js/ppr
---

部分预渲染 (Partial Prerendering, PPR) 是一种渲染策略，允许你在同一路由中结合静态与动态内容。这既能提升初始页面性能，又能支持个性化的动态数据。

<Image
  alt="部分预渲染的产品页面展示静态导航栏和产品信息，以及动态购物车和推荐商品"
  srcLight="/learn/light/thinking-in-ppr.png"
  srcDark="/learn/dark/thinking-in-ppr.png"
  width="1600"
  height="632"
/>

当用户访问路由时：

- 服务器发送包含静态内容的 **外壳 (shell)**，确保快速初始加载。
- 外壳为动态内容预留 **空缺 (holes)**，这些内容将异步加载。
- 动态空缺会 **并行流式传输 (streamed in parallel)**，减少页面的整体加载时间。

> **🎥 观看视频：** 为什么需要 PPR 及其工作原理 → [YouTube (10 分钟)](https://www.youtube.com/watch?v=MTcPrTIBkpA)。

## 部分预渲染如何工作？

要理解部分预渲染，需要先熟悉 Next.js 提供的渲染策略。

### 静态渲染 (Static Rendering)

静态渲染会提前生成 HTML —— 可以在构建时或通过 [重新验证 (revalidation)](/docs/app/building-your-application/data-fetching/incremental-static-regeneration) 完成。结果会被缓存并在用户和请求间共享。

在部分预渲染中，Next.js 会为路由预渲染一个 **静态外壳 (static shell)**，包含布局和任何不依赖请求时数据的组件。

### 动态渲染 (Dynamic Rendering)

动态渲染会在 **请求时 (request time)** 生成 HTML，从而根据请求时的数据提供个性化内容。

组件在以下情况下会变为动态：

- 使用 [`cookies`](/docs/app/api-reference/functions/cookies)
- 使用 [`headers`](/docs/app/api-reference/functions/headers)
- 使用 [`connection`](/docs/app/api-reference/functions/connection)
- 使用 [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- 使用 [`searchParams` 属性](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- 使用 [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)
- 使用 `{ cache: 'no-store' }` 的 [`fetch`](/docs/app/api-reference/functions/fetch)

在部分预渲染中，使用这些 API 会抛出特殊的 React 错误，提示 Next.js 该组件无法静态渲染，导致构建错误。你可以使用 [Suspense](#suspense) 将渲染推迟到运行时。

### Suspense

React 的 [Suspense](https://react.dev/reference/react/Suspense) 用于延迟渲染部分应用，直到满足某些条件。

在部分预渲染中，Suspense 用于标记组件树中的 **动态边界 (dynamic boundaries)**。

构建时，Next.js 会预渲染静态内容和 `fallback` UI。动态内容会 **推迟 (postponed)** 到用户请求路由时加载。

用 Suspense 包裹组件不会使组件本身变为动态（动态性由 API 使用决定），而是作为封装动态内容的边界，并启用 [流式传输 (streaming)](#streaming)。

```jsx filename="app/page.js"
import { Suspense } from 'react'
import StaticComponent from './StaticComponent'
import DynamicComponent from './DynamicComponent'
import Fallback from './Fallback'

export const experimental_ppr = true

export default function Page() {
  return (
    <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
    </>
  )
}
```

### 流式传输 (Streaming)

流式传输将路由拆分为多个块，并在准备就绪时逐步传输到客户端。这样用户可以在整个内容完成渲染前立即看到部分页面。

<Image
  alt="图表展示客户端部分渲染的页面，以及正在流式传输的区块加载 UI。"
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

在部分预渲染中，包裹在 Suspense 中的动态组件会从服务器并行流式传输。

<Image
  alt="图表展示流式传输期间路由段的并行化，显示各个区块的数据获取、渲染和水合。"
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

为了减少网络开销，完整响应（包括静态 HTML 和流式传输的动态部分）会在 **单个 HTTP 请求** 中发送。这避免了额外的往返，提升了初始加载和整体性能。

## 启用部分预渲染

你可以通过在 `next.config.ts` 文件中添加 [`ppr`](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr) 选项来启用 PPR：

```ts filename="next.config.ts" highlight={5} switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

export default nextConfig
```

```js filename="next.config.js" highlight={4} switcher
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}
```

`'incremental'` 值允许你为特定路由启用 PPR：

```tsx filename="/app/dashboard/layout.tsx"
export const experimental_ppr = true

export default function Layout({ children }: { children: React.ReactNode }) {
  // ...
}
```

```jsx filename="/app/dashboard/layout.js"
export const experimental_ppr = true

export default function Layout({ children }) {
  // ...
}
```

未设置 `experimental_ppr` 的路由会默认为 `false`，不会使用 PPR 预渲染。你需要为每个路由显式启用 PPR。

> **须知：**
>
> - `experimental_ppr` 会应用到路由段的所有子节点，包括嵌套布局和页面。你无需在每个文件中添加，只需在路由的顶层段设置。
> - 要为子段禁用 PPR，可以在子段中将 `experimental_ppr` 设为 `false`。

## 示例

### 动态 API

当使用需要查看请求的动态 API 时，Next.js 会为该路由启用动态渲染。要继续使用 PPR，请用 Suspense 包裹组件。例如，`<User />` 组件因使用 `cookies` API 而变为动态：

```jsx filename="app/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

```tsx filename="app/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

`<User />` 组件会流式传输，而 `<Page />` 中的其他内容会被预渲染并成为静态外壳的一部分。

```tsx filename="app/page.tsx" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>这部分会被预渲染</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>这部分会被预渲染</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

### 传递动态属性

组件仅在访问值时才会启用动态渲染。例如，如果你从 `<Page />` 组件读取 `searchParams`，可以将其作为属性传递给其他组件：

```tsx filename="app/page.tsx" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  return (
    <section>
      <h1>这部分会被预渲染</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({ searchParams }) {
  return (
    <section>
      <h1>这部分会被预渲染</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

在表格组件内部，访问 `searchParams` 的值会使该组件变为动态，而页面的其余部分会被预渲染。

```tsx filename="app/table.tsx" switcher
export async function Table({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

```jsx filename="app/table.js" switcher
export async function Table({ searchParams }) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```