---
source-updated-at: 2025-05-25T15:16:02.000Z
translation-updated-at: 2025-05-25T20:30:03.863Z
title: 服务端操作与数据变更
nav_title: 服务端操作与数据变更
description: 了解如何使用 Next.js 处理表单提交和数据变更。
related:
  description: 了解如何在 Next.js 中配置服务端操作
  links:
    - app/api-reference/config/next-config-js/serverActions
---

[服务端操作 (Server Actions)](https://react.dev/reference/rsc/server-actions) 是在服务端执行的**异步函数**。它们可以在服务端和客户端组件中调用，用于处理 Next.js 应用中的表单提交和数据变更。

> **🎥 观看视频:** 了解更多关于服务端操作的数据变更 → [YouTube (10分钟)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## 约定

可以通过 React 的 [`"use server"`](https://react.dev/reference/react/use-server) 指令定义服务端操作。您可以将该指令放在 `async` 函数顶部以标记该函数为服务端操作，或者放在单独文件顶部以标记该文件所有导出为服务端操作。

### 服务端组件

服务端组件可以使用函数级或模块级的 `"use server"` 指令。要内联定义服务端操作，请在函数体顶部添加 `"use server"`：

```tsx filename="app/page.tsx" switcher
export default function Page() {
  // 服务端操作
  async function create() {
    'use server'
    // 数据变更
  }

  return '...'
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  // 服务端操作
  async function create() {
    'use server'
    // 数据变更
  }

  return '...'
}
```

### 客户端组件

要在[客户端组件](/docs/app/getting-started/updating-data#server-functions)中调用服务端函数，需创建新文件并在顶部添加 `"use server"` 指令。该文件内所有导出函数都将被标记为可在客户端和服务端组件中复用的服务端函数：

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {}
```

```tsx filename="app/button.tsx" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>创建</button>
}
```

```jsx filename="app/button.js" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>创建</button>
}
```

### 将操作作为属性传递

您也可以将服务端操作作为属性传递给客户端组件：

```jsx
<ClientComponent updateItemAction={updateItem} />
```

```tsx filename="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

```jsx filename="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

通常，Next.js TypeScript 插件会标记 `client-component.tsx` 中的 `updateItemAction`，因为函数通常无法跨客户端-服务端边界序列化。但以 `action` 结尾或命名的属性会被假定为接收服务端操作。这只是启发式规则，因为 TypeScript 插件实际上无法判断接收的是服务端操作还是普通函数。运行时类型检查仍会确保您不会意外将函数传递给客户端组件。

## 行为特性

- 服务端操作可通过 [`<form>` 元素](#forms) 的 `action` 属性调用：
  - 服务端组件默认支持渐进增强，即使 JavaScript 未加载或禁用，表单仍可提交。
  - 在客户端组件中，调用服务端操作的表单会在 JavaScript 未加载时排队提交，优先进行客户端水合。
  - 水合后，表单提交不会导致浏览器刷新。
- 服务端操作不仅限于 `<form>`，可从事件处理器、`useEffect`、第三方库及其他表单元素（如 `<button>`）调用。
- 服务端操作与 Next.js [缓存和重新验证](/docs/app/deep-dive/caching) 架构集成。操作调用时，Next.js 可在单次服务端往返中返回更新的 UI 和新数据。
- 底层实现使用 `POST` 方法，仅此 HTTP 方法可调用操作。
- 服务端操作的参数和返回值必须可被 React 序列化。参见 React 文档了解 [可序列化参数和值](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values)。
- 服务端操作是函数，意味着可在应用中任何位置复用。
- 服务端操作继承所在页面或布局的运行时环境。
- 服务端操作继承所在页面或布局的 [路由段配置](/docs/app/api-reference/file-conventions/route-segment-config)，包括 `maxDuration` 等字段。

## 示例

### 表单

React 扩展了 HTML [`<form>`](https://developer.mozilla.org/docs/Web/HTML/Element/form) 元素，允许通过 `action` 属性调用服务端操作。

表单中调用时，操作自动接收 [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData) 对象。无需使用 React `useState` 管理字段，可直接使用原生 [FormData 方法](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods) 提取数据：

```tsx filename="app/invoices/page.tsx" switcher
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // 数据变更
    // 重新验证缓存
  }

  return <form action={createInvoice}>...</form>
}
```

```jsx filename="app/invoices/page.js" switcher
export default function Page() {
  async function createInvoice(formData) {
    'use server'

    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }

    // 数据变更
    // 重新验证缓存
  }

  return <form action={createInvoice}>...</form>
}
```

> **须知：**
>
> - 示例: [带加载和错误状态的表单](https://github.com/vercel/next.js/tree/canary/examples/next-forms)
> - 处理多字段表单时，可考虑使用 [`entries()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/entries) 方法配合 JavaScript 的 [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)。例如：`const rawFormData = Object.fromEntries(formData)`。注意 `formData` 会包含额外的 `$ACTION_` 属性。
> - 参阅 [React `<form>` 文档](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-action) 了解更多。

### 传递额外参数

可通过 JavaScript `bind` 方法向服务端操作传递额外参数。

```tsx filename="app/client-component.tsx" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">更新用户名</button>
    </form>
  )
}
```

```jsx filename="app/client-component.js" highlight={6} switcher
'use client'

import { updateUser } from './actions'

export function UserProfile({ userId }) {
  const updateUserWithId = updateUser.bind(null, userId)

  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">更新用户名</button>
    </form>
  )
}
```

服务端操作将接收 `userId` 参数及表单数据：

```ts filename="app/actions.ts" switcher
'use server'

export async function updateUser(userId: string, formData: FormData) {}
```

```js filename="app/actions.js" switcher
'use server'

export async function updateUser(userId, formData) {}
```

> **须知**:
>
> - 替代方案是将参数作为隐藏输入字段传递（如 `<input type="hidden" name="userId" value={userId} />`）。但值会成为渲染 HTML 的一部分且不会被编码。
> - `.bind` 在服务端和客户端组件中均有效，也支持渐进增强。

### 嵌套表单元素

也可在 `<form>` 内的嵌套元素（如 `<button>`、`<input type="submit">` 和 `<input type="image">`）中调用服务端操作。这些元素接受 `formAction` 属性或[事件处理器](#event-handlers)。

这在需要单表单内调用多个服务端操作时很有用。例如，除了发布按钮外，可为保存草稿创建特定 `<button>` 元素。详见 [React `<form>` 文档](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)。

### 编程式表单提交

可使用 [`requestSubmit()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit) 方法编程触发表单提交。例如，当用户使用 `⌘` + `Enter` 快捷键提交时，可监听 `onKeyDown` 事件：

```tsx filename="app/entry.tsx" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

```jsx filename="app/entry.js" switcher
'use client'

export function Entry() {
  const handleKeyDown = (e) => {
    if (
      (e.ctrlKey || e.metaKey) &&
      (e.key === 'Enter' || e.key === 'NumpadEnter')
    ) {
      e.preventDefault()
      e.currentTarget.form?.requestSubmit()
    }
  }

  return (
    <div>
      <textarea name="entry" rows={20} required onKeyDown={handleKeyDown} />
    </div>
  )
}
```

这将触发最近 `<form>` 祖先的提交，从而调用服务端操作。

### 服务端表单验证

可使用 `required` 和 `type="email"` 等 HTML 属性进行基本客户端验证。

更高级的服务端验证可使用 [zod](https://zod.dev/) 等库在数据变更前验证表单字段：

```tsx filename="app/actions.ts" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '无效邮箱',
  }),
})

export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // 表单数据无效时提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 数据变更
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { z } from 'zod'

const schema = z.object({
  email: z.string({
    invalid_type_error: '无效邮箱',
  }),
})

export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })

  // 表单数据无效时提前返回
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }

  // 数据变更
}
```

服务端验证字段后，可在操作中返回可序列化对象，并使用 React `useActionState` 钩子向用户显示消息。

- 将操作传递给 `useActionState` 后，函数签名会新增首个参数 `prevState` 或 `initialState`。
- `useActionState` 是 React 钩子，因此必须在客户端组件中使用。

```tsx filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState: any, formData: FormData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '请输入有效邮箱' }
  }

  redirect('/dashboard')
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createUser(prevState, formData) {
  const res = await fetch('https://...')
  const json = await res.json()

  if (!res.ok) {
    return { message: '请输入有效邮箱' }
  }

  redirect('/dashboard')
}
```

然后可将操作传递给 `useActionState` 钩子，使用返回的 `state` 显示错误消息。

```tsx filename="app/ui/signup.tsx" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">邮箱</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>注册</button>
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" highlight={11,18-20} switcher
'use client'

import { useActionState } from 'react'
import { createUser } from '@/app/actions'

const initialState = {
  message: '',
}

export function Signup() {
  const [state, formAction, pending] = useActionState(createUser, initialState)

  return (
    <form action={formAction}>
      <label htmlFor="email">邮箱</label>
      <input type="text" id="email" name="email" required />
      {/* ... */}
      <p aria-live="polite">{state?.message}</p>
      <button disabled={pending}>注册</button>
    </form>
  )
}
```

### 挂起状态

[`useActionState`](https://react.dev/reference/react/useActionState) 钩子提供了一个 `pending` 布尔值，可用于在操作执行期间显示加载指示器。

或者，您可以使用 [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) 钩子在操作执行期间显示加载指示器。使用此钩子时，需要创建一个单独的组件来渲染加载指示器。例如，在操作挂起时禁用按钮：

```tsx filename="app/ui/button.tsx" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      注册
    </button>
  )
}
```

```jsx filename="app/ui/button.js" highlight={6} switcher
'use client'

import { useFormStatus } from 'react-dom'

export function SubmitButton() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending} type="submit">
      注册
    </button>
  )
}
```

然后可以将 `SubmitButton` 组件嵌套在表单中：

```tsx filename="app/ui/signup.tsx" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* 其他表单元素 */}
      <SubmitButton />
    </form>
  )
}
```

```jsx filename="app/ui/signup.js" switcher
import { SubmitButton } from './button'
import { createUser } from '@/app/actions'

export function Signup() {
  return (
    <form action={createUser}>
      {/* 其他表单元素 */}
      <SubmitButton />
    </form>
  )
}
```

> **须知：** 在 React 19 中，`useFormStatus` 返回的对象包含额外的键，如 data、method 和 action。如果您未使用 React 19，则仅 `pending` 键可用。

### 乐观更新

您可以使用 React 的 [`useOptimistic`](https://react.dev/reference/react/useOptimistic) 钩子在服务器操作完成执行前乐观地更新 UI，而不是等待响应：

```tsx filename="app/page.tsx" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

type Message = {
  message: string
}

export function Thread({ messages }: { messages: Message[] }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic<
    Message[],
    string
  >(messages, (state, newMessage) => [...state, { message: newMessage }])

  const formAction = async (formData: FormData) => {
    const message = formData.get('message') as string
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m, i) => (
        <div key={i}>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">发送</button>
      </form>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useOptimistic } from 'react'
import { send } from './actions'

export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )

  const formAction = async (formData) => {
    const message = formData.get('message')
    addOptimisticMessage(message)
    await send(message)
  }

  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form action={formAction}>
        <input type="text" name="message" />
        <button type="submit">发送</button>
      </form>
    </div>
  )
}
```

### 事件处理程序

虽然通常在 `<form>` 元素中使用服务器操作，但它们也可以通过 `onClick` 等事件处理程序调用。例如，增加点赞数：

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>总点赞数：{likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        点赞
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>总点赞数：{likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        点赞
      </button>
    </>
  )
}
```

您还可以为表单元素添加事件处理程序，例如在 `onChange` 时保存表单字段：

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">发布</button>
    </form>
  )
}
```

对于此类可能快速触发多个事件的情况，我们建议使用**防抖**来避免不必要的服务器操作调用。

### `useEffect`

您可以使用 React 的 [`useEffect`](https://react.dev/reference/react/useEffect) 钩子在组件挂载或依赖项更改时调用服务器操作。这对于依赖于全局事件或需要自动触发的变更非常有用。例如，`onKeyDown` 用于应用快捷键、无限滚动的交叉观察器钩子，或在组件挂载时更新视图计数：

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    startTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // 可以使用 `isPending` 向用户提供反馈
  return <p>总浏览量：{views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    starTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // 可以使用 `isPending` 向用户提供反馈
  return <p>总浏览量：{views}</p>
}
```

请记住考虑 [`useEffect` 的行为和注意事项](https://react.dev/reference/react/useEffect#caveats)。

### 错误处理

当抛出错误时，它将被客户端最近的 `error.js` 或 `<Suspense>` 边界捕获。有关更多信息，请参阅[错误处理](/docs/app/building-your-application/routing/error-handling)。

> **须知：**
>
> - 除了抛出错误外，您还可以返回一个对象供 `useActionState` 处理。请参阅[服务端验证和错误处理](#server-side-form-validation)。

### 重新验证数据

您可以在服务器操作中使用 [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) API 重新验证 [Next.js 缓存](/docs/app/deep-dive/caching)：

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

或者使用 [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) 通过缓存标签使特定数据获取失效：

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### 重定向

如果您希望在服务器操作完成后将用户重定向到不同的路由，可以使用 [`redirect`](/docs/app/api-reference/functions/redirect) API。`redirect` 需要在 `try/catch` 块外部调用：

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // 更新缓存的帖子
  redirect(`/post/${id}`) // 导航到新帖子页面
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // 更新缓存的帖子
  redirect(`/post/${id}`) // 导航到新帖子页面
}
```

### Cookies

您可以在服务器操作中使用 [`cookies`](/docs/app/api-reference/functions/cookies) API 来 `get`、`set` 和 `delete` cookies：

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // 获取 cookie
  cookieStore.get('name')?.value

  // 设置 cookie
  cookieStore.set('name', 'Delba')

  // 删除 cookie
  cookieStore.delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // 获取 cookie
  const cookieStore = await cookies()

  // 获取 cookie
  cookieStore.get('name')?.value

  // 设置 cookie
  cookieStore.set('name', 'Delba')

  // 删除 cookie
  cookieStore.delete('name')
}
```

有关从服务器操作中删除 cookies 的更多示例，请参阅[其他示例](/docs/app/api-reference/functions/cookies#deleting-cookies)。

## 安全性

默认情况下，当创建并导出一个服务器操作时，它会创建一个公共 HTTP 端点，应使用相同的安全假设和授权检查进行处理。这意味着，即使服务器操作或实用函数未在代码的其他地方导入，它仍然是公开可访问的。

为了提高安全性，Next.js 具有以下内置功能：

- **安全操作 ID**：Next.js 创建加密的、非确定性的 ID，允许客户端引用和调用服务器操作。这些 ID 在构建之间定期重新计算以增强安全性。
- **死代码消除**：未使用的服务器操作（通过其 ID 引用）将从客户端包中删除，以避免第三方公开访问。

> **须知**：
>
> ID 在编译期间创建，并最多缓存 14 天。它们将在启动新构建或构建缓存失效时重新生成。
> 此安全改进在缺少身份验证层的情况下降低了风险。但是，您仍应将服务器操作视为公共 HTTP 端点。

```jsx
// app/actions.js
'use server'

// 此操作**已**在我们的应用程序中使用，因此 Next.js
// 将创建一个安全 ID 以允许客户端引用
// 并调用服务器操作。
export async function updateUserAction(formData) {}

// 此操作**未**在我们的应用程序中使用，因此 Next.js
// 将在 `next build` 期间自动删除此代码
// 并且不会创建公共端点。
export async function deleteUserAction(formData) {}
```

### 身份验证和授权

您应确保用户有权执行操作。例如：

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('您必须登录才能执行此操作')
  }

  // ...
}
```

### 闭包和加密

在组件内定义服务器操作会创建一个[闭包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)，其中操作可以访问外部函数的作用域。例如，`publish` 操作可以访问 `publishVersion` 变量：

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('自按下发布以来版本已更改');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>发布</button>
    </form>
  );
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('自按下发布以来版本已更改');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>发布</button>
    </form>
  );
}
```

闭包在需要捕获数据的**快照**（例如 `publishVersion`）以便在操作调用时使用非常有用。

然而，为了实现这一点，捕获的变量会发送到客户端并在操作调用时返回服务器。为了防止敏感数据暴露给客户端，Next.js 会自动加密闭包变量。每次构建 Next.js 应用程序时，都会为每个操作生成一个新的私钥。这意味着操作只能针对特定构建调用。

> **须知：** 我们不建议仅依赖加密来防止敏感值暴露在客户端。相反，您应使用 [React taint APIs](/docs/app/api-reference/config/next-config-js/taint) 主动防止特定数据发送到客户端。

### 覆盖加密密钥（高级）

在多个服务器上自托管 Next.js 应用程序时，每个服务器实例可能最终使用不同的加密密钥，从而导致潜在的不一致。

为了缓解这种情况，您可以使用 `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY` 环境变量覆盖加密密钥。指定此变量可确保您的加密密钥在构建之间保持一致，并且所有服务器实例使用相同的密钥。此变量**必须**是 AES-GCM 加密的。

这是一个高级用例，其中跨多个部署的一致加密行为对您的应用程序至关重要。您应考虑标准的安全实践，如密钥轮换和签名。

> **须知：** 部署到 Vercel 的 Next.js 应用程序会自动处理此问题。

### 允许的来源（高级配置）

由于服务端操作 (Server Actions) 可以通过 `<form>` 元素调用，这使得它们容易受到 [CSRF 攻击](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) 的威胁。

在底层实现中，服务端操作使用 `POST` 方法，并且仅允许通过该 HTTP 方法进行调用。这一机制配合现代浏览器默认启用的 [SameSite Cookie](https://web.dev/articles/samesite-cookies-explained)，能够有效防范大多数 CSRF 漏洞。

作为额外的安全措施，Next.js 中的服务端操作还会比较 [Origin 标头](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) 与 [Host 标头](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)（或 `X-Forwarded-Host`）。如果两者不匹配，请求将被中止。换句话说，服务端操作只能由托管它的页面所在的主机发起调用。

对于使用反向代理或多层后端架构（服务器 API 与生产域名不同）的大型应用，建议通过配置项 [`serverActions.allowedOrigins`](/docs/app/api-reference/config/next-config-js/serverActions) 指定安全来源列表。该选项接受字符串数组作为参数。

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

了解更多关于 [安全性与服务端操作](https://nextjs.org/blog/security-nextjs-server-components-actions) 的内容。

## 扩展资源

更多信息请参阅以下 React 文档：

- [服务端操作](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
