---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T17:42:19.982Z
title: Authentifizierung
description: Erfahren Sie, wie Sie Authentifizierung in Next.js implementieren, einschlie√ülich Best Practices, Absicherung von Routen, Autorisierungstechniken und Session-Management.
---

Um Authentifizierung in Next.js zu implementieren, sollten Sie sich mit drei grundlegenden Konzepten vertraut machen:

- **[Authentifizierung](#authentication)** best√§tigt, ob der Benutzer derjenige ist, f√ºr den er sich ausgibt. Der Benutzer muss seine Identit√§t mit etwas nachweisen, das er besitzt, wie z.B. einem Benutzernamen und Passwort.
- **[Session-Management](#session-management)** verfolgt den Zustand des Benutzers (z.B. eingeloggt) √ºber mehrere Anfragen hinweg.
- **[Autorisierung](#authorization)** entscheidet, auf welche Teile der Anwendung der Benutzer zugreifen darf.

Diese Seite zeigt, wie Sie Next.js-Funktionen nutzen k√∂nnen, um g√§ngige Authentifizierungs-, Autorisierungs- und Session-Management-Muster zu implementieren, damit Sie die besten L√∂sungen basierend auf den Anforderungen Ihrer Anwendung ausw√§hlen k√∂nnen.

## Authentifizierung

Authentifizierung best√§tigt die Identit√§t eines Benutzers. Dies geschieht, wenn sich ein Benutzer anmeldet, entweder mit einem Benutzernamen und Passwort oder √ºber einen Dienst wie Google. Es geht darum zu best√§tigen, dass Benutzer wirklich diejenigen sind, f√ºr die sie sich ausgeben, um sowohl die Daten des Benutzers als auch die Anwendung vor unbefugtem Zugriff oder betr√ºgerischen Aktivit√§ten zu sch√ºtzen.

### Authentifizierungsstrategien

Moderne Webanwendungen verwenden h√§ufig mehrere Authentifizierungsstrategien:

1. **OAuth/OpenID Connect (OIDC)**: Erm√∂glichen Zugriff durch Dritte ohne Weitergabe von Benutzeranmeldedaten. Ideal f√ºr Social-Media-Logins und Single Sign-On (SSO)-L√∂sungen. Sie f√ºgen eine Identit√§tsschicht mit OpenID Connect hinzu.
2. **Anmeldedaten-basierte Anmeldung (E-Mail + Passwort)**: Eine Standardwahl f√ºr Webanwendungen, bei der sich Benutzer mit einer E-Mail und einem Passwort anmelden. Vertraut und einfach zu implementieren, erfordert es robuste Sicherheitsma√ünahmen gegen Bedrohungen wie Phishing.
3. **Passwortlose/Token-basierte Authentifizierung**: Verwendet E-Mail-Magic-Links oder SMS-Einmalcodes f√ºr sicheren, passwortfreien Zugriff. Beliebt wegen seiner Bequemlichkeit und verbesserten Sicherheit, hilft diese Methode, Passwortm√ºdigkeit zu reduzieren. Ihre Einschr√§nkung ist die Abh√§ngigkeit von der Verf√ºgbarkeit der E-Mail oder des Telefons des Benutzers.
4. **Passkeys/WebAuthn**: Verwendet kryptografische Anmeldedaten, die f√ºr jede Website einzigartig sind, und bietet hohe Sicherheit gegen Phishing. Sicher aber neu, diese Strategie kann schwierig zu implementieren sein.

Die Auswahl einer Authentifizierungsstrategie sollte den spezifischen Anforderungen Ihrer Anwendung, Benutzeroberfl√§chen√ºberlegungen und Sicherheitszielen entsprechen.

### Implementierung der Authentifizierung

In diesem Abschnitt werden wir den Prozess der Hinzuf√ºgung einer grundlegenden E-Mail-Passwort-Authentifizierung zu einer Webanwendung untersuchen. W√§hrend diese Methode ein grundlegendes Sicherheitsniveau bietet, lohnt es sich, fortgeschrittenere Optionen wie OAuth oder passwortlose Logins f√ºr einen verbesserten Schutz gegen g√§ngige Sicherheitsbedrohungen in Betracht zu ziehen. Der Authentifizierungsablauf, den wir diskutieren, ist wie folgt:

<PagesOnly>

1. Der Benutzer √ºbermittelt seine Anmeldedaten √ºber ein Anmeldeformular.
2. Das Formular sendet eine Anfrage, die von einer API-Route verarbeitet wird.
3. Bei erfolgreicher √úberpr√ºfung wird der Prozess abgeschlossen, was die erfolgreiche Authentifizierung des Benutzers anzeigt.
4. Wenn die √úberpr√ºfung fehlschl√§gt, wird eine Fehlermeldung angezeigt.

Betrachten Sie ein Anmeldeformular, in dem Benutzer ihre Anmeldedaten eingeben k√∂nnen:

```tsx filename="pages/login.tsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Fehler behandeln
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <button type="submit">Anmelden</button>
    </form>
  )
}
```

```jsx filename="pages/login.jsx" switcher
import { FormEvent } from 'react'
import { useRouter } from 'next/router'

export default function LoginPage() {
  const router = useRouter()

  async function handleSubmit(event) {
    event.preventDefault()

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')

    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })

    if (response.ok) {
      router.push('/profile')
    } else {
      // Fehler behandeln
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <button type="submit">Anmelden</button>
    </form>
  )
}
```

Das obige Formular hat zwei Eingabefelder f√ºr die Erfassung der E-Mail und des Passworts des Benutzers. Bei der √úbermittlung wird eine Funktion ausgel√∂st, die eine POST-Anfrage an eine API-Route (`/api/auth/login`) sendet.

Sie k√∂nnen dann die API Ihres Authentifizierungsanbieters in der API-Route aufrufen, um die Authentifizierung zu behandeln:

```ts filename="pages/api/auth/login.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Ung√ºltige Anmeldedaten.' })
    } else {
      res.status(500).json({ error: 'Etwas ist schiefgelaufen.' })
    }
  }
}
```

```js filename="pages/api/auth/login.js" switcher
import { signIn } from '@/auth'

export default async function handler(req, res) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })

    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Ung√ºltige Anmeldedaten.' })
    } else {
      res.status(500).json({ error: 'Etwas ist schiefgelaufen.' })
    }
  }
}
```

</PagesOnly>

<AppOnly>

1. Der Benutzer √ºbermittelt seine Anmeldedaten √ºber ein Anmeldeformular.
2. Das Formular ruft eine Server-Aktion auf.
3. Bei erfolgreicher √úberpr√ºfung wird der Prozess abgeschlossen, was die erfolgreiche Authentifizierung des Benutzers anzeigt.
4. Wenn die √úberpr√ºfung fehlschl√§gt, wird eine Fehlermeldung angezeigt.

Betrachten Sie ein Anmeldeformular, in dem Benutzer ihre Anmeldedaten eingeben k√∂nnen:

```tsx filename="app/login/page.tsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <button type="submit">Anmelden</button>
    </form>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
import { authenticate } from '@/app/lib/actions'

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <button type="submit">Anmelden</button>
    </form>
  )
}
```

Das obige Formular hat zwei Eingabefelder f√ºr die Erfassung der E-Mail und des Passworts des Benutzers. Bei der √úbermittlung ruft es die Server-Aktion `authenticate` auf.

Sie k√∂nnen dann die API Ihres Authentifizierungsanbieters in der Server-Aktion aufrufen, um die Authentifizierung zu behandeln:

```ts filename="app/lib/actions.ts" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState: unknown, formData: FormData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Ung√ºltige Anmeldedaten.'
        default:
          return 'Etwas ist schiefgelaufen.'
      }
    }
    throw error
  }
}
```

```js filename="app/lib/actions.js" switcher
'use server'

import { signIn } from '@/auth'

export async function authenticate(_currentState, formData) {
  try {
    await signIn('credentials', formData)
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Ung√ºltige Anmeldedaten.'
        default:
          return 'Etwas ist schiefgelaufen.'
      }
    }
    throw error
  }
}
```

</AppOnly>

In diesem Code √ºberpr√ºft die Methode `signIn` die Anmeldedaten gegen gespeicherte Benutzerdaten.
Nachdem der Authentifizierungsanbieter die Anmeldedaten verarbeitet hat, gibt es zwei m√∂gliche Ergebnisse:

- **Erfolgreiche Authentifizierung**: Dies bedeutet, dass die Anmeldung erfolgreich war. Weitere Aktionen, wie der Zugriff auf gesch√ºtzte Routen und das Abrufen von Benutzerinformationen, k√∂nnen dann eingeleitet werden.
- **Fehlgeschlagene Authentifizierung**: Falls die Anmeldedaten falsch sind oder ein Fehler auftritt, gibt die Funktion eine entsprechende Fehlermeldung zur√ºck, um das Authentifizierungsversagen anzuzeigen.

<AppOnly>

Schlie√ülich k√∂nnen Sie in Ihrer `login-form.tsx`-Komponente Reacts `useFormState` verwenden, um die Server-Aktion aufzurufen und Formularfehler zu behandeln, und `useFormStatus` verwenden, um den ausstehenden Zustand des Formulars zu behandeln:

```tsx filename="app/login/page.tsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Anmelden
    </button>
  )
}
```

```jsx filename="app/login/page.jsx" switcher
'use client'

import { authenticate } from '@/app/lib/actions'
import { useFormState, useFormStatus } from 'react-dom'

export default function Page() {
  const [errorMessage, dispatch] = useFormState(authenticate, undefined)

  return (
    <form action={dispatch}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Passwort" required />
      <div>{errorMessage && <p>{errorMessage}</p>}</div>
      <LoginButton />
    </form>
  )
}

function LoginButton() {
  const { pending } = useFormStatus()

  const handleClick = (event) => {
    if (pending) {
      event.preventDefault()
    }
  }

  return (
    <button aria-disabled={pending} type="submit" onClick={handleClick}>
      Anmelden
    </button>
  )
}
```

</AppOnly>

F√ºr eine effizientere Authentifizierungseinrichtung in Next.js-Projekten, insbesondere bei der Bereitstellung mehrerer Anmeldemethoden, sollten Sie eine umfassende [Authentifizierungsl√∂sung](#examples) in Betracht ziehen.

## Autorisierung

Sobald ein Benutzer authentifiziert ist, m√ºssen Sie sicherstellen, dass der Benutzer bestimmte Routen besuchen darf und Operationen wie das √Ñndern von Daten mit Server-Aktionen und das Aufrufen von Route Handlern durchf√ºhren darf.

### Absicherung von Routen mit Middleware

[Middleware](/docs/app/building-your-application/routing/middleware) in Next.js hilft Ihnen zu kontrollieren, wer auf verschiedene Teile Ihrer Website zugreifen kann. Dies ist wichtig, um Bereiche wie das Benutzerdashboard gesch√ºtzt zu halten, w√§hrend andere Seiten wie Marketingseiten √∂ffentlich bleiben. Es wird empfohlen, Middleware √ºber alle Routen anzuwenden und Ausnahmen f√ºr den √∂ffentlichen Zugriff festzulegen.

Hier ist, wie Sie Middleware f√ºr die Authentifizierung in Next.js implementieren k√∂nnen:

#### Einrichtung der Middleware:

- Erstellen Sie eine `middleware.ts` oder `.js`-Datei im Stammverzeichnis Ihres Projekts.
- F√ºgen Sie Logik zur Autorisierung des Benutzerzugriffs hinzu, wie z.B. die √úberpr√ºfung von Authentifizierungstokens.

#### Definition gesch√ºtzter Routen:

- Nicht alle Routen erfordern eine Autorisierung. Verwenden Sie die Option `matcher` in Ihrer Middleware, um Routen anzugeben, die keine Autorisierungspr√ºfungen erfordern.

#### Middleware-Logik:

- Schreiben Sie Logik, um zu √ºberpr√ºfen, ob ein Benutzer authentifiziert ist. √úberpr√ºfen Sie Benutzerrollen oder Berechtigungen f√ºr die Routenautorisierung.

#### Behandlung nicht autorisierter Zugriffe:

- Leiten Sie nicht autorisierte Benutzer je nach Bedarf zu einer Anmelde- oder Fehlerseite weiter.

Beispiel-Middleware-Datei:

```ts filename="middleware.ts" switcher
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

```js filename="middleware.js" switcher
export function middleware(request) {
  const currentUser = request.cookies.get('currentUser')?.value

  if (currentUser && !request.nextUrl.pathname.startsWith('/dashboard')) {
    return Response.redirect(new URL('/dashboard', request.url))
  }

  if (!currentUser && !request.nextUrl.pathname.startsWith('/login')) {
    return Response.redirect(new URL('/login', request.url))
  }
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'],
}
```

Dieses Beispiel verwendet [`Response.redirect`](https://developer.mozilla.org/en-US/docs/Web/API/Response/redirect_static) f√ºr die Behandlung von Weiterleitungen fr√ºh in der Anfragepipeline, was effizient ist und die Zugriffskontrolle zentralisiert.

<AppOnly>

F√ºr spezifische Weiterleitungsanforderungen kann die `redirect`-Funktion in Server-Komponenten, Route Handlern und Server-Aktionen verwendet werden, um mehr Kontrolle zu bieten. Dies ist n√ºtzlich f√ºr rollenbasierte Navigation oder kontextsensitive Szenarien.

```ts filename="app/page.tsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // Logik zur Bestimmung, ob eine Weiterleitung ben√∂tigt wird
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // Definieren Sie andere Routen und Logik
}
```

```js filename="app/page.jsx" switcher
import { redirect } from 'next/navigation'

export default function Page() {
  // Logik zur Bestimmung, ob eine Weiterleitung ben√∂tigt wird
  const accessDenied = true
  if (accessDenied) {
    redirect('/login')
  }

  // Definieren Sie andere Routen und Logik
}
```

</AppOnly>

Nach erfolgreicher Authentifizierung ist es wichtig, die Benutzerf√ºhrung basierend auf ihren Rollen zu verwalten. Beispielsweise k√∂nnte ein Admin-Benutzer zu einem Admin-Dashboard weitergeleitet werden, w√§hrend ein normaler Benutzer zu einer anderen Seite geschickt wird. Dies ist wichtig f√ºr rollenspezifische Erfahrungen und bedingte Navigation, wie z.B. das Auffordern von Benutzern, ihr Profil zu vervollst√§ndigen, falls erforderlich.

Bei der Einrichtung der Autorisierung ist es wichtig sicherzustellen, dass die Hauptsicherheitspr√ºfungen dort stattfinden, wo Ihre App auf Daten zugreift oder sie √§ndert. W√§hrend Middleware f√ºr die anf√§ngliche Validierung n√ºtzlich sein kann, sollte sie nicht die einzige Verteidigungslinie zum Schutz Ihrer Daten sein. Der Gro√üteil der Sicherheitspr√ºfungen sollte in der Data Access Layer (DAL) durchgef√ºhrt werden.

<PagesOnly>

### Schutz von API-Routen

API-Routen in Next.js sind entscheidend f√ºr die Handhabung serverseitiger Logik und Datenverwaltung. Es ist wichtig, diese Routen zu sichern, um sicherzustellen, dass nur autorisierte Benutzer auf bestimmte Funktionen zugreifen k√∂nnen. Dies beinhaltet typischerweise die √úberpr√ºfung des Authentifizierungsstatus des Benutzers und seiner rollenbasierten Berechtigungen.

Hier ist ein Beispiel f√ºr die Sicherung einer API-Route:

```ts filename="pages/api/route.ts" switcher
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const session = await getSession(req)

  // √úberpr√ºfen, ob der Benutzer authentifiziert ist
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // √úberpr√ºfen, ob der Benutzer die Rolle 'admin' hat
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Fortfahren mit der Route f√ºr autorisierte Benutzer
  // ... Implementierung der API-Route
}
```

```js filename="pages/api/route.js" switcher
export default async function handler(req, res) {
  const session = await getSession(req)

  // √úberpr√ºfen, ob der Benutzer authentifiziert ist
  if (!session) {
    res.status(401).json({
      error: 'User is not authenticated',
    })
    return
  }

  // √úberpr√ºfen, ob der Benutzer die Rolle 'admin' hat
  if (session.user.role !== 'admin') {
    res.status(401).json({
      error: 'Unauthorized access: User does not have admin privileges.',
    })
    return
  }

  // Fortfahren mit der Route f√ºr autorisierte Benutzer
  // ... Implementierung der API-Route
}
```

Dieses Beispiel zeigt eine API-Route mit einer zweistufigen Sicherheitspr√ºfung f√ºr Authentifizierung und Autorisierung. Zuerst wird auf eine aktive Sitzung gepr√ºft und dann verifiziert, ob der angemeldete Benutzer ein 'admin' ist. Dieser Ansatz gew√§hrleistet sicheren Zugriff, beschr√§nkt auf authentifizierte und autorisierte Benutzer, und sorgt f√ºr robuste Sicherheit bei der Anfrageverarbeitung.

</PagesOnly>

<AppOnly>

Dieser Ansatz, der in [diesem Sicherheitsblog](/blog/security-nextjs-server-components-actions) hervorgehoben wird, bef√ºrwortet die Konsolidierung aller Datenzugriffe innerhalb einer dedizierten DAL (Data Access Layer). Diese Strategie gew√§hrleistet konsistenten Datenzugriff, minimiert Autorisierungsfehler und vereinfacht die Wartung. Um umfassende Sicherheit zu gew√§hrleisten, sollten folgende Schl√ºsselbereiche ber√ºcksichtigt werden:

- Server-Aktionen: Implementieren Sie Sicherheitspr√ºfungen in serverseitigen Prozessen, insbesondere f√ºr sensible Operationen.
- Route-Handler: Verwalten Sie eingehende Anfragen mit Sicherheitsma√ünahmen, um sicherzustellen, dass der Zugriff auf autorisierte Benutzer beschr√§nkt ist.
- Data Access Layer (DAL): Interagiert direkt mit der Datenbank und ist entscheidend f√ºr die Validierung und Autorisierung von Datentransaktionen. Es ist wichtig, kritische Pr√ºfungen innerhalb der DAL durchzuf√ºhren, um Daten an ihrem wichtigsten Interaktionspunkt ‚Äì dem Zugriff oder der √Ñnderung ‚Äì zu sichern.

Eine detaillierte Anleitung zur Sicherung der DAL, einschlie√ülich Beispiel-Codeausschnitten und fortgeschrittenen Sicherheitspraktiken, finden Sie in unserem [Data Access Layer-Abschnitt](/blog/security-nextjs-server-components-actions#data-access-layer) des Sicherheitsleitfadens.

### Schutz von Server-Aktionen

Es ist wichtig, [Server-Aktionen](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) mit den gleichen Sicherheits√ºberlegungen zu behandeln wie √∂ffentlich zug√§ngliche API-Endpunkte. Die √úberpr√ºfung der Benutzerautorisierung f√ºr jede Aktion ist entscheidend. Implementieren Sie Pr√ºfungen innerhalb von Server-Aktionen, um Benutzerberechtigungen zu bestimmen, z.B. indem Sie bestimmte Aktionen auf Admin-Benutzer beschr√§nken.

Im folgenden Beispiel √ºberpr√ºfen wir die Rolle des Benutzers, bevor die Aktion fortgesetzt wird:

```ts filename="app/lib/actions.ts" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // √úberpr√ºfen, ob der Benutzer zur Ausf√ºhrung der Aktion berechtigt ist
  if (userRole !== 'admin') {
    throw new Error('Unauthorized access: User does not have admin privileges.')
  }

  // Fortfahren mit der Aktion f√ºr autorisierte Benutzer
  // ... Implementierung der Aktion
}
```

```js filename="app/lib/actions.js" switcher
'use server'

// ...

export async function serverAction() {
  const session = await getSession()
  const userRole = session?.user?.role

  // √úberpr√ºfen, ob der Benutzer zur Ausf√ºhrung der Aktion berechtigt ist
  if (userRole !== 'admin') {
    throw new Error('Unauthorized access: User does not have admin privileges.')
  }

  // Fortfahren mit der Aktion f√ºr autorisierte Benutzer
  // ... Implementierung der Aktion
}
```

### Schutz von Route-Handlern

Route-Handler in Next.js spielen eine wichtige Rolle bei der Verwaltung eingehender Anfragen. Genau wie Server-Aktionen sollten sie gesichert werden, um sicherzustellen, dass nur autorisierte Benutzer auf bestimmte Funktionen zugreifen k√∂nnen. Dies beinhaltet oft die √úberpr√ºfung des Authentifizierungsstatus des Benutzers und seiner Berechtigungen.

Hier ist ein Beispiel f√ºr die Sicherung eines Route-Handlers:

```ts filename="app/api/route.ts" switcher
export async function GET() {
  // Benutzerauthentifizierung und Rollen√ºberpr√ºfung
  const session = await getSession()

  // √úberpr√ºfen, ob der Benutzer authentifiziert ist
  if (!session) {
    return new Response(null, { status: 401 }) // Benutzer ist nicht authentifiziert
  }

  // √úberpr√ºfen, ob der Benutzer die Rolle 'admin' hat
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // Benutzer ist authentifiziert, hat aber nicht die erforderlichen Berechtigungen
  }

  // Datenabruf f√ºr autorisierte Benutzer
}
```

```js filename="app/api/route.js" switcher
export async function GET() {
  // Benutzerauthentifizierung und Rollen√ºberpr√ºfung
  const session = await getSession()

  // √úberpr√ºfen, ob der Benutzer authentifiziert ist
  if (!session) {
    return new Response(null, { status: 401 }) // Benutzer ist nicht authentifiziert
  }

  // √úberpr√ºfen, ob der Benutzer die Rolle 'admin' hat
  if (session.user.role !== 'admin') {
    return new Response(null, { status: 403 }) // Benutzer ist authentifiziert, hat aber nicht die erforderlichen Berechtigungen
  }

  // Datenabruf f√ºr autorisierte Benutzer
}
```

Dieses Beispiel zeigt einen Route-Handler mit einer zweistufigen Sicherheitspr√ºfung f√ºr Authentifizierung und Autorisierung. Zuerst wird auf eine aktive Sitzung gepr√ºft und dann verifiziert, ob der angemeldete Benutzer ein 'admin' ist. Dieser Ansatz gew√§hrleistet sicheren Zugriff, beschr√§nkt auf authentifizierte und autorisierte Benutzer, und sorgt f√ºr robuste Sicherheit bei der Anfrageverarbeitung.

### Autorisierung mit Server-Komponenten

[Server-Komponenten](/docs/app/building-your-application/rendering/server-components) in Next.js sind f√ºr die serverseitige Ausf√ºhrung konzipiert und bieten eine sichere Umgebung f√ºr die Integration komplexer Logik wie Autorisierung. Sie erm√∂glichen den direkten Zugriff auf Backend-Ressourcen, optimieren die Leistung f√ºr datenintensive Aufgaben und verbessern die Sicherheit f√ºr sensible Operationen.

In Server-Komponenten ist es √ºblich, UI-Elemente bedingt basierend auf der Rolle des Benutzers zu rendern. Dieser Ansatz verbessert sowohl die Benutzererfahrung als auch die Sicherheit, indem sichergestellt wird, dass Benutzer nur auf Inhalte zugreifen, f√ºr die sie autorisiert sind.

**Beispiel:**

```tsx filename="app/dashboard/page.tsx" switcher
export default async function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Angenommen, 'role' ist Teil des Sitzungsobjekts

  if (userRole === 'admin') {
    return <AdminDashboard /> // Komponente f√ºr Admin-Benutzer
  } else if (userRole === 'user') {
    return <UserDashboard /> // Komponente f√ºr regul√§re Benutzer
  } else {
    return <AccessDenied /> // Komponente f√ºr nicht autorisierten Zugriff
  }
}
```

```jsx filename="app/dashboard/page.jsx" switcher
export default function Dashboard() {
  const session = await getSession()
  const userRole = session?.user?.role // Angenommen, 'role' ist Teil des Sitzungsobjekts

  if (userRole === 'admin') {
    return <AdminDashboard /> // Komponente f√ºr Admin-Benutzer
  } else if (userRole === 'user') {
    return <UserDashboard /> // Komponente f√ºr regul√§re Benutzer
  } else {
    return <AccessDenied /> // Komponente f√ºr nicht autorisierten Zugriff
  }
}
```

In diesem Beispiel rendert die Dashboard-Komponente unterschiedliche UIs f√ºr 'admin', 'user' und nicht autorisierte Rollen. Dieses Muster stellt sicher, dass jeder Benutzer nur mit Komponenten interagiert, die seiner Rolle entsprechen, was sowohl die Sicherheit als auch die Benutzererfahrung verbessert.

</AppOnly>

### Best Practices

- **Sichere Sitzungsverwaltung**: Priorisieren Sie die Sicherheit von Sitzungsdaten, um unbefugten Zugriff und Datenlecks zu verhindern. Verwenden Sie Verschl√ºsselung und sichere Speicherpraktiken.
- **Dynamische Rollenverwaltung**: Verwenden Sie ein flexibles System f√ºr Benutzerrollen, um √Ñnderungen in Berechtigungen und Rollen leicht anpassen zu k√∂nnen, und vermeiden Sie hartkodierte Rollen.
- **Sicherheitsorientierter Ansatz**: Priorisieren Sie in allen Aspekten der Autorisierungslogik die Sicherheit, um Benutzerdaten zu sch√ºtzen und die Integrit√§t Ihrer Anwendung zu erhalten. Dies beinhaltet gr√ºndliches Testen und die Ber√ºcksichtigung potenzieller Sicherheitsl√ºcken.

## Sitzungsverwaltung

Die Sitzungsverwaltung umfasst die Nachverfolgung und Verwaltung der Interaktion eines Benutzers mit der Anwendung √ºber die Zeit, wodurch sichergestellt wird, dass sein authentifizierter Zustand √ºber verschiedene Teile der Anwendung hinweg erhalten bleibt.

Dies vermeidet die Notwendigkeit wiederholter Anmeldungen und verbessert sowohl die Sicherheit als auch die Benutzerfreundlichkeit. Es gibt zwei prim√§re Methoden f√ºr die Sitzungsverwaltung: cookie-basierte Sitzungen und Datenbank-Sitzungen.

### Cookie-basierte Sitzungen

> **üé• Ansehen:** Erfahren Sie mehr √ºber cookie-basierte Sitzungen und Authentifizierung mit Next.js ‚Üí [YouTube (11 Minuten)](https://www.youtube.com/watch?v=DJvM2lSPn6w).

Cookie-basierte Sitzungen verwalten Benutzerdaten, indem sie verschl√ºsselte Sitzungsinformationen direkt in Browser-Cookies speichern. Bei der Benutzeranmeldung werden diese verschl√ºsselten Daten im Cookie gespeichert. Jede nachfolgende Serveranfrage enth√§lt dieses Cookie, was die Notwendigkeit wiederholter Serverabfragen minimiert und die Client-seitige Effizienz verbessert.

Diese Methode erfordert jedoch eine sorgf√§ltige Verschl√ºsselung, um sensible Daten zu sch√ºtzen, da Cookies anf√§llig f√ºr Client-seitige Sicherheitsrisiken sind. Die Verschl√ºsselung von Sitzungsdaten in Cookies ist entscheidend, um Benutzerinformationen vor unbefugtem Zugriff zu sch√ºtzen. Sie stellt sicher, dass die Daten im Cookie selbst bei Diebstahl unlesbar bleiben.

Dar√ºber hinaus sind einzelne Cookies zwar in der Gr√∂√üe begrenzt (typischerweise etwa 4KB), aber Techniken wie Cookie-Chunking k√∂nnen diese Einschr√§nkung √ºberwinden, indem gro√üe Sitzungsdaten in mehrere Cookies aufgeteilt werden.

Das Setzen eines Cookies in einem Next.js-Projekt k√∂nnte etwa so aussehen:

**Setzen eines Cookies auf dem Server:**

<PagesOnly>

```ts filename="pages/api/login.ts" switcher
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Eine Woche
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

```js filename="pages/api/login.js" switcher
import { serialize } from 'cookie'

export default function handler(req, res) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)

  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Eine Woche
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

</PagesOnly>

<AppOnly>

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Verschl√ºsseln Sie Ihre Sitzungsdaten
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Eine Woche
    path: '/',
  })
  // Weiterleitung oder Behandlung der Antwort nach dem Setzen des Cookies
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function handleLogin(sessionData) {
  const encryptedSessionData = encrypt(sessionData) // Verschl√ºsseln Sie Ihre Sitzungsdaten
  cookies().set('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // Eine Woche
    path: '/',
  })
  // Weiterleitung oder Behandlung der Antwort nach dem Setzen des Cookies
}
```

**Zugriff auf die im Cookie gespeicherten Sitzungsdaten in einer Server-Komponente:**

```tsx filename="app/page.tsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

```jsx filename="app/page.jsx" switcher
import { cookies } from 'next/headers'

export async function getSessionData(req) {
  const encryptedSessionData = cookies().get('session')?.value
  return encryptedSessionData ? JSON.parse(decrypt(encryptedSessionData)) : null
}
```

</AppOnly>

### Datenbank-Sitzungen

Die Datenbank-Sitzungsverwaltung beinhaltet die Speicherung von Sitzungsdaten auf dem Server, wobei der Browser des Benutzers nur eine Sitzungs-ID erh√§lt. Diese ID verweist auf die serverseitig gespeicherten Sitzungsdaten, ohne die Daten selbst zu enthalten. Diese Methode verbessert die Sicherheit, da sie sensible Sitzungsdaten von der Client-seitigen Umgebung fernh√§lt und das Risiko von Client-seitigen Angriffen reduziert. Datenbank-Sitzungen sind auch skalierbarer und k√∂nnen gr√∂√üere Datenspeicheranforderungen bew√§ltigen.

Dieser Ansatz hat jedoch auch seine Nachteile. Er kann die Leistung beeintr√§chtigen, da bei jeder Benutzerinteraktion Datenbankabfragen erforderlich sind. Strategien wie das Caching von Sitzungsdaten k√∂nnen dies mildern. Dar√ºber hinaus bedeutet die Abh√§ngigkeit von der Datenbank, dass die Sitzungsverwaltung so zuverl√§ssig ist wie die Leistung und Verf√ºgbarkeit der Datenbank.

Hier ist ein vereinfachtes Beispiel f√ºr die Implementierung von Datenbank-Sitzungen in einer Next.js-Anwendung:

**Erstellen einer Sitzung auf dem Server**:

<PagesOnly>

```ts filename="pages/api/create-session.ts" switcher
import db from '../../lib/db'
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

```js filename="pages/api/create-session.js" switcher
import db from '../../lib/db'

export default async function handler(req, res) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })

    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

</PagesOnly>

<AppOnly>

```js
import db from './lib/db'

export async function createSession(user) {
  const sessionId = generateSessionId() // Generieren Sie eine eindeutige Sitzungs-ID
  await db.insertSession({ sessionId, userId: user.id, createdAt: new Date() })
  return sessionId
}
```

**Abrufen einer Sitzung in Middleware oder serverseitiger Logik**:

```js
import { cookies } from 'next/headers'
import db from './lib/db'

export async function getSession() {
  const sessionId = cookies().get('sessionId')?.value
  return sessionId ? await db.findSession(sessionId) : null
}
```

</AppOnly>

### Auswahl der Session-Verwaltung in Next.js

Die Entscheidung zwischen Cookie-basierten und Datenbank-Sessions in Next.js h√§ngt von den Anforderungen Ihrer Anwendung ab. Cookie-basierte Sessions sind einfacher und eignen sich f√ºr kleinere Anwendungen mit geringerer Serverlast, bieten jedoch m√∂glicherweise weniger Sicherheit. Datenbank-Sessions sind zwar komplexer, bieten aber bessere Sicherheit und Skalierbarkeit, was sie ideal f√ºr gr√∂√üere, datensensible Anwendungen macht.

Mit [Authentifizierungsl√∂sungen](#beispiele) wie [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5) wird die Session-Verwaltung effizienter, indem entweder Cookies oder Datenbankspeicher verwendet werden. Diese Automatisierung vereinfacht den Entwicklungsprozess, aber es ist wichtig, die von Ihrer gew√§hlten L√∂sung verwendete Session-Verwaltungsmethode zu verstehen. Stellen Sie sicher, dass sie mit den Sicherheits- und Leistungsanforderungen Ihrer Anwendung √ºbereinstimmt.

Unabh√§ngig von Ihrer Wahl sollten Sie Sicherheit in Ihrer Session-Verwaltungsstrategie priorisieren. Bei Cookie-basierten Sessions ist die Verwendung sicherer und HTTP-only Cookies entscheidend, um Session-Daten zu sch√ºtzen. Bei Datenbank-Sessions sind regelm√§√üige Backups und die sichere Handhabung von Session-Daten unerl√§sslich. Die Implementierung von Session-Ablauf- und Bereinigungsmechanismen ist bei beiden Ans√§tzen wichtig, um unbefugten Zugriff zu verhindern und die Anwendungsleistung sowie Zuverl√§ssigkeit zu gew√§hrleisten.

## Beispiele

Hier sind Authentifizierungsl√∂sungen, die mit Next.js kompatibel sind. Bitte lesen Sie die folgenden Quickstart-Anleitungen, um zu erfahren, wie Sie sie in Ihrer Next.js-Anwendung konfigurieren:

{/* TODO: Link zu authjs.dev √§ndern, wenn die neue Dokumentation verf√ºgbar ist */}

- [Auth0](https://auth0.com/docs/quickstart/webapp/nextjs/01-login)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk)
- [Lucia](https://lucia-auth.com/getting-started/nextjs-app)
- [NextAuth.js](https://authjs.dev/guides/upgrade-to-v5)
- [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs)
- [Stytch](https://stytch.com/docs/guides/quickstarts/nextjs)
- [Iron Session](https://github.com/vvo/iron-session)

## Weiterf√ºhrende Literatur

Um mehr √ºber Authentifizierung und Sicherheit zu lernen, lesen Sie die folgenden Ressourcen:

- [Verst√§ndnis von XSS-Angriffen](https://vercel.com/guides/understanding-xss-attacks)
- [Verst√§ndnis von CSRF-Angriffen](https://vercel.com/guides/understanding-csrf-attacks)
