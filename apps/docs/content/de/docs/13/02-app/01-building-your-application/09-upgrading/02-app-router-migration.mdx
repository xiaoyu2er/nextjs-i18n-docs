---
source-updated-at: 2025-05-16T04:52:11.000Z
translation-updated-at: 2025-06-06T18:06:33.432Z
title: Leitfaden f√ºr inkrementelle Migration zum App Router
nav_title: Migration zum App Router
description: Erfahren Sie, wie Sie Ihre bestehende Next.js-Anwendung vom Pages Router zum App Router migrieren.
---

Dieser Leitfaden hilft Ihnen bei folgenden Schritten:

- [Aktualisierung Ihrer Next.js-Anwendung von Version 12 auf Version 13](#nextjs-version)
- [Upgrade von Features, die sowohl im `pages`- als auch im `app`-Verzeichnis funktionieren](#upgrading-new-features)
- [Inkrementelle Migration Ihrer bestehenden Anwendung von `pages` zu `app`](#migrating-from-pages-to-app)

## Aktualisierung

### Node.js-Version

Die Mindestversion von Node.js ist nun **v16.14**. Weitere Informationen finden Sie in der [Node.js-Dokumentation](https://nodejs.org/docs/latest-v16.x/api/).

### Next.js-Version

Um auf Next.js Version 13 zu aktualisieren, f√ºhren Sie folgenden Befehl mit Ihrem bevorzugten Paketmanager aus:

```bash filename="Terminal"
npm install next@latest react@latest react-dom@latest
```

### ESLint-Version

Falls Sie ESLint verwenden, m√ºssen Sie Ihre ESLint-Version aktualisieren:

```bash filename="Terminal"
npm install -D eslint-config-next@latest
```

> **Gut zu wissen**: M√∂glicherweise m√ºssen Sie den ESLint-Server in VS Code neu starten, damit die √Ñnderungen wirksam werden. √ñffnen Sie die Befehlspalette (`cmd+shift+p` auf Mac; `ctrl+shift+p` auf Windows) und suchen Sie nach `ESLint: Restart ESLint Server`.

## N√§chste Schritte

Nach der Aktualisierung finden Sie in den folgenden Abschnitten weitere Anleitungen:

- [Upgrade neuer Features](#upgrading-new-features): Eine Anleitung zur Aktualisierung auf neue Features wie die verbesserten Image- und Link-Komponenten.
- [Migration vom `pages`- zum `app`-Verzeichnis](#migrating-from-pages-to-app): Eine Schritt-f√ºr-Schritt-Anleitung zur inkrementellen Migration vom `pages`- zum `app`-Verzeichnis.

## Upgrade neuer Features

Next.js 13 f√ºhrte den neuen [App Router](/docs/app/building-your-application/routing) mit neuen Features und Konventionen ein. Der neue Router ist im `app`-Verzeichnis verf√ºgbar und koexistiert mit dem `pages`-Verzeichnis.

Ein Upgrade auf Next.js 13 erfordert **nicht** die Verwendung des neuen [App Routers](/docs/app/building-your-application/routing#the-app-router). Sie k√∂nnen weiterhin `pages` mit neuen Features verwenden, die in beiden Verzeichnissen funktionieren, wie die aktualisierte [Image-Komponente](#image-component), [Link-Komponente](#link-component), [Script-Komponente](#script-component) und [Font-Optimierung](#font-optimization).

### `<Image/>`-Komponente

Next.js 12 f√ºhrte Verbesserungen an der Image-Komponente mit einem tempor√§ren Import ein: `next/future/image`. Diese Verbesserungen umfassten weniger clientseitigen JavaScript-Code, einfachere M√∂glichkeiten zur Erweiterung und Gestaltung von Bildern, bessere Barrierefreiheit und natives Browser-Lazy-Loading.

In Version 13 ist dieses neue Verhalten nun der Standard f√ºr `next/image`.

Es gibt zwei Codemods, die Ihnen bei der Migration zur neuen Image-Komponente helfen:

- [**`next-image-to-legacy-image` Codemod**](/docs/app/building-your-application/upgrading/codemods#next-image-to-legacy-image): Benennt `next/image`-Importe sicher und automatisch in `next/legacy/image` um. Bestehende Komponenten behalten dasselbe Verhalten bei.
- [**`next-image-experimental` Codemod**](/docs/app/building-your-application/upgrading/codemods#next-image-experimental): F√ºgt gef√§hrlicherweise Inline-Styles hinzu und entfernt ungenutzte Props. Dies √§ndert das Verhalten bestehender Komponenten, um den neuen Standard zu entsprechen. Um diesen Codemod zu verwenden, m√ºssen Sie zuerst den `next-image-to-legacy-image`-Codemod ausf√ºhren.

### `<Link>`-Komponente

Die [`<Link>`-Komponente](/docs/app/building-your-application/routing/linking-and-navigating#link-component) erfordert nicht mehr das manuelle Hinzuf√ºgen eines `<a>`-Tags als Child. Dieses Verhalten wurde als experimentelle Option in [Version 12.2](https://nextjs.org/blog/next-12-2) hinzugef√ºgt und ist nun der Standard. In Next.js 13 rendert `<Link>` immer ein `<a>` und erlaubt es Ihnen, Props an das zugrunde liegende Tag weiterzuleiten.

Beispiel:

```jsx
import Link from 'next/link'

// Next.js 12: `<a>` muss verschachtelt sein, sonst wird es ausgeschlossen
<Link href="/about">
  <a>About</a>
</Link>

// Next.js 13: `<Link>` rendert immer ein `<a>` im Hintergrund
<Link href="/about">
  About
</Link>
```

Um Ihre Links auf Next.js 13 zu aktualisieren, k√∂nnen Sie den [`new-link`-Codemod](/docs/app/building-your-application/upgrading/codemods#new-link) verwenden.

### `<Script>`-Komponente

Das Verhalten von [`next/script`](/docs/app/api-reference/components/script) wurde aktualisiert, um sowohl `pages` als auch `app` zu unterst√ºtzen, aber einige √Ñnderungen sind notwendig, um eine reibungslose Migration zu gew√§hrleisten:

- Verschieben Sie alle `beforeInteractive`-Scripts, die Sie zuvor in `_document.js` eingebunden haben, in die Root-Layout-Datei (`app/layout.tsx`).
- Die experimentelle `worker`-Strategie funktioniert noch nicht in `app`, und Scripts mit dieser Strategie m√ºssen entweder entfernt oder so ge√§ndert werden, dass sie eine andere Strategie verwenden (z.B. `lazyOnload`).
- `onLoad`, `onReady` und `onError`-Handler funktionieren nicht in Server Components, daher m√ºssen Sie sie in eine [Client Component](/docs/app/building-your-application/rendering/server-components) verschieben oder ganz entfernen.

### Font-Optimierung

Bisher half Next.js bei der Optimierung von Fonts durch [Inline-Einbindung von Font-CSS](/docs/app/building-your-application/optimizing/fonts). Version 13 f√ºhrt das neue [`next/font`](/docs/app/building-your-application/optimizing/fonts)-Modul ein, das Ihnen die M√∂glichkeit gibt, Ihre Font-Loading-Erfahrung anzupassen, w√§hrend gleichzeitig eine hervorragende Leistung und Privatsph√§re gew√§hrleistet wird. `next/font` wird sowohl im `pages`- als auch im `app`-Verzeichnis unterst√ºtzt.

W√§hrend [Inline-CSS](/docs/app/building-your-application/optimizing/fonts) in `pages` weiterhin funktioniert, funktioniert es nicht in `app`. Sie sollten stattdessen [`next/font`](/docs/app/building-your-application/optimizing/fonts) verwenden.

Weitere Informationen zur Verwendung von `next/font` finden Sie auf der Seite [Font-Optimierung](/docs/app/building-your-application/optimizing/fonts).

## Migration von `pages` zu `app`

> **üé• Video ansehen:** Erfahren Sie, wie Sie den App Router inkrementell einf√ºhren ‚Üí [YouTube (16 Minuten)](https://www.youtube.com/watch?v=YQMSietiFm0).

Der Wechsel zum App Router k√∂nnte das erste Mal sein, dass Sie React-Features verwenden, auf denen Next.js aufbaut, wie Server Components, Suspense und mehr. In Kombination mit neuen Next.js-Features wie [Spezialdateien](/docs/app/building-your-application/routing#file-conventions) und [Layouts](/docs/app/building-your-application/routing/pages-and-layouts#layouts) bedeutet die Migration neue Konzepte, mentale Modelle und Verhaltens√§nderungen, die es zu lernen gilt.

Wir empfehlen, die Komplexit√§t dieser Updates zu reduzieren, indem Sie Ihre Migration in kleinere Schritte unterteilen. Das `app`-Verzeichnis ist absichtlich so gestaltet, dass es gleichzeitig mit dem `pages`-Verzeichnis funktioniert, um eine schrittweise Migration Seite f√ºr Seite zu erm√∂glichen.

- Das `app`-Verzeichnis unterst√ºtzt verschachtelte Routen _und_ Layouts. [Mehr erfahren](/docs/app/building-your-application/routing).
- Verwenden Sie verschachtelte Ordner, um [Routen zu definieren](/docs/app/building-your-application/routing/defining-routes), und eine spezielle `page.js`-Datei, um ein Routensegment √∂ffentlich zug√§nglich zu machen. [Mehr erfahren](#step-4-migrating-pages).
- [Spezielle Dateikonventionen](/docs/app/building-your-application/routing#file-conventions) werden verwendet, um die Benutzeroberfl√§che f√ºr jedes Routensegment zu erstellen. Die h√§ufigsten Spezialdateien sind `page.js` und `layout.js`.
  - Verwenden Sie `page.js`, um eine Benutzeroberfl√§che zu definieren, die f√ºr eine Route einzigartig ist.
  - Verwenden Sie `layout.js`, um eine Benutzeroberfl√§che zu definieren, die √ºber mehrere Routen hinweg geteilt wird.
  - Die Dateierweiterungen `.js`, `.jsx` oder `.tsx` k√∂nnen f√ºr Spezialdateien verwendet werden.
- Sie k√∂nnen andere Dateien wie Komponenten, Styles, Tests und mehr im `app`-Verzeichnis zusammen ablegen. [Mehr erfahren](/docs/app/building-your-application/routing).
- Datenabruffunktionen wie `getServerSideProps` und `getStaticProps` wurden durch [eine neue API](/docs/app/building-your-application/data-fetching) in `app` ersetzt. `getStaticPaths` wurde durch [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) ersetzt.
- `pages/_app.js` und `pages/_document.js` wurden durch ein einzelnes `app/layout.js`-Root-Layout ersetzt. [Mehr erfahren](/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required).
- `pages/_error.js` wurde durch granularere `error.js`-Spezialdateien ersetzt. [Mehr erfahren](/docs/app/building-your-application/routing/error-handling).
- `pages/404.js` wurde durch die [`not-found.js`](/docs/app/api-reference/file-conventions/not-found)-Datei ersetzt.
- `pages/api/*` verbleiben derzeit im `pages`-Verzeichnis.

### Schritt 1: Erstellen des `app`-Verzeichnisses

Aktualisieren Sie auf die neueste Next.js-Version (erfordert 13.4 oder h√∂her):

```bash
npm install next@latest
```

Erstellen Sie dann ein neues `app`-Verzeichnis im Stammverzeichnis Ihres Projekts (oder im `src/`-Verzeichnis).

### Schritt 2: Erstellen eines Root-Layouts

Erstellen Sie eine neue `app/layout.tsx`-Datei im `app`-Verzeichnis. Dies ist ein [Root-Layout](/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), das f√ºr alle Routen innerhalb von `app` gilt.

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  // Layouts m√ºssen eine children-Prop akzeptieren.
  // Diese wird mit verschachtelten Layouts oder Seiten gef√ºllt
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({
  // Layouts m√ºssen eine children-Prop akzeptieren.
  // Diese wird mit verschachtelten Layouts oder Seiten gef√ºllt
  children,
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

- Das `app`-Verzeichnis **muss** ein Root-Layout enthalten.
- Das Root-Layout muss `<html>`- und `<body>`-Tags definieren, da Next.js diese nicht automatisch erstellt.
- Das Root-Layout ersetzt die Dateien `pages/_app.tsx` und `pages/_document.tsx`.
- Die Dateierweiterungen `.js`, `.jsx` oder `.tsx` k√∂nnen f√ºr Layout-Dateien verwendet werden.

Um `<head>`-HTML-Elemente zu verwalten, k√∂nnen Sie die [integrierte SEO-Unterst√ºtzung](/docs/app/building-your-application/optimizing/metadata) verwenden:

```tsx filename="app/layout.tsx" switcher
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```

```jsx filename="app/layout.js" switcher
export const metadata = {
  title: 'Home',
  description: 'Welcome to Next.js',
}
```

#### Migration von `_document.js` und `_app.js`

Falls Sie eine bestehende `_app`- oder `_document`-Datei haben, k√∂nnen Sie deren Inhalte (z.B. globale Styles) in das Root-Layout (`app/layout.tsx`) kopieren. Styles in `app/layout.tsx` gelten _nicht_ f√ºr `pages/*`. Sie sollten `_app`/`_document` w√§hrend der Migration behalten, um sicherzustellen, dass Ihre `pages/*`-Routen nicht brechen. Sobald die Migration abgeschlossen ist, k√∂nnen Sie sie sicher l√∂schen.

Falls Sie React Context-Provider verwenden, m√ºssen diese in eine [Client Component](/docs/app/building-your-application/rendering/client-components) verschoben werden.

#### Migration des `getLayout()`-Patterns zu Layouts (Optional)

Next.js empfahl, eine [Eigenschaft zu Page-Komponenten](/docs/pages/building-your-application/routing/pages-and-layouts#layout-pattern#per-page-layouts) hinzuzuf√ºgen, um pro-Seite-Layouts im `pages`-Verzeichnis zu erreichen. Dieses Pattern kann durch die native Unterst√ºtzung f√ºr [verschachtelte Layouts](/docs/app/building-your-application/routing/pages-and-layouts#layouts) im `app`-Verzeichnis ersetzt werden.

<details>
  <summary>Vorher-Nachher-Beispiel anzeigen</summary>

**Vorher**

```jsx filename="components/DashboardLayout.js"
export default function DashboardLayout({ children }) {
  return (
    <div>
      <h2>My Dashboard</h2>
      {children}
    </div>
  )
}
```

```jsx filename="pages/dashboard/index.js"
import DashboardLayout from '../components/DashboardLayout'

export default function Page() {
  return <p>My Page</p>
}

Page.getLayout = function getLayout(page) {
  return <DashboardLayout>{page}</DashboardLayout>
}
```

**Nachher**

- Entfernen Sie die `Page.getLayout`-Eigenschaft aus `pages/dashboard/index.js` und folgen Sie den [Schritten zur Migration von Seiten](#step-4-migrating-pages) in das `app`-Verzeichnis.

  ```jsx filename="app/dashboard/page.js"
  export default function Page() {
    return <p>My Page</p>
  }
  ```

- Verschieben Sie den Inhalt von `DashboardLayout` in eine neue [Client Component](/docs/app/building-your-application/rendering/client-components), um das Verhalten des `pages`-Verzeichnisses beizubehalten.

  ```jsx filename="app/dashboard/DashboardLayout.js"
  'use client' // Diese Direktive sollte am Anfang der Datei stehen, vor allen Imports.

  // Dies ist eine Client Component
  export default function DashboardLayout({ children }) {
    return (
      <div>
        <h2>My Dashboard</h2>
        {children}
      </div>
    )
  }
  ```

- Importieren Sie `DashboardLayout` in eine neue `layout.js`-Datei im `app`-Verzeichnis.

  ```jsx filename="app/dashboard/layout.js"
  import DashboardLayout from './DashboardLayout'

  // Dies ist eine Server Component
  export default function Layout({ children }) {
    return <DashboardLayout>{children}</DashboardLayout>
  }
  ```

- Sie k√∂nnen nicht-interaktive Teile von `DashboardLayout.js` (Client Component) schrittweise in `layout.js` (Server Component) verschieben, um die Menge an JavaScript-Code zu reduzieren, die an den Client gesendet wird.

</details>

### Schritt 3: Migration von `next/head`

Im `pages`-Verzeichnis wurde die `next/head`-React-Komponente verwendet, um `<head>`-HTML-Elemente wie `title` und `meta` zu verwalten. Im `app`-Verzeichnis wird `next/head` durch die neue [integrierte SEO-Unterst√ºtzung](/docs/app/building-your-application/optimizing/metadata) ersetzt.

**Vorher:**

```tsx filename="pages/index.tsx" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```

```jsx filename="pages/index.js" switcher
import Head from 'next/head'

export default function Page() {
  return (
    <>
      <Head>
        <title>My page title</title>
      </Head>
    </>
  )
}
```

**Nachher:**

```tsx filename="app/page.tsx" switcher
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```

```jsx filename="app/page.js" switcher
export const metadata = {
  title: 'My Page Title',
}

export default function Page() {
  return '...'
}
```

[Alle Metadaten-Optionen anzeigen](/docs/app/api-reference/functions/generate-metadata).

### Schritt 4: Migration von Seiten

- Seiten im [`app`-Verzeichnis](/docs/app/building-your-application/routing) sind standardm√§√üig [Server Components (Server-Komponenten)](/docs/app/building-your-application/rendering/server-components). Dies unterscheidet sich vom `pages`-Verzeichnis, wo Seiten [Client Components (Client-Komponenten)](/docs/app/building-your-application/rendering/client-components) sind.
- [Data Fetching (Datenabruf)](/docs/app/building-your-application/data-fetching) hat sich in `app` ge√§ndert. `getServerSideProps`, `getStaticProps` und `getInitialProps` wurden durch eine einfachere API ersetzt.
- Das `app`-Verzeichnis verwendet verschachtelte Ordner, um [Routen zu definieren](/docs/app/building-your-application/routing/defining-routes), und eine spezielle `page.js`-Datei, um ein Routensegment √∂ffentlich zug√§nglich zu machen.
- | `pages`-Verzeichnis | `app`-Verzeichnis      | Route          |
  | ------------------- | ---------------------- | -------------- |
  | `index.js`          | `page.js`              | `/`            |
  | `about.js`          | `about/page.js`        | `/about`       |
  | `blog/[slug].js`    | `blog/[slug]/page.js`  | `/blog/post-1` |

Wir empfehlen, die Migration einer Seite in zwei Hauptschritte aufzuteilen:

- Schritt 1: Die standardm√§√üig exportierte Page-Komponente in eine neue Client-Komponente verschieben.
- Schritt 2: Die neue Client-Komponente in eine neue `page.js`-Datei im `app`-Verzeichnis importieren.

> **Gut zu wissen**: Dies ist der einfachste Migrationspfad, da er das vergleichbarste Verhalten zum `pages`-Verzeichnis aufweist.

**Schritt 1: Erstellen einer neuen Client-Komponente**

- Erstellen Sie eine neue separate Datei im `app`-Verzeichnis (z.B. `app/home-page.tsx` oder √§hnlich), die eine Client-Komponente exportiert. Um Client-Komponenten zu definieren, f√ºgen Sie die `'use client'`-Direktive am Anfang der Datei ein (vor allen Imports).
- Verschieben Sie die standardm√§√üig exportierte Page-Komponente von `pages/index.js` nach `app/home-page.tsx`.

```tsx filename="app/home-page.tsx" switcher
'use client'

// Dies ist eine Client-Komponente. Sie empf√§ngt Daten als Props und
// hat Zugriff auf State und Effekte, genau wie Page-Komponenten
// im `pages`-Verzeichnis.
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

```jsx filename="app/home-page.js" switcher
'use client'

// Dies ist eine Client-Komponente. Sie empf√§ngt Daten als Props und
// hat Zugriff auf State und Effekte, genau wie Page-Komponenten
// im `pages`-Verzeichnis.
export default function HomePage({ recentPosts }) {
  return (
    <div>
      {recentPosts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

**Schritt 2: Erstellen einer neuen Seite**

- Erstellen Sie eine neue `app/page.tsx`-Datei im `app`-Verzeichnis. Dies ist standardm√§√üig eine Server-Komponente.
- Importieren Sie die `home-page.tsx`-Client-Komponente in die Seite.
- Falls Sie Daten in `pages/index.js` abgerufen haben, verschieben Sie die Datenabruflogik direkt in die Server-Komponente unter Verwendung der neuen [Data Fetching APIs (Datenabruf-APIs)](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating). Weitere Details finden Sie im [Leitfaden zur Datenabruf-Migration](#step-6-migrating-data-fetching-methods).

  ```tsx filename="app/page.tsx" switcher
  // Importieren Sie Ihre Client-Komponente
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // Daten direkt in einer Server-Komponente abrufen
    const recentPosts = await getPosts()
    // Abgerufene Daten an Ihre Client-Komponente weiterleiten
    return <HomePage recentPosts={recentPosts} />
  }
  ```

  ```jsx filename="app/page.js" switcher
  // Importieren Sie Ihre Client-Komponente
  import HomePage from './home-page'

  async function getPosts() {
    const res = await fetch('https://...')
    const posts = await res.json()
    return posts
  }

  export default async function Page() {
    // Daten direkt in einer Server-Komponente abrufen
    const recentPosts = await getPosts()
    // Abgerufene Daten an Ihre Client-Komponente weiterleiten
    return <HomePage recentPosts={recentPosts} />
  }
  ```

- Falls Ihre vorherige Seite `useRouter` verwendet hat, m√ºssen Sie auf die neuen Routing-Hooks umstellen. [Mehr erfahren](/docs/app/api-reference/functions/use-router).
- Starten Sie Ihren Entwicklungsserver und rufen Sie [`http://localhost:3000`](http://localhost:3000) auf. Sie sollten Ihre bestehende Index-Route sehen, die nun √ºber das `app`-Verzeichnis bereitgestellt wird.

### Schritt 5: Migration von Routing-Hooks

Ein neuer Router wurde hinzugef√ºgt, um das neue Verhalten im `app`-Verzeichnis zu unterst√ºtzen.

In `app` sollten Sie die drei neuen Hooks verwenden, die aus `next/navigation` importiert werden: [`useRouter()`](/docs/app/api-reference/functions/use-router), [`usePathname()`](/docs/app/api-reference/functions/use-pathname) und [`useSearchParams()`](/docs/app/api-reference/functions/use-search-params).

- Der neue `useRouter`-Hook wird aus `next/navigation` importiert und unterscheidet sich im Verhalten vom `useRouter`-Hook in `pages`, der aus `next/router` importiert wird.
  - Der [`useRouter`-Hook aus `next/router`](/docs/pages/api-reference/functions/use-router) wird im `app`-Verzeichnis nicht unterst√ºtzt, kann aber weiterhin im `pages`-Verzeichnis verwendet werden.
- Der neue `useRouter` gibt nicht den `pathname`-String zur√ºck. Verwenden Sie stattdessen den separaten `usePathname`-Hook.
- Der neue `useRouter` gibt nicht das `query`-Objekt zur√ºck. Verwenden Sie stattdessen den separaten `useSearchParams`-Hook.
- Sie k√∂nnen `useSearchParams` und `usePathname` kombinieren, um Seiten√§nderungen zu √ºberwachen. Weitere Details finden Sie im Abschnitt [Router Events (Router-Ereignisse)](/docs/app/api-reference/functions/use-router#router-events).
- Diese neuen Hooks werden nur in Client-Komponenten unterst√ºtzt. Sie k√∂nnen nicht in Server-Komponenten verwendet werden.

```tsx filename="app/example-client-component.tsx" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```

```jsx filename="app/example-client-component.js" switcher
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()

  // ...
}
```

Zus√§tzlich weist der neue `useRouter`-Hook folgende √Ñnderungen auf:

- `isFallback` wurde entfernt, da `fallback` [ersetzt wurde](#replacing-fallback).
- Die Werte `locale`, `locales`, `defaultLocales`, `domainLocales` wurden entfernt, da die integrierten i18n-Funktionen von Next.js im `app`-Verzeichnis nicht mehr notwendig sind. [Mehr √ºber i18n erfahren](/docs/pages/building-your-application/routing/internationalization).
- `basePath` wurde entfernt. Die Alternative wird nicht Teil von `useRouter` sein. Sie wurde noch nicht implementiert.
- `asPath` wurde entfernt, da das Konzept von `as` aus dem neuen Router entfernt wurde.
- `isReady` wurde entfernt, da es nicht mehr notwendig ist. W√§hrend des [Static Rendering (statischen Renderings)](/docs/app/building-your-application/rendering/server-components#static-rendering-default) wird jede Komponente, die den [`useSearchParams()`](/docs/app/api-reference/functions/use-params)-Hook verwendet, den Prerendering-Schritt √ºberspringen und stattdessen zur Laufzeit auf dem Client gerendert.

[Siehe die `useRouter()`-API-Referenz](/docs/app/api-reference/functions/use-router).

### Schritt 6: Migration von Data Fetching-Methoden

Das `pages`-Verzeichnis verwendet `getServerSideProps` und `getStaticProps`, um Daten f√ºr Seiten abzurufen. Im `app`-Verzeichnis wurden diese bisherigen Data Fetching-Funktionen durch eine [einfachere API](/docs/app/building-your-application/data-fetching) ersetzt, die auf `fetch()` und `async` React Server Components basiert.

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  // Diese Anfrage sollte zwischengespeichert werden, bis sie manuell ung√ºltig gemacht wird.
  // √Ñhnlich wie `getStaticProps`.
  // `force-cache` ist der Standardwert und kann weggelassen werden.
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // Diese Anfrage sollte bei jeder Anfrage neu abgerufen werden.
  // √Ñhnlich wie `getServerSideProps`.
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // Diese Anfrage sollte mit einer Lebensdauer von 10 Sekunden zwischengespeichert werden.
  // √Ñhnlich wie `getStaticProps` mit der `revalidate`-Option.
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  // Diese Anfrage sollte zwischengespeichert werden, bis sie manuell ung√ºltig gemacht wird.
  // √Ñhnlich wie `getStaticProps`.
  // `force-cache` ist der Standardwert und kann weggelassen werden.
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })

  // Diese Anfrage sollte bei jeder Anfrage neu abgerufen werden.
  // √Ñhnlich wie `getServerSideProps`.
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })

  // Diese Anfrage sollte mit einer Lebensdauer von 10 Sekunden zwischengespeichert werden.
  // √Ñhnlich wie `getStaticProps` mit der `revalidate`-Option.
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })

  return <div>...</div>
}
```

#### Server-seitiges Rendering (`getServerSideProps`)

Im `pages`-Verzeichnis wird `getServerSideProps` verwendet, um Daten auf dem Server abzurufen und Props an die standardm√§√üig exportierte React-Komponente in der Datei weiterzuleiten. Das initiale HTML f√ºr die Seite wird vom Server vorgerendert, gefolgt vom "Hydratisieren" der Seite im Browser (um sie interaktiv zu machen).

```jsx filename="pages/dashboard.js"
// `pages`-Verzeichnis

export async function getServerSideProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Dashboard({ projects }) {
  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

Im `app`-Verzeichnis k√∂nnen wir unseren Datenabruf direkt in unseren React-Komponenten mit [Server Components (Server-Komponenten)](/docs/app/building-your-application/rendering/server-components) platzieren. Dies erm√∂glicht es uns, weniger JavaScript an den Client zu senden, w√§hrend das gerenderte HTML vom Server beibehalten wird.

Indem wir die `cache`-Option auf `no-store` setzen, k√∂nnen wir angeben, dass die abgerufenen Daten [niemals zwischengespeichert werden sollen](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating). Dies √§hnelt `getServerSideProps` im `pages`-Verzeichnis.

```tsx filename="app/dashboard/page.tsx" switcher
// `app`-Verzeichnis

// Diese Funktion kann beliebig benannt werden
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/dashboard/page.js" switcher
// `app`-Verzeichnis

// Diese Funktion kann beliebig benannt werden
async function getProjects() {
  const res = await fetch(`https://...`, { cache: 'no-store' })
  const projects = await res.json()

  return projects
}

export default async function Dashboard() {
  const projects = await getProjects()

  return (
    <ul>
      {projects.map((project) => (
        <li key={project.id}>{project.name}</li>
      ))}
    </ul>
  )
}
```

#### Zugriff auf das Request-Objekt

Im `pages`-Verzeichnis k√∂nnen Sie anforderungsbasierte Daten basierend auf der Node.js HTTP-API abrufen.

Beispielsweise k√∂nnen Sie das `req`-Objekt aus `getServerSideProps` abrufen und damit die Cookies und Header der Anfrage abfragen.

```jsx filename="pages/index.js"
// `pages`-Verzeichnis

export async function getServerSideProps({ req, query }) {
  const authHeader = req.getHeaders()['authorization'];
  const theme = req.cookies['theme'];

  return { props: { ... }}
}

export default function Page(props) {
  return ...
}
```

Das `app`-Verzeichnis stellt neue schreibgesch√ºtzte Funktionen zum Abrufen von Anforderungsdaten bereit:

- [`headers()`](/docs/app/api-reference/functions/headers): Basierend auf der Web Headers API und kann in [Server Components (Server-Komponenten)](/docs/app/building-your-application/rendering/server-components) verwendet werden, um Anfrage-Header abzurufen.
- [`cookies()`](/docs/app/api-reference/functions/cookies): Basierend auf der Web Cookies API und kann in [Server Components (Server-Komponenten)](/docs/app/building-your-application/rendering/server-components) verwendet werden, um Cookies abzurufen.

```tsx filename="app/page.tsx" switcher
// `app`-Verzeichnis
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = headers().get('authorization')

  return '...'
}

export default async function Page() {
  // Sie k√∂nnen `cookies()` oder `headers()` direkt in Server-Komponenten
  // oder in Ihrer Data Fetching-Funktion verwenden
  const theme = cookies().get('theme')
  const data = await getData()
  return '...'
}
```

```jsx filename="app/page.js" switcher
// `app`-Verzeichnis
import { cookies, headers } from 'next/headers'

async function getData() {
  const authHeader = headers().get('authorization')

  return '...'
}

export default async function Page() {
  // Sie k√∂nnen `cookies()` oder `headers()` direkt in Server-Komponenten
  // oder in Ihrer Data Fetching-Funktion verwenden
  const theme = cookies().get('theme')
  const data = await getData()
  return '...'
}
```

#### Statische Seiten-Generierung (`getStaticProps`)

Im `pages`-Verzeichnis wird die `getStaticProps`-Funktion verwendet, um eine Seite zur Build-Zeit vorzurrendern. Diese Funktion kann verwendet werden, um Daten von einer externen API oder direkt aus einer Datenbank abzurufen und diese Daten w√§hrend des Builds an die gesamte Seite weiterzuleiten.

```jsx filename="pages/index.js"
// `pages`-Verzeichnis

export async function getStaticProps() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return { props: { projects } }
}

export default function Index({ projects }) {
  return projects.map((project) => <div>{project.name}</div>)
}
```

Im `app`-Verzeichnis wird der Datenabruf mit [`fetch()`](/docs/app/api-reference/functions/fetch) standardm√§√üig auf `cache: 'force-cache'` gesetzt, was die Anforderungsdaten bis zur manuellen Invalidierung zwischenspeichert. Dies √§hnelt `getStaticProps` im `pages`-Verzeichnis.

```jsx filename="app/page.js"
// `app`-Verzeichnis

// Diese Funktion kann beliebig benannt werden
async function getProjects() {
  const res = await fetch(`https://...`)
  const projects = await res.json()

  return projects
}

export default async function Index() {
  const projects = await getProjects()

  return projects.map((project) => <div>{project.name}</div>)
}
```

#### Dynamische Pfade (`getStaticPaths`)

Im `pages`-Verzeichnis wird die Funktion `getStaticPaths` verwendet, um die dynamischen Pfade zu definieren, die zur Build-Zeit vorgerendert werden sollen.

```jsx filename="pages/posts/[id].js"
// `pages`-Verzeichnis
import PostLayout from '@/components/post-layout'

export async function getStaticPaths() {
  return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
  }
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return { props: { post } }
}

export default function Post({ post }) {
  return <PostLayout post={post} />
}
```

Im `app`-Verzeichnis wird `getStaticPaths` durch [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) ersetzt.

[`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) verh√§lt sich √§hnlich wie `getStaticPaths`, bietet jedoch eine vereinfachte API f√ºr die R√ºckgabe von Routenparametern und kann innerhalb von [Layouts](/docs/app/building-your-application/routing/pages-and-layouts) verwendet werden. Die R√ºckgabeform von `generateStaticParams` ist ein Array von Segmenten anstelle eines Arrays von verschachtelten `param`-Objekten oder einer Zeichenkette von aufgel√∂sten Pfaden.

```jsx filename="app/posts/[id]/page.js"
// `app`-Verzeichnis
import PostLayout from '@/components/post-layout'

export async function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }]
}

async function getPost(params) {
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()

  return post
}

export default async function Post({ params }) {
  const post = await getPost(params)

  return <PostLayout post={post} />
}
```

Die Verwendung des Namens `generateStaticParams` ist f√ºr das neue Modell im `app`-Verzeichnis passender als `getStaticPaths`. Das `get`-Pr√§fix wird durch ein beschreibenderes `generate` ersetzt, das besser allein steht, da `getStaticProps` und `getServerSideProps` nicht mehr notwendig sind. Das `Paths`-Suffix wird durch `Params` ersetzt, was besser f√ºr verschachteltes Routing mit mehreren dynamischen Segmenten geeignet ist.

---

#### Ersetzen von `fallback`

Im `pages`-Verzeichnis wird die Eigenschaft `fallback`, die von `getStaticPaths` zur√ºckgegeben wird, verwendet, um das Verhalten einer Seite zu definieren, die nicht zur Build-Zeit vorgerendert wurde. Diese Eigenschaft kann auf `true` gesetzt werden, um eine Fallback-Seite anzuzeigen, w√§hrend die Seite generiert wird, auf `false`, um eine 404-Seite anzuzeigen, oder auf `blocking`, um die Seite zur Anforderungszeit zu generieren.

```jsx filename="pages/posts/[id].js"
// `pages`-Verzeichnis

export async function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking'
  };
}

export async function getStaticProps({ params }) {
  ...
}

export default function Post({ post }) {
  return ...
}
```

Im `app`-Verzeichnis steuert die Eigenschaft [`config.dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams), wie mit Parametern umgegangen wird, die nicht in [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) enthalten sind:

- **`true`**: (Standard) Dynamische Segmente, die nicht in `generateStaticParams` enthalten sind, werden bei Bedarf generiert.
- **`false`**: Dynamische Segmente, die nicht in `generateStaticParams` enthalten sind, geben einen 404-Fehler zur√ºck.

Dies ersetzt die Option `fallback: true | false | 'blocking'` von `getStaticPaths` im `pages`-Verzeichnis. Die Option `fallback: 'blocking'` ist in `dynamicParams` nicht enthalten, da der Unterschied zwischen `'blocking'` und `true` mit Streaming vernachl√§ssigbar ist.

```jsx filename="app/posts/[id]/page.js"
// `app`-Verzeichnis

export const dynamicParams = true;

export async function generateStaticParams() {
  return [...]
}

async function getPost(params) {
  ...
}

export default async function Post({ params }) {
  const post = await getPost(params);

  return ...
}
```

Wenn [`dynamicParams`](/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams) auf `true` (Standard) gesetzt ist, wird ein angefragtes Routensegment, das noch nicht generiert wurde, serverseitig gerendert und zwischengespeichert.

#### Inkrementelle statische Regeneration (`getStaticProps` mit `revalidate`)

Im `pages`-Verzeichnis erm√∂glicht die Funktion `getStaticProps` das Hinzuf√ºgen eines `revalidate`-Feldes, um eine Seite nach einer bestimmten Zeit automatisch neu zu generieren.

```jsx filename="pages/index.js"
// `pages`-Verzeichnis

export async function getStaticProps() {
  const res = await fetch(`https://.../posts`)
  const posts = await res.json()

  return {
    props: { posts },
    revalidate: 60,
  }
}

export default function Index({ posts }) {
  return (
    <Layout>
      <PostList posts={posts} />
    </Layout>
  )
}
```

Im `app`-Verzeichnis kann das Abrufen von Daten mit [`fetch()`](/docs/app/api-reference/functions/fetch) `revalidate` verwenden, wodurch die Anfrage f√ºr die angegebene Anzahl von Sekunden zwischengespeichert wird.

```jsx filename="app/page.js"
// `app`-Verzeichnis

async function getPosts() {
  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })
  const data = await res.json()

  return data.posts
}

export default async function PostList() {
  const posts = await getPosts()

  return posts.map((post) => <div>{post.name}</div>)
}
```

#### API-Routen

API-Routen funktionieren weiterhin im `pages/api`-Verzeichnis ohne √Ñnderungen. Sie wurden jedoch im `app`-Verzeichnis durch [Route-Handler](/docs/app/building-your-application/routing/route-handlers) ersetzt.

Route-Handler erm√∂glichen es Ihnen, benutzerdefinierte Anfragehandler f√ºr eine bestimmte Route unter Verwendung der Web-[Request](https://developer.mozilla.org/docs/Web/API/Request)- und [Response](https://developer.mozilla.org/docs/Web/API/Response)-APIs zu erstellen.

```ts filename="app/api/route.ts" switcher
export async function GET(request: Request) {}
```

```js filename="app/api/route.js" switcher
export async function GET(request) {}
```

> **Gut zu wissen**: Wenn Sie zuvor API-Routen verwendet haben, um eine externe API vom Client aus aufzurufen, k√∂nnen Sie jetzt stattdessen [Server-Komponenten](/docs/app/building-your-application/rendering/server-components) verwenden, um Daten sicher abzurufen. Erfahren Sie mehr √ºber [Datenabruf](/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating).

### Schritt 7: Styling

Im `pages`-Verzeichnis sind globale Stylesheets auf `pages/_app.js` beschr√§nkt. Mit dem `app`-Verzeichnis wurde diese Einschr√§nkung aufgehoben. Globale Styles k√∂nnen zu jedem Layout, jeder Seite oder Komponente hinzugef√ºgt werden.

- [CSS-Module](/docs/app/building-your-application/styling/css-modules)
- [Tailwind CSS](/docs/app/building-your-application/styling/tailwind-css)
- [Globale Styles](/docs/app/building-your-application/styling/css-modules#global-styles)
- [CSS-in-JS](/docs/app/building-your-application/styling/css-in-js)
- [Externe Stylesheets](/docs/app/building-your-application/styling/css-modules#external-stylesheets)
- [Sass](/docs/app/building-your-application/styling/sass)

#### Tailwind CSS

Wenn Sie Tailwind CSS verwenden, m√ºssen Sie das `app`-Verzeichnis zu Ihrer `tailwind.config.js`-Datei hinzuf√ºgen:

```js filename="tailwind.config.js"
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Diese Zeile hinzuf√ºgen
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
}
```

Sie m√ºssen auch Ihre globalen Styles in Ihrer `app/layout.js`-Datei importieren:

```jsx filename="app/layout.js"
import '../styles/globals.css'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

Erfahren Sie mehr √ºber [Styling mit Tailwind CSS](/docs/app/building-your-application/styling/tailwind-css)

## Codemods

Next.js bietet Codemod-Transformationen, um Ihnen beim Upgrade Ihres Codebase zu helfen, wenn eine Funktion veraltet ist. Weitere Informationen finden Sie unter [Codemods](/docs/app/building-your-application/upgrading/codemods).
