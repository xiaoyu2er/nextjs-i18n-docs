---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:03:24.774Z
title: Daten aktualisieren
nav_title: Daten aktualisieren
description: Erfahren Sie, wie Sie Daten in Ihrer Next.js-Anwendung aktualisieren können.
related:
  title: API-Referenz
  description: Erfahren Sie mehr über die auf dieser Seite erwähnten Funktionen, indem Sie die API-Referenz lesen.
  links:
    - app/api-reference/functions/revalidatePath
    - app/api-reference/functions/revalidateTag
    - app/api-reference/functions/redirect
---

Sie können Daten in Next.js mithilfe von Reacts [Server Functions](https://react.dev/reference/rsc/server-functions) aktualisieren. Diese Seite erklärt, wie Sie [Server Functions erstellen](#creating-server-functions) und [aufrufen](#invoking-server-functions) können.

## Server Functions

Eine Server Function ist eine asynchrone Funktion, die auf dem Server ausgeführt wird. Server Functions sind von Natur aus asynchron, da sie vom Client über eine Netzwerkanfrage aufgerufen werden. Wenn sie als Teil einer `action` aufgerufen werden, werden sie auch **Server Actions** genannt.

Nach Konvention ist eine `action` eine asynchrone Funktion, die an `startTransition` übergeben wird. Server Functions werden automatisch mit `startTransition` umschlossen, wenn:

- Sie an ein `<form>` über die `action`-Prop übergeben werden,
- Sie an einen `<button>` über die `formAction`-Prop übergeben werden,
- Sie an `useActionState` übergeben werden.

## Server Functions erstellen

Eine Server Function kann durch Verwendung der [`use server`](https://react.dev/reference/rsc/use-server)-Direktive definiert werden. Sie können die Direktive am Anfang einer **asynchronen** Funktion platzieren, um die Funktion als Server Function zu markieren, oder am Anfang einer separaten Datei, um alle Exporte dieser Datei zu markieren.

```ts filename="app/lib/actions.ts" switcher
export async function createPost(formData: FormData) {
  'use server'
  const title = formData.get('title')
  const content = formData.get('content')

  // Daten aktualisieren
  // Cache neu validieren
}

export async function deletePost(formData: FormData) {
  'use server'
  const id = formData.get('id')

  // Daten aktualisieren
  // Cache neu validieren
}
```

```js filename="app/lib/actions.js" switcher
export async function createPost(formData) {
  'use server'
  const title = formData.get('title')
  const content = formData.get('content')

  // Daten aktualisieren
  // Cache neu validieren
}

export async function deletePost(formData) {
  'use server'
  const id = formData.get('id')

  // Daten aktualisieren
  // Cache neu validieren
}
```

### Server Components

Server Functions können in Server Components inline definiert werden, indem die `"use server"`-Direktive am Anfang des Funktionskörpers hinzugefügt wird:

```tsx filename="app/page.tsx" switcher
export default function Page() {
  // Server Action
  async function createPost(formData: FormData) {
    'use server'
    // ...
  }

  return <></>
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  // Server Action
  async function createPost(formData: FormData) {
    'use server'
    // ...
  }

  return <></>
}
```

### Client Components

Es ist nicht möglich, Server Functions in Client Components zu definieren. Sie können sie jedoch in Client Components aufrufen, indem Sie sie aus einer Datei importieren, die die `"use server"`-Direktive am Anfang enthält:

```ts filename="app/actions.ts" switcher
'use server'

export async function createPost() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function createPost() {}
```

```tsx filename="app/ui/button.tsx" switcher
'use client'

import { createPost } from '@/app/actions'

export function Button() {
  return <button formAction={createPost}>Erstellen</button>
}
```

```jsx filename="app/ui/button.js" switcher
'use client'

import { createPost } from '@/app/actions'

export function Button() {
  return <button formAction={createPost}>Erstellen</button>
}
```

## Server Functions aufrufen

Es gibt zwei Hauptmethoden, um eine Server Function aufzurufen:

1. [Formulare](#forms) in Server- und Client-Components
2. [Event-Handler](#event-handlers) in Client-Components

### Formulare

React erweitert das HTML-[`<form>`](https://react.dev/reference/react-dom/components/form)-Element, um das Aufrufen einer Server Function mit der HTML-`action`-Prop zu ermöglichen.

Wenn die Funktion in einem Formular aufgerufen wird, erhält sie automatisch das [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData/FormData)-Objekt. Sie können die Daten mit den nativen [`FormData`-Methoden](https://developer.mozilla.org/en-US/docs/Web/API/FormData#instance_methods) extrahieren:

```tsx filename="app/ui/form.tsx" switcher
import { createPost } from '@/app/actions'

export function Form() {
  return (
    <form action={createPost}>
      <input type="text" name="title" />
      <input type="text" name="content" />
      <button type="submit">Erstellen</button>
    </form>
  )
}
```

```jsx filename="app/ui/form.js" switcher
import { createPost } from '@/app/actions'

export function Form() {
  return (
    <form action={createPost}>
      <input type="text" name="title" />
      <input type="text" name="content" />
      <button type="submit">Erstellen</button>
    </form>
  )
}
```

```ts filename="app/actions.ts" switcher
'use server'

export async function createPost(formData: FormData) {
  const title = formData.get('title')
  const content = formData.get('content')

  // Daten aktualisieren
  // Cache neu validieren
}
```

```js filename="app/actions.js" switcher
'use server'

export async function createPost(formData) {
  const title = formData.get('title')
  const content = formData.get('content')

  // Daten aktualisieren
  // Cache neu validieren
}
```

> **Gut zu wissen:** Wenn sie an die `action`-Prop übergeben werden, werden Server Functions auch als _Server Actions_ bezeichnet.

### Event-Handler

Sie können eine Server Function in einer Client Component mithilfe von Event-Handlern wie `onClick` aufrufen.

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Gesamt-Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Gesamt-Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

## Beispiele

### Anzeigen eines Ladezustands

Während eine Server Function ausgeführt wird, können Sie einen Ladeindikator mit Reacts [`useActionState`](https://react.dev/reference/react/useActionState)-Hook anzeigen. Dieser Hook gibt einen `pending`-Boolean zurück:

```tsx filename="app/ui/button.tsx" switcher
'use client'

import { useActionState } from 'react'
import { createPost } from '@/app/actions'
import { LoadingSpinner } from '@/app/ui/loading-spinner'

export function Button() {
  const [state, action, pending] = useActionState(createPost, false)

  return (
    <button onClick={async () => action()}>
      {pending ? <LoadingSpinner /> : 'Beitrag erstellen'}
    </button>
  )
}
```

```jsx filename="app/ui/button.js" switcher
'use client'

import { useActionState } from 'react'
import { createPost } from '@/app/actions'
import { LoadingSpinner } from '@/app/ui/loading-spinner'

export function Button() {
  const [state, action, pending] = useActionState(createPost, false)

  return (
    <button onClick={async () => action()}>
      {pending ? <LoadingSpinner /> : 'Beitrag erstellen'}
    </button>
  )
}
```

### Cache neu validieren

Nach einer Aktualisierung können Sie den Next.js-Cache neu validieren und die aktualisierten Daten anzeigen, indem Sie [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) oder [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) innerhalb der Server Function aufrufen:

```ts filename="app/lib/actions.ts" switcher
import { revalidatePath } from 'next/cache'

export async function createPost(formData: FormData) {
  'use server'
  // Daten aktualisieren
  // ...

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
import { revalidatePath } from 'next/cache'

export async function createPost(formData) {
  'use server'
  // Daten aktualisieren
  // ...
  revalidatePath('/posts')
}
```

### Weiterleiten

Möglicherweise möchten Sie den Benutzer nach einer Aktualisierung auf eine andere Seite weiterleiten. Dies können Sie tun, indem Sie [`redirect`](/docs/app/api-reference/functions/redirect) innerhalb der Server Function aufrufen:

```ts filename="app/lib/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createPost(formData: FormData) {
  // Daten aktualisieren
  // ...

  redirect('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'

export async function createPost(formData) {
  // Daten aktualisieren
  // ...

  redirect('/posts')
}
```