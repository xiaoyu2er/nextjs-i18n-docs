---
source-updated-at: 2025-06-08T05:18:03.000Z
translation-updated-at: 2025-06-08T05:18:03.000Z
title: Verwendung von Partial Prerendering
nav_title: Partial Prerendering
description: Erfahren Sie, wie Sie die Vorteile von statischem und dynamischem Rendering mit Partial Prerendering kombinieren k√∂nnen.
version: experimental
related:
  title: N√§chste Schritte
  description: Erfahren Sie mehr √ºber die Konfigurationsoption f√ºr Partial Prerendering.
  links:
    - app/api-reference/config/next-config-js/ppr
---

Partial Prerendering (PPR) ist eine Rendering-Strategie, die es erm√∂glicht, statische und dynamische Inhalte in derselben Route zu kombinieren. Dies verbessert die anf√§ngliche Seitenleistung, w√§hrend gleichzeitig personalisierte, dynamische Daten unterst√ºtzt werden.

<Image
  alt="Teilweise vorgerenderte Produktseite mit statischer Navigation und Produktinformationen sowie dynamischem Warenkorb und empfohlenen Produkten"
  srcLight="/learn/light/thinking-in-ppr.png"
  srcDark="/learn/dark/thinking-in-ppr.png"
  width="1600"
  height="632"
/>

Wenn ein Benutzer eine Route aufruft:

- Sendet der Server eine **Shell** mit den statischen Inhalten, was einen schnellen initialen Ladevorgang gew√§hrleistet.
- Die Shell l√§sst **L√ºcken** f√ºr dynamische Inhalte, die asynchron nachgeladen werden.
- Die dynamischen L√ºcken werden **parallel gestreamt**, was die gesamte Ladezeit der Seite reduziert.

> **üé• Video ansehen:** Warum PPR und wie es funktioniert ‚Üí [YouTube (10 Minuten)](https://www.youtube.com/watch?v=MTcPrTIBkpA).

## Wie funktioniert Partial Prerendering?

Um Partial Prerendering zu verstehen, ist es hilfreich, die in Next.js verf√ºgbaren Rendering-Strategien zu kennen.

### Statisches Rendering

Beim statischen Rendering wird HTML im Voraus generiert ‚Äì entweder beim Build oder durch [Revalidierung](/docs/app/guides/incremental-static-regeneration). Das Ergebnis wird zwischengespeichert und f√ºr alle Benutzer und Anfragen gemeinsam genutzt.

Bei Partial Prerendering prerendert Next.js eine **statische Shell** f√ºr eine Route. Diese kann das Layout und alle anderen Komponenten enthalten, die nicht von Anfragezeit-Daten abh√§ngen.

### Dynamisches Rendering

Beim dynamischen Rendering wird HTML zur **Anfragezeit** generiert. Dies erm√∂glicht die Bereitstellung personalisierter Inhalte basierend auf Anfragezeit-Daten.

Eine Komponente wird dynamisch, wenn sie die folgenden APIs verwendet:

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)
- [`fetch`](/docs/app/api-reference/functions/fetch) mit `{ cache: 'no-store' }`

Bei Partial Prerendering f√ºhrt die Verwendung dieser APIs zu einem speziellen React-Fehler, der Next.js mitteilt, dass die Komponente nicht statisch gerendert werden kann, was zu einem Build-Fehler f√ºhrt. Sie k√∂nnen eine [Suspense](#suspense)-Grenze verwenden, um Ihre Komponente zu umschlie√üen und das Rendering auf die Laufzeit zu verschieben.

### Suspense

React [Suspense](https://react.dev/reference/react/Suspense) wird verwendet, um das Rendering von Teilen Ihrer Anwendung zu verz√∂gern, bis eine bestimmte Bedingung erf√ºllt ist.

Bei Partial Prerendering wird Suspense verwendet, um **dynamische Grenzen** in Ihrem Komponentenbaum zu markieren.

Zum Build-Zeitpunkt prerendert Next.js die statischen Inhalte und die `fallback`-UI. Die dynamischen Inhalte werden **zur√ºckgestellt**, bis der Benutzer die Route anfordert.

Das Umschlie√üen einer Komponente mit Suspense macht die Komponente selbst nicht dynamisch (das tun Ihre API-Aufrufe), sondern Suspense dient als Grenze, die dynamische Inhalte kapselt und [Streaming](#streaming) erm√∂glicht.

```jsx filename="app/page.js"
import { Suspense } from 'react'
import StaticComponent from './StaticComponent'
import DynamicComponent from './DynamicComponent'
import Fallback from './Fallback'

export const experimental_ppr = true

export default function Page() {
  return (
    <>
      <StaticComponent />
      <Suspense fallback={<Fallback />}>
        <DynamicComponent />
      </Suspense>
    </>
  )
}
```

### Streaming

Streaming teilt die Route in Chunks auf und √ºbertr√§gt sie progressiv an den Client, sobald sie bereit sind. Dadurch kann der Benutzer Teile der Seite sofort sehen, bevor der gesamte Inhalt fertig gerendert wurde.

<Image
  alt="Diagramm einer teilweise gerenderten Seite auf dem Client mit Lade-UI f√ºr Chunks, die gestreamt werden."
  srcLight="/docs/light/server-rendering-with-streaming.png"
  srcDark="/docs/dark/server-rendering-with-streaming.png"
  width="1600"
  height="785"
/>

Bei Partial Prerendering beginnen dynamische Komponenten, die in Suspense eingeschlossen sind, parallel vom Server zu streamen.

<Image
  alt="Diagramm der Parallelisierung von Routensegmenten w√§hrend des Streamings, das das Abrufen, Rendering und Hydration einzelner Chunks zeigt."
  srcLight="/docs/light/sequential-parallel-data-fetching.png"
  srcDark="/docs/dark/sequential-parallel-data-fetching.png"
  width="1600"
  height="525"
/>

Um den Netzwerk-Overhead zu reduzieren, wird die vollst√§ndige Antwort ‚Äì einschlie√ülich statischem HTML und gestreamten dynamischen Teilen ‚Äì in einer **einzelnen HTTP-Anfrage** gesendet. Dies vermeidet zus√§tzliche Roundtrips und verbessert sowohl den initialen Ladevorgang als auch die Gesamtleistung.

## Aktivierung von Partial Prerendering

Sie k√∂nnen PPR aktivieren, indem Sie die [`ppr`](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr)-Option zu Ihrer `next.config.ts`-Datei hinzuf√ºgen:

```ts filename="next.config.ts" highlight={5} switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}

export default nextConfig
```

```js filename="next.config.js" highlight={4} switcher
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
}
```

Der Wert `'incremental'` erm√∂glicht es Ihnen, PPR f√ºr bestimmte Routen zu verwenden:

```tsx filename="/app/dashboard/layout.tsx"
export const experimental_ppr = true

export default function Layout({ children }: { children: React.ReactNode }) {
  // ...
}
```

```jsx filename="/app/dashboard/layout.js"
export const experimental_ppr = true

export default function Layout({ children }) {
  // ...
}
```

Routen, die `experimental_ppr` nicht haben, standardm√§√üig auf `false` und werden nicht mit PPR prerendert. Sie m√ºssen PPR f√ºr jede Route explizit aktivieren.

> **Gut zu wissen**:
>
> - `experimental_ppr` gilt f√ºr alle Kinder des Routensegments, einschlie√ülich verschachtelter Layouts und Seiten. Sie m√ºssen es nicht jeder Datei hinzuf√ºgen, sondern nur dem obersten Segment einer Route.
> - Um PPR f√ºr Kindsegmente zu deaktivieren, k√∂nnen Sie `experimental_ppr` im Kindsegment auf `false` setzen.

## Beispiele

### Dynamische APIs

Bei der Verwendung dynamischer APIs, die die eingehende Anfrage untersuchen m√ºssen, wechselt Next.js zum dynamischen Rendering f√ºr die Route. Um PPR weiterhin zu verwenden, umschlie√üen Sie die Komponente mit Suspense. Beispielsweise ist die `<User />`-Komponente dynamisch, weil sie die `cookies`-API verwendet:

```jsx filename="app/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

```tsx filename="app/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const session = (await cookies()).get('session')?.value
  return '...'
}
```

Die `<User />`-Komponente wird gestreamt, w√§hrend alle anderen Inhalte innerhalb von `<Page />` prerendert werden und Teil der statischen Shell werden.

```tsx filename="app/page.tsx" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Dies wird prerendert</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Suspense } from 'react'
import { User, AvatarSkeleton } from './user'

export const experimental_ppr = true

export default function Page() {
  return (
    <section>
      <h1>Dies wird prerendert</h1>
      <Suspense fallback={<AvatarSkeleton />}>
        <User />
      </Suspense>
    </section>
  )
}
```

### √úbergeben dynamischer Props

Komponenten werden nur dann dynamisch, wenn der Wert abgerufen wird. Wenn Sie beispielsweise `searchParams` aus einer `<Page />`-Komponente lesen, k√∂nnen Sie diesen Wert als Prop an eine andere Komponente weitergeben:

```tsx filename="app/page.tsx" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  return (
    <section>
      <h1>Dies wird prerendert</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

```jsx filename="app/page.js" switcher
import { Table, TableSkeleton } from './table'
import { Suspense } from 'react'

export default function Page({ searchParams }) {
  return (
    <section>
      <h1>Dies wird prerendert</h1>
      <Suspense fallback={<TableSkeleton />}>
        <Table searchParams={searchParams} />
      </Suspense>
    </section>
  )
}
```

Innerhalb der Tabellenkomponente macht der Zugriff auf den Wert von `searchParams` die Komponente dynamisch, w√§hrend der Rest der Seite prerendert wird.

```tsx filename="app/table.tsx" switcher
export async function Table({
  searchParams,
}: {
  searchParams: Promise<{ sort: string }>
}) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```

```jsx filename="app/table.js" switcher
export async function Table({ searchParams }) {
  const sort = (await searchParams).sort === 'true'
  return '...'
}
```