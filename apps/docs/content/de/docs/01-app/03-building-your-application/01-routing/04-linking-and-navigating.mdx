---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:13:15.217Z
title: Verlinkung und Navigation
description: Erfahren Sie, wie Navigation in Next.js funktioniert und wie Sie die Link-Komponente sowie den `useRouter`-Hook verwenden.
related:
  links:
    - app/deep-dive/caching
    - app/api-reference/config/typescript
---

In Next.js gibt es vier Möglichkeiten, zwischen Routen zu navigieren:

- Verwendung der [`<Link>`-Komponente](#link-component)
- Verwendung des [`useRouter`-Hooks](#userouter-hook) ([Client Components](/docs/app/getting-started/server-and-client-components))
- Verwendung der [`redirect`-Funktion](#redirect-function) ([Server Components](/docs/app/getting-started/server-and-client-components))
- Verwendung der nativen [History API](#using-the-native-history-api)

Diese Seite erklärt die Verwendung dieser Optionen und geht tiefer auf die Funktionsweise der Navigation ein.

## `<Link>`-Komponente

`<Link>` ist eine eingebaute Komponente, die das HTML-`<a>`-Tag erweitert, um [Prefetching](#2-prefetching) und clientseitige Navigation zwischen Routen zu ermöglichen. Es ist die primäre und empfohlene Methode für die Navigation zwischen Routen in Next.js.

Sie können sie verwenden, indem Sie sie aus `next/link` importieren und der Komponente eine `href`-Prop übergeben:

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

Es gibt weitere optionale Props, die Sie an `<Link>` übergeben können. Weitere Informationen finden Sie in der [API-Referenz](/docs/app/api-reference/components/link).

## `useRouter()`-Hook

Der `useRouter`-Hook ermöglicht es Ihnen, Routen programmatisch aus [Client Components](/docs/app/getting-started/server-and-client-components) zu ändern.

```tsx filename="app/page.tsx" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

```jsx filename="app/page.js" switcher
'use client'

import { useRouter } from 'next/navigation'

export default function Page() {
  const router = useRouter()

  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Eine vollständige Liste der `useRouter`-Methoden finden Sie in der [API-Referenz](/docs/app/api-reference/functions/use-router).

> **Empfehlung:** Verwenden Sie die `<Link>`-Komponente für die Navigation zwischen Routen, es sei denn, Sie haben einen spezifischen Grund für die Verwendung von `useRouter`.

## `redirect`-Funktion

Für [Server Components](/docs/app/getting-started/server-and-client-components) verwenden Sie stattdessen die `redirect`-Funktion.

```tsx filename="app/team/[id]/page.tsx" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

```jsx filename="app/team/[id]/page.js" switcher
import { redirect } from 'next/navigation'

async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}

export default async function Profile({ params }) {
  const { id } = await params
  if (!id) {
    redirect('/login')
  }

  const team = await fetchTeam(id)
  if (!team) {
    redirect('/join')
  }

  // ...
}
```

> **Wissenswertes**:
>
> - `redirect` gibt standardmäßig einen 307 (Temporary Redirect)-Statuscode zurück. Bei Verwendung in einer Server Action wird ein 303 (See Other) zurückgegeben, der häufig für die Weiterleitung zu einer Erfolgsseite nach einer POST-Anfrage verwendet wird.
> - `redirect` wirft intern einen Fehler aus und sollte daher außerhalb von `try/catch`-Blöcken aufgerufen werden.
> - `redirect` kann in Client Components während des Rendering-Prozesses aufgerufen werden, jedoch nicht in Event-Handlern. Verwenden Sie stattdessen den [`useRouter`-Hook](#userouter-hook).
> - `redirect` akzeptiert auch absolute URLs und kann für Weiterleitungen zu externen Links verwendet werden.
> - Wenn Sie vor dem Rendering-Prozess weiterleiten möchten, verwenden Sie [`next.config.js`](/docs/app/guides/redirecting#redirects-in-nextconfigjs) oder [Middleware](/docs/app/guides/redirecting#nextresponseredirect-in-middleware).

Weitere Informationen finden Sie in der [`redirect`-API-Referenz](/docs/app/api-reference/functions/redirect).

## Verwendung der nativen History API

Next.js ermöglicht die Verwendung der nativen Methoden [`window.history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) und [`window.history.replaceState`](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState), um den Browserverlauf zu aktualisieren, ohne die Seite neu zu laden.

Aufrufe von `pushState` und `replaceState` werden in den Next.js-Router integriert, sodass Sie sie mit [`usePathname`](/docs/app/api-reference/functions/use-pathname) und [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) synchronisieren können.

### `window.history.pushState`

Verwenden Sie diese Methode, um einen neuen Eintrag zum Browserverlauf hinzuzufügen. Der Benutzer kann zum vorherigen Zustand zurücknavigieren. Beispielsweise zum Sortieren einer Produktliste:

```tsx fileName="app/ui/sort-products.tsx" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder: string) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Aufsteigend sortieren</button>
      <button onClick={() => updateSorting('desc')}>Absteigend sortieren</button>
    </>
  )
}
```

```jsx fileName="app/ui/sort-products.js" switcher
'use client'

import { useSearchParams } from 'next/navigation'

export default function SortProducts() {
  const searchParams = useSearchParams()

  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }

  return (
    <>
      <button onClick={() => updateSorting('asc')}>Aufsteigend sortieren</button>
      <button onClick={() => updateSorting('desc')}>Absteigend sortieren</button>
    </>
  )
}
```

### `window.history.replaceState`

Verwenden Sie diese Methode, um den aktuellen Eintrag im Browserverlauf zu ersetzen. Der Benutzer kann nicht zum vorherigen Zustand zurücknavigieren. Beispielsweise zum Wechseln der Anwendungssprache:

```tsx fileName="app/ui/locale-switcher.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale: string) {
    // z.B. '/en/about' oder '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Englisch</button>
      <button onClick={() => switchLocale('fr')}>Französisch</button>
    </>
  )
}
```

```jsx fileName="app/ui/locale-switcher.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function LocaleSwitcher() {
  const pathname = usePathname()

  function switchLocale(locale) {
    // z.B. '/en/about' oder '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }

  return (
    <>
      <button onClick={() => switchLocale('en')}>Englisch</button>
      <button onClick={() => switchLocale('fr')}>Französisch</button>
    </>
  )
}
```

## Funktionsweise von Routing und Navigation

Der App Router verwendet einen hybriden Ansatz für Routing und Navigation. Auf dem Server wird Ihr Anwendungscode automatisch nach [Route-Segmenten aufgeteilt](#1-code-splitting). Auf dem Client prefetcht und cached Next.js die [Route-Segmente](#2-prefetching). Das bedeutet, dass bei der Navigation zu einer neuen Route die Seite nicht neu geladen wird und nur die sich ändernden Route-Segmente neu gerendert werden – was die Navigationserfahrung und Leistung verbessert.

### 1. Code Splitting

Code Splitting ermöglicht es, Ihren Anwendungscode in kleinere Bundles aufzuteilen, die vom Browser heruntergeladen und ausgeführt werden können. Dies reduziert die übertragene Datenmenge und die Ausführungszeit für jede Anfrage und verbessert so die Leistung.

[Server Components](/docs/app/getting-started/server-and-client-components) ermöglichen die automatische Aufteilung Ihres Anwendungscodes nach Route-Segmenten. Das bedeutet, dass nur der Code für die aktuelle Route bei der Navigation geladen wird.

### 2. Prefetching

Prefetching ist eine Methode, um eine Route im Hintergrund vorzuladen, bevor der Benutzer sie besucht.

Es gibt zwei Möglichkeiten, wie Routen in Next.js geprefetcht werden:

- **`<Link>`-Komponente**: Routen werden automatisch geprefetcht, sobald sie im Blickfeld des Benutzers erscheinen. Das Prefetching erfolgt beim ersten Laden der Seite oder beim Scrollen in den sichtbaren Bereich.
- **`router.prefetch()`**: Der `useRouter`-Hook kann verwendet werden, um Routen programmatisch vorzuladen.

Das Standard-Prefetching-Verhalten von `<Link>` (d.h. wenn die `prefetch`-Prop nicht angegeben oder auf `null` gesetzt ist) unterscheidet sich je nach Verwendung von [`loading.js`](/docs/app/api-reference/file-conventions/loading). Nur das gemeinsame Layout bis zur ersten `loading.js`-Datei im gerenderten "Baum" der Komponenten wird geprefetcht und für `30s` gecacht. Dies reduziert die Kosten für das Abrufen einer gesamten dynamischen Route und ermöglicht die Anzeige eines [sofortigen Ladezustands](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states) für bessere visuelle Rückmeldung an den Benutzer.

Sie können das Prefetching deaktivieren, indem Sie die `prefetch`-Prop auf `false` setzen. Alternativ können Sie die vollständigen Seitendaten über die Ladegrenzen hinaus prefetchen, indem Sie die `prefetch`-Prop auf `true` setzen.

Weitere Informationen finden Sie in der [`<Link>`-API-Referenz](/docs/app/api-reference/components/link).

> **Wissenswertes**:
>
> - Prefetching ist in der Entwicklung nicht aktiviert, nur in der Produktion.

### 3. Caching

Next.js verfügt über einen **clientseitigen In-Memory-Cache** namens [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache). Wenn Benutzer durch die App navigieren, werden die React Server Component Payloads von [geprefetchten](#2-prefetching) Route-Segmenten und besuchten Routen im Cache gespeichert.

Das bedeutet, dass bei der Navigation der Cache so weit wie möglich wiederverwendet wird, anstatt eine neue Anfrage an den Server zu stellen – was die Leistung durch Reduzierung der Anzahl der Anfragen und der übertragenen Daten verbessert.

Erfahren Sie mehr über die Funktionsweise des [Router Caches](/docs/app/deep-dive/caching#client-side-router-cache) und dessen Konfiguration.

### 4. Partielles Rendering

Partielles Rendering bedeutet, dass nur die Route-Segmente, die sich bei der Navigation ändern, clientseitig neu gerendert werden, während gemeinsame Segmente erhalten bleiben.

Beispielsweise wird beim Navigieren zwischen zwei Geschwisterrouten, `/dashboard/settings` und `/dashboard/analytics`, die `settings`-Seite ausgeblendet, die `analytics`-Seite mit frischem Zustand eingeblendet und das gemeinsame `dashboard`-Layout beibehalten. Dieses Verhalten tritt auch zwischen zwei Routen auf demselben dynamischen Segment auf, z.B. bei `/blog/[slug]/page` und der Navigation von `/blog/first` zu `/blog/second`.

<Image
  alt="Wie partielles Rendering funktioniert"
  srcLight="/docs/light/partial-rendering.png"
  srcDark="/docs/dark/partial-rendering.png"
  width="1600"
  height="945"
/>

Ohne partielles Rendering würde jede Navigation ein vollständiges Neu-Rendering der Seite auf dem Client verursachen. Das Rendern nur des sich ändernden Segments reduziert die übertragene Datenmenge und die Ausführungszeit, was die Leistung verbessert.

### 5. Soft Navigation

Browser führen eine "Hard Navigation" durch, wenn zwischen Seiten navigiert wird. Der Next.js App Router ermöglicht eine "Soft Navigation" zwischen Seiten, bei der nur die sich ändernden Route-Segmente neu gerendert werden (partielles Rendering). Dadurch bleibt der clientseitige React-Zustand während der Navigation erhalten.

### 6. Vor- und Zurück-Navigation

Standardmäßig behält Next.js die Scroll-Position für Vor- und Zurück-Navigation bei und verwendet Route-Segmente aus dem [Router Cache](/docs/app/deep-dive/caching#client-side-router-cache) wieder.

### 7. Routing zwischen `pages/` und `app/`

Bei der schrittweisen Migration von `pages/` zu `app/` behandelt der Next.js-Router die Hard Navigation zwischen den beiden automatisch. Um Übergänge von `pages/` zu `app/` zu erkennen, gibt es einen Client-Router-Filter, der probabilistische Prüfungen von App-Routen nutzt, was gelegentlich zu falsch positiven Ergebnissen führen kann. Standardmäßig sollten solche Vorkommnisse sehr selten sein, da wir die Wahrscheinlichkeit für falsch positive Ergebnisse auf 0,01 % konfigurieren. Diese Wahrscheinlichkeit kann über die Option `experimental.clientRouterFilterAllowedRate` in `next.config.js` angepasst werden. Es ist wichtig zu beachten, dass eine Senkung der falsch positiven Rate die Größe des generierten Filters im Client-Bundle erhöht.

Alternativ können Sie diese automatische Handhabung deaktivieren und das Routing zwischen `pages/` und `app/` manuell verwalten, indem Sie `experimental.clientRouterFilter` in `next.config.js` auf `false` setzen. Wenn diese Funktion deaktiviert ist, werden dynamische Routen in pages, die mit app-Routen überlappen, standardmäßig nicht korrekt angesteuert.