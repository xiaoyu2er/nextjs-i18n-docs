---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:14:01.588Z
title: Server Actions und Mutationen
nav_title: Server Actions und Mutationen
description: Erfahren Sie, wie Sie Formular√ºbermittlungen und Datenmutationen mit Next.js handhaben k√∂nnen.
related:
  description: Erfahren Sie, wie Sie Server Actions in Next.js konfigurieren
  links:
    - app/api-reference/config/next-config-js/serverActions
---

[Server Actions](https://react.dev/reference/rsc/server-actions) sind **asynchrone Funktionen**, die auf dem Server ausgef√ºhrt werden. Sie k√∂nnen in Server- und Client-Komponenten aufgerufen werden, um Formular√ºbermittlungen und Datenmutationen in Next.js-Anwendungen zu verarbeiten.

> **üé• Video:** Mehr √ºber Mutationen mit Server Actions erfahren ‚Üí [YouTube (10 Minuten)](https://youtu.be/dDpZfOQBMaU?si=cJZHlUu_jFhCzHUg).

## Konvention

Eine Server Action kann mit der React [`"use server"`](https://react.dev/reference/react/use-server)-Direktive definiert werden. Sie k√∂nnen die Direktive entweder am Anfang einer `async`-Funktion platzieren, um die Funktion als Server Action zu markieren, oder am Anfang einer separaten Datei, um alle Exporte dieser Datei als Server Actions zu kennzeichnen.

### Server-Komponenten

Server-Komponenten k√∂nnen die `"use server"`-Direktive auf Funktions- oder Modulebene verwenden. Um eine Server Action inline zu definieren, f√ºgen Sie `"use server"` am Anfang des Funktionsk√∂rpers hinzu:

```tsx filename="app/page.tsx" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // Daten mutieren
  }

  return '...'
}
```

```jsx filename="app/page.js" switcher
export default function Page() {
  // Server Action
  async function create() {
    'use server'
    // Daten mutieren
  }

  return '...'
}
```

### Client-Komponenten

Um eine [Server-Funktion](/docs/app/getting-started/updating-data#server-functions) in einer Client-Komponente aufzurufen, erstellen Sie eine neue Datei und f√ºgen die `"use server"`-Direktive am Anfang hinzu. Alle exportierten Funktionen innerhalb der Datei werden als Server-Funktionen markiert, die sowohl in Client- als auch Server-Komponenten wiederverwendet werden k√∂nnen:

```tsx filename="app/actions.ts" switcher
'use server'

export async function create() {}
```

```js filename="app/actions.js" switcher
'use server'

export async function create() {}
```

```tsx filename="app/button.tsx" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

```jsx filename="app/button.js" switcher
'use client'

import { create } from './actions'

export function Button() {
  return <button onClick={() => create()}>Create</button>
}
```

### Aktionen als Props √ºbergeben

Sie k√∂nnen eine Server Action auch als Prop an eine Client-Komponente √ºbergeben:

```jsx
<ClientComponent updateItemAction={updateItem} />
```

```tsx filename="app/client-component.tsx" switcher
'use client'

export default function ClientComponent({
  updateItemAction,
}: {
  updateItemAction: (formData: FormData) => void
}) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

```jsx filename="app/client-component.js" switcher
'use client'

export default function ClientComponent({ updateItemAction }) {
  return <form action={updateItemAction}>{/* ... */}</form>
}
```

Normalerweise w√ºrde das Next.js TypeScript-Plugin `updateItemAction` in `client-component.tsx` markieren, da es sich um eine Funktion handelt, die im Allgemeinen nicht √ºber Client-Server-Grenzen hinweg serialisiert werden kann. Allerdings wird bei Props mit dem Namen `action` oder solchen, die mit `Action` enden, angenommen, dass sie Server Actions erhalten. Dies ist nur eine Heuristik, da das TypeScript-Plugin nicht tats√§chlich wei√ü, ob es eine Server Action oder eine gew√∂hnliche Funktion erh√§lt. Laufzeit-Typ√ºberpr√ºfungen stellen dennoch sicher, dass Sie nicht versehentlich eine Funktion an eine Client-Komponente √ºbergeben.

## Verhalten

- Server Actions k√∂nnen mit dem `action`-Attribut in einem `<form>`-Element aufgerufen werden.
  - Server-Komponenten unterst√ºtzen standardm√§√üig progressive Verbesserung, was bedeutet, dass das Formular auch dann √ºbermittelt wird, wenn JavaScript noch nicht geladen oder deaktiviert ist.
  - In Client-Komponenten werden Formulare, die Server Actions aufrufen, in eine Warteschlange gestellt, wenn JavaScript noch nicht geladen ist, wobei die Client-Hydration priorisiert wird.
  - Nach der Hydration wird der Browser bei der Formular√ºbermittlung nicht aktualisiert.
- Server Actions sind nicht auf `<form>` beschr√§nkt und k√∂nnen von Event-Handlern, `useEffect`, Bibliotheken von Drittanbietern und anderen Formularelementen wie `<button>` aufgerufen werden.
- Server Actions sind in die [Caching- und Revalidierungsarchitektur](/docs/app/deep-dive/caching) von Next.js integriert. Wenn eine Aktion aufgerufen wird, kann Next.js sowohl die aktualisierte Benutzeroberfl√§che als auch neue Daten in einem einzigen Server-Roundtrip zur√ºckgeben.
- Im Hintergrund verwenden Actions die `POST`-Methode, und nur diese HTTP-Methode kann sie aufrufen.
- Die Argumente und R√ºckgabewerte von Server Actions m√ºssen von React serialisierbar sein. Siehe die React-Dokumentation f√ºr eine Liste der [serialisierbaren Argumente und Werte](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values).
- Server Actions sind Funktionen. Das bedeutet, dass sie √ºberall in Ihrer Anwendung wiederverwendet werden k√∂nnen.
- Server Actions √ºbernehmen die Laufzeitumgebung von der Seite oder dem Layout, in dem sie verwendet werden.
- Server Actions √ºbernehmen die [Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config) von der Seite oder dem Layout, in dem sie verwendet werden, einschlie√ülich Feldern wie `maxDuration`.

## Beispiele

### Event-Handler

W√§hrend es √ºblich ist, Server Actions innerhalb von `<form>`-Elementen zu verwenden, k√∂nnen sie auch mit Event-Handlern wie `onClick` aufgerufen werden. Zum Beispiel, um einen Like-Z√§hler zu erh√∂hen:

```tsx filename="app/like-button.tsx" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }: { initialLikes: number }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

```jsx filename="app/like-button.js" switcher
'use client'

import { incrementLike } from './actions'
import { useState } from 'react'

export default function LikeButton({ initialLikes }) {
  const [likes, setLikes] = useState(initialLikes)

  return (
    <>
      <p>Total Likes: {likes}</p>
      <button
        onClick={async () => {
          const updatedLikes = await incrementLike()
          setLikes(updatedLikes)
        }}
      >
        Like
      </button>
    </>
  )
}
```

Sie k√∂nnen auch Event-Handler zu Formularelementen hinzuf√ºgen, zum Beispiel, um ein Formularfeld bei `onChange` zu speichern:

```tsx filename="app/ui/edit-post.tsx"
'use client'

import { publishPost, saveDraft } from './actions'

export default function EditPost() {
  return (
    <form action={publishPost}>
      <textarea
        name="content"
        onChange={async (e) => {
          await saveDraft(e.target.value)
        }}
      />
      <button type="submit">Publish</button>
    </form>
  )
}
```

F√ºr solche F√§lle, in denen mehrere Ereignisse in schneller Folge ausgel√∂st werden k√∂nnen, empfehlen wir **Debouncing**, um unn√∂tige Server-Action-Aufrufe zu vermeiden.

### `useEffect`

Sie k√∂nnen den React [`useEffect`](https://react.dev/reference/react/useEffect)-Hook verwenden, um eine Server Action beim Mounten der Komponente oder bei einer √Ñnderung der Abh√§ngigkeiten aufzurufen. Dies ist n√ºtzlich f√ºr Mutationen, die von globalen Ereignissen abh√§ngen oder automatisch ausgel√∂st werden m√ºssen. Zum Beispiel `onKeyDown` f√ºr App-Shortcuts, ein Intersection Observer Hook f√ºr unendliches Scrollen oder beim Mounten der Komponente, um eine Aufrufz√§hlung zu aktualisieren:

```tsx filename="app/view-count.tsx" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }: { initialViews: number }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    startTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // Sie k√∂nnen `isPending` verwenden, um Benutzern Feedback zu geben
  return <p>Total Views: {views}</p>
}
```

```jsx filename="app/view-count.js" switcher
'use client'

import { incrementViews } from './actions'
import { useState, useEffect, useTransition } from 'react'

export default function ViewCount({ initialViews }) {
  const [views, setViews] = useState(initialViews)
  const [isPending, startTransition] = useTransition()

  useEffect(() => {
    starTransition(async () => {
      const updatedViews = await incrementViews()
      setViews(updatedViews)
    })
  }, [])

  // Sie k√∂nnen `isPending` verwenden, um Benutzern Feedback zu geben
  return <p>Total Views: {views}</p>
}
```

Denken Sie daran, die [Verhaltensweisen und Einschr√§nkungen](https://react.dev/reference/react/useEffect#caveats) von `useEffect` zu ber√ºcksichtigen.

### Fehlerbehandlung

Wenn ein Fehler auftritt, wird er von der n√§chsten `error.js` oder `<Suspense>`-Grenze auf dem Client abgefangen. Weitere Informationen finden Sie unter [Fehlerbehandlung](/docs/app/getting-started/error-handling).

> **Gut zu wissen:**
>
> - Neben dem Ausl√∂sen des Fehlers k√∂nnen Sie auch ein Objekt zur√ºckgeben, das von `useActionState` verarbeitet wird.

### Datenrevalidierung

Sie k√∂nnen den [Next.js Cache](/docs/app/deep-dive/caching) innerhalb Ihrer Server Actions mit der [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)-API revalidieren:

```ts filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidatePath('/posts')
}
```

Oder Sie k√∂nnen einen bestimmten Datenabruf mit einem Cache-Tag √ºber [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) invalidieren:

```ts filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

```js filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts')
}
```

### Umleitung

Wenn Sie den Benutzer nach Abschluss einer Server Action zu einer anderen Route weiterleiten m√∂chten, k√∂nnen Sie die [`redirect`](/docs/app/api-reference/functions/redirect)-API verwenden. `redirect` muss au√üerhalb des `try/catch`-Blocks aufgerufen werden:

```ts filename="app/actions.ts" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id: string) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Zwischengespeicherte Beitr√§ge aktualisieren
  redirect(`/post/${id}`) // Zur neuen Beitragsseite navigieren
}
```

```js filename="app/actions.js" switcher
'use server'

import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'

export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }

  revalidateTag('posts') // Zwischengespeicherte Beitr√§ge aktualisieren
  redirect(`/post/${id}`) // Zur neuen Beitragsseite navigieren
}
```

### Cookies

Sie k√∂nnen Cookies innerhalb einer Server Action mit der [`cookies`](/docs/app/api-reference/functions/cookies)-API `get`, `set` und `delete`:

```ts filename="app/actions.ts" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  const cookieStore = await cookies()

  // Cookie abrufen
  cookieStore.get('name')?.value

  // Cookie setzen
  cookieStore.set('name', 'Delba')

  // Cookie l√∂schen
  cookieStore.delete('name')
}
```

```js filename="app/actions.js" switcher
'use server'

import { cookies } from 'next/headers'

export async function exampleAction() {
  // Cookie abrufen
  const cookieStore = await cookies()

  // Cookie abrufen
  cookieStore.get('name')?.value

  // Cookie setzen
  cookieStore.set('name', 'Delba')

  // Cookie l√∂schen
  cookieStore.delete('name')
}
```

Weitere Beispiele finden Sie unter [Cookies l√∂schen](/docs/app/api-reference/functions/cookies#deleting-cookies).

## Sicherheit

Standardm√§√üig erstellt eine Server Action, wenn sie erstellt und exportiert wird, einen √∂ffentlichen HTTP-Endpunkt und sollte mit den gleichen Sicherheitsannahmen und Autorisierungspr√ºfungen behandelt werden. Das bedeutet, selbst wenn eine Server Action oder Hilfsfunktion nicht anderswo in Ihrem Code importiert wird, ist sie dennoch √∂ffentlich zug√§nglich.

Um die Sicherheit zu verbessern, bietet Next.js die folgenden integrierten Funktionen:

- **Sichere Action-IDs:** Next.js erstellt verschl√ºsselte, nicht-deterministische IDs, die es dem Client erm√∂glichen, auf die Server Action zu verweisen und sie aufzurufen. Diese IDs werden zwischen Builds periodisch neu berechnet, um die Sicherheit zu erh√∂hen.
- **Dead-Code-Eliminierung:** Nicht verwendete Server Actions (referenziert durch ihre IDs) werden aus dem Client-Bundle entfernt, um den √∂ffentlichen Zugriff durch Dritte zu vermeiden.

> **Gut zu wissen:**
>
> Die IDs werden w√§hrend der Kompilierung erstellt und f√ºr maximal 14 Tage zwischengespeichert. Sie werden neu generiert, wenn ein neuer Build initiiert wird oder der Build-Cache ung√ºltig wird.
> Diese Sicherheitsverbesserung reduziert das Risiko in F√§llen, in denen eine Authentifizierungsschicht fehlt. Dennoch sollten Sie Server Actions wie √∂ffentliche HTTP-Endpunkte behandeln.

```jsx
// app/actions.js
'use server'

// Diese Aktion **wird** in unserer Anwendung verwendet, daher erstellt Next.js
// eine sichere ID, damit der Client auf die Server Action verweisen
// und sie aufrufen kann.
export async function updateUserAction(formData) {}

// Diese Aktion **wird nicht** in unserer Anwendung verwendet, daher entfernt Next.js
// diesen Code automatisch w√§hrend `next build`
// und erstellt keinen √∂ffentlichen Endpunkt.
export async function deleteUserAction(formData) {}
```

### Authentifizierung und Autorisierung

Sie sollten sicherstellen, dass der Benutzer berechtigt ist, die Aktion auszuf√ºhren. Zum Beispiel:

```tsx filename="app/actions.ts"
'use server'

import { auth } from './lib'

export function addItem() {
  const { user } = auth()
  if (!user) {
    throw new Error('Sie m√ºssen angemeldet sein, um diese Aktion auszuf√ºhren')
  }

  // ...
}
```

### Closures und Verschl√ºsselung

Das Definieren einer Server Action innerhalb einer Komponente erstellt einen [Closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), in dem die Aktion Zugriff auf den Scope der √§u√üeren Funktion hat. Zum Beispiel hat die `publish`-Aktion Zugriff auf die `publishVersion`-Variable:

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('Die Version hat sich seit dem Dr√ºcken von "Publish" ge√§ndert');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const publishVersion = await getLatestVersion();

  async function publish() {
    "use server";
    if (publishVersion !== await getLatestVersion()) {
      throw new Error('Die Version hat sich seit dem Dr√ºcken von "Publish" ge√§ndert');
    }
    ...
  }

  return (
    <form>
      <button formAction={publish}>Publish</button>
    </form>
  );
}
```

Closures sind n√ºtzlich, wenn Sie eine Momentaufnahme von Daten (z.B. `publishVersion`) zum Zeitpunkt des Renderings erfassen m√ºssen, damit sie sp√§ter verwendet werden k√∂nnen, wenn die Aktion aufgerufen wird.

Damit dies funktioniert, werden die erfassten Variablen jedoch an den Client und zur√ºck zum Server gesendet, wenn die Aktion aufgerufen wird. Um zu verhindern, dass sensible Daten dem Client zug√§nglich gemacht werden, verschl√ºsselt Next.js die eingeschlossenen Variablen automatisch. F√ºr jede Aktion wird bei jedem Build einer Next.js-Anwendung ein neuer privater Schl√ºssel generiert. Das bedeutet, dass Aktionen nur f√ºr einen bestimmten Build aufgerufen werden k√∂nnen.

> **Gut zu wissen:** Wir empfehlen nicht, sich allein auf die Verschl√ºsselung zu verlassen, um zu verhindern, dass sensible Werte dem Client zug√§nglich gemacht werden. Stattdessen sollten Sie die [React taint APIs](/docs/app/api-reference/config/next-config-js/taint) verwenden, um proaktiv zu verhindern, dass bestimmte Daten an den Client gesendet werden.

### √úberschreiben von Verschl√ºsselungsschl√ºsseln (Fortgeschrittene)

Wenn Sie Ihre Next.js-Anwendung selbst auf mehreren Servern hosten, kann jede Serverinstanz einen unterschiedlichen Verschl√ºsselungsschl√ºssel erhalten, was zu potenziellen Inkonsistenzen f√ºhren kann.

Um dies zu vermeiden, k√∂nnen Sie den Verschl√ºsselungsschl√ºssel mit der Umgebungsvariable `process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY` √ºberschreiben. Durch die Angabe dieser Variable wird sichergestellt, dass Ihre Verschl√ºsselungsschl√ºssel √ºber Builds hinweg konsistent bleiben und alle Serverinstanzen denselben Schl√ºssel verwenden. Diese Variable **muss** mit AES-GCM verschl√ºsselt sein.

Dies ist ein fortgeschrittener Anwendungsfall, bei dem ein einheitliches Verschl√ºsselungsverhalten √ºber mehrere Bereitstellungen hinweg f√ºr Ihre Anwendung entscheidend ist. Sie sollten Standard-Sicherheitspraktiken wie Schl√ºsselrotation und Signierung ber√ºcksichtigen.

> **Gut zu wissen:** Next.js-Anwendungen, die auf Vercel bereitgestellt werden, handhaben dies automatisch.

### Erlaubte Urspr√ºnge (Fortgeschrittene)

Da Server-Aktionen (Server Actions) in einem `<form>`-Element aufgerufen werden k√∂nnen, sind sie anf√§llig f√ºr [CSRF-Angriffe](https://developer.mozilla.org/en-US/docs/Glossary/CSRF).

Im Hintergrund verwenden Server-Aktionen die `POST`-Methode, und nur diese HTTP-Methode ist f√ºr ihren Aufruf erlaubt. Dies verhindert die meisten CSRF-Schwachstellen in modernen Browsern, insbesondere da [SameSite-Cookies](https://web.dev/articles/samesite-cookies-explained) standardm√§√üig aktiviert sind.

Als zus√§tzlichen Schutz vergleichen Server-Aktionen in Next.js auch den [Origin-Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) mit dem [Host-Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host) (oder `X-Forwarded-Host`). Wenn diese nicht √ºbereinstimmen, wird die Anfrage abgebrochen. Mit anderen Worten: Server-Aktionen k√∂nnen nur auf demselben Host aufgerufen werden, auf dem die sie enthaltende Seite gehostet wird.

F√ºr gro√üe Anwendungen, die Reverse-Proxies oder mehrschichtige Backend-Architekturen verwenden (bei denen sich die Server-API von der Produktionsdom√§ne unterscheidet), wird empfohlen, die Konfigurationsoption [`serverActions.allowedOrigins`](/docs/app/api-reference/config/next-config-js/serverActions) zu verwenden, um eine Liste sicherer Urspr√ºnge anzugeben. Die Option akzeptiert ein Array von Strings.

```js filename="next.config.js"
/** @type {import('next').NextConfig} */
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

Erfahren Sie mehr √ºber [Sicherheit und Server-Aktionen](https://nextjs.org/blog/security-nextjs-server-components-actions).

## Zus√§tzliche Ressourcen

Weitere Informationen finden Sie in den folgenden React-Dokumenten:

- [Server-Aktionen](https://react.dev/reference/rsc/server-actions)
- [`"use server"`](https://react.dev/reference/react/use-server)
- [`<form>`](https://react.dev/reference/react-dom/components/form)
- [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)
- [`useActionState`](https://react.dev/reference/react/useActionState)
- [`useOptimistic`](https://react.dev/reference/react/useOptimistic)
