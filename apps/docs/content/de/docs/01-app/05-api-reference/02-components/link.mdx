---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:15:30.407Z
title: Link
description: Ermöglicht schnelle clientseitige Navigation mit der integrierten `next/link`-Komponente.
---

{/* Der Inhalt dieses Dokuments wird sowohl für den App- als auch für den Pages-Router verwendet. Sie können die `<PagesOnly>Content</PagesOnly>`-Komponente verwenden, um Inhalte hinzuzufügen, die spezifisch für den Pages-Router sind. Gemeinsam genutzte Inhalte sollten nicht in eine Komponente eingeschlossen werden. */}

`<Link>` ist eine React-Komponente, die das HTML-`<a>`-Element erweitert, um [Prefetching](/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching) und clientseitige Navigation zwischen Routen zu ermöglichen. Es ist die primäre Methode, um zwischen Routen in Next.js zu navigieren.

Grundlegende Verwendung:

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

</PagesOnly>

## Referenz

Die folgenden Props können an die `<Link>`-Komponente übergeben werden:

<PagesOnly>

| Prop                                | Beispiel                  | Typ               | Erforderlich |
| ----------------------------------- | ------------------------ | ----------------- | ------------ |
| [`href`](#href-required)            | `href="/dashboard"`      | String oder Objekt | Ja           |
| [`replace`](#replace)               | `replace={false}`        | Boolean           | -            |
| [`scroll`](#scroll)                 | `scroll={false}`         | Boolean           | -            |
| [`prefetch`](#prefetch)             | `prefetch={false}`       | Boolean           | -            |
| [`legacyBehavior`](#legacybehavior) | `legacyBehavior={true}`  | Boolean           | -            |
| [`passHref`](#passhref)             | `passHref={true}`        | Boolean           | -            |
| [`shallow`](#shallow)               | `shallow={false}`        | Boolean           | -            |
| [`locale`](#locale)                 | `locale="fr"`            | String oder Boolean | -            |
| [`onNavigate`](#onnavigate)         | `onNavigate={(e) => {}}` | Funktion          | -            |

</PagesOnly>

<AppOnly>

| Prop                        | Beispiel                  | Typ              | Erforderlich |
| --------------------------- | ------------------------ | ---------------- | ------------ |
| [`href`](#href-required)    | `href="/dashboard"`      | String oder Objekt | Ja           |
| [`replace`](#replace)       | `replace={false}`        | Boolean          | -            |
| [`scroll`](#scroll)         | `scroll={false}`         | Boolean          | -            |
| [`prefetch`](#prefetch)     | `prefetch={false}`       | Boolean oder null | -            |
| [`onNavigate`](#onnavigate) | `onNavigate={(e) => {}}` | Funktion         | -            |

</AppOnly>

> **Gut zu wissen**: Attribute des `<a>`-Tags wie `className` oder `target="_blank"` können als Props an `<Link>` übergeben werden und werden an das zugrunde liegende `<a>`-Element weitergegeben.

### `href` (erforderlich)

Der Pfad oder die URL, zu der navigiert werden soll.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

// Navigiere zu /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

// Navigiere zu /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

// Navigiere zu /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

// Navigiere zu /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

</PagesOnly>

### `replace`

**Standardwert: `false`.** Wenn `true`, ersetzt `next/link` den aktuellen Verlaufseintrag, anstatt eine neue URL zum [Browserverlauf](https://developer.mozilla.org/docs/Web/API/History_API) hinzuzufügen.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `scroll`

**Standardwert: `true`.** Das standardmäßige Scrollverhalten von `<Link>` in Next.js **ist die Beibehaltung der Scrollposition**, ähnlich wie Browser mit der Navigation vor und zurück umgehen. Wenn Sie zu einer neuen [Seite](/docs/app/api-reference/file-conventions/page) navigieren, bleibt die Scrollposition gleich, solange die Seite im Viewport sichtbar ist. Wenn die Seite jedoch nicht im Viewport sichtbar ist, scrollt Next.js zum obersten Element der Seite.

Wenn `scroll = {false}`, versucht Next.js nicht, zum ersten Seitenelement zu scrollen.

> **Gut zu wissen**: Next.js prüft `scroll: false`, bevor es das Scrollverhalten verwaltet. Wenn das Scrollen aktiviert ist, identifiziert es den relevanten DOM-Knoten für die Navigation und überprüft jedes Top-Level-Element. Alle nicht scrollbaren Elemente und solche ohne gerendertes HTML werden übersprungen, einschließlich Elementen mit fester oder sticky Positionierung und nicht sichtbaren Elementen, die mit `getBoundingClientRect` berechnet werden. Next.js durchläuft dann die Geschwisterelemente, bis es ein scrollbares Element findet, das im Viewport sichtbar ist.

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

### `prefetch`

<AppOnly>

Das Prefetching erfolgt, wenn eine `<Link />`-Komponente in den Viewport des Benutzers gelangt (initial oder durch Scrollen). Next.js lädt die verlinkte Route (angegeben durch `href`) und ihre Daten im Hintergrund vor, um die Leistung der clientseitigen Navigation zu verbessern. Wenn die vorab geladenen Daten abgelaufen sind, wenn der Benutzer über einen `<Link />` hovered, versucht Next.js, sie erneut vorzuladen. **Prefetching ist nur in der Produktion aktiviert**.

Die folgenden Werte können an die `prefetch`-Prop übergeben werden:

- **`null` (Standard)**: Das Prefetch-Verhalten hängt davon ab, ob die Route statisch oder dynamisch ist. Für statische Routen wird die vollständige Route (einschließlich aller Daten) vorab geladen. Für dynamische Routen wird der Teil der Route bis zum nächsten Segment mit einer [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)-Grenze vorab geladen.
- `true`: Die vollständige Route wird für statische und dynamische Routen vorab geladen.
- `false`: Prefetching erfolgt weder beim Eintritt in den Viewport noch beim Hover.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

Das Prefetching erfolgt, wenn eine `<Link />`-Komponente in den Viewport des Benutzers gelangt (initial oder durch Scrollen). Next.js lädt die verlinkte Route (angegeben durch `href`) und die Daten im Hintergrund vor, um die Leistung der clientseitigen Navigation zu verbessern. **Prefetching ist nur in der Produktion aktiviert**.

Die folgenden Werte können an die `prefetch`-Prop übergeben werden:

- **`true` (Standard)**: Die vollständige Route und ihre Daten werden vorab geladen.
- `false`: Prefetching erfolgt nicht beim Eintritt in den Viewport, aber beim Hover. Wenn Sie das Prefetching beim Hover vollständig deaktivieren möchten, sollten Sie ein `<a>`-Tag verwenden oder [inkrementell migrieren](/docs/app/guides/migrating/app-router-migration) zum App-Router, der auch das Deaktivieren des Prefetchings beim Hover ermöglicht.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

### `legacyBehavior`

> **Warnung**: Die `legacyBehavior`-Prop wird in Next.js v16 entfernt. Um das neue `<Link>`-Verhalten zu übernehmen, entfernen Sie alle `<a>`-Tags, die als Kinder von `<Link>` verwendet werden. Ein [Codemod ist verfügbar](/docs/app/guides/upgrading/codemods#new-link), um Ihnen bei der automatischen Aktualisierung Ihres Codebase zu helfen.

Seit Version 13 ist ein `<a>`-Element nicht mehr als Kind der `<Link>`-Komponente erforderlich. Wenn Sie das alte Verhalten aus Kompatibilitätsgründen dennoch benötigen, können Sie die `legacyBehavior`-Prop hinzufügen.

> **Gut zu wissen**: Wenn `legacyBehavior` nicht auf `true` gesetzt ist, können alle [`anchor`](https://developer.mozilla.org/docs/Web/HTML/Element/a)-Tag-Eigenschaften wie `className`, `onClick` usw. auch an `next/link` übergeben werden.

### `passHref`

Erzwingt, dass `Link` die `href`-Eigenschaft an sein Kind weitergibt. Standardwert ist `false`. Siehe das Beispiel [Übergeben einer funktionalen Komponente](#nesting-a-functional-component) für weitere Informationen.

### `shallow`

Aktualisiert den Pfad der aktuellen Seite, ohne [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props), [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props) oder [`getInitialProps`](/docs/pages/api-reference/functions/get-initial-props) erneut auszuführen. Standardwert ist `false`.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/dashboard" shallow={false}>
      Dashboard
    </Link>
  )
}
```

### `locale`

Die aktive Locale wird automatisch vorangestellt. Mit `locale` kann eine andere Locale angegeben werden. Wenn `false`, muss `href` die Locale enthalten, da das Standardverhalten deaktiviert ist.

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Standardverhalten: Locale wird vorangestellt */}
      <Link href="/dashboard">Dashboard (mit Locale)</Link>

      {/* Deaktiviert das Voranstellen der Locale */}
      <Link href="/dashboard" locale={false}>
        Dashboard (ohne Locale)
      </Link>

      {/* Gibt eine andere Locale an */}
      <Link href="/dashboard" locale="fr">
        Dashboard (Französisch)
      </Link>
    </>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <>
      {/* Standardverhalten: Locale wird vorangestellt */}
      <Link href="/dashboard">Dashboard (mit Locale)</Link>

      {/* Deaktiviert das Voranstellen der Locale */}
      <Link href="/dashboard" locale={false}>
        Dashboard (ohne Locale)
      </Link>

      {/* Gibt eine andere Locale an */}
      <Link href="/dashboard" locale="fr">
        Dashboard (Französisch)
      </Link>
    </>
  )
}
```

</PagesOnly>

### `onNavigate`

Ein Event-Handler, der während der clientseitigen Navigation aufgerufen wird. Der Handler empfängt ein Event-Objekt, das eine `preventDefault()`-Methode enthält, mit der Sie die Navigation bei Bedarf abbrechen können.

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Wird nur während der SPA-Navigation ausgeführt
        console.log('Navigiere...')

        // Optional Navigation abbrechen
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Wird nur während der SPA-Navigation ausgeführt
        console.log('Navigiere...')

        // Optional Navigation abbrechen
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```

> **Gut zu wissen**: Obwohl `onClick` und `onNavigate` ähnlich erscheinen mögen, dienen sie unterschiedlichen Zwecken. `onClick` wird für alle Klick-Events ausgeführt, während `onNavigate` nur während der clientseitigen Navigation läuft. Einige wichtige Unterschiede:
>
> - Bei Verwendung von Modifikatortasten (`Strg`/`Cmd` + Klick) wird `onClick` ausgeführt, aber nicht `onNavigate`, da Next.js die Standardnavigation für neue Tabs verhindert.
> - Externe URLs lösen `onNavigate` nicht aus, da es nur für clientseitige und same-origin-Navigationen gilt.
> - Links mit dem `download`-Attribut funktionieren mit `onClick`, aber nicht mit `onNavigate`, da der Browser die verlinkte URL als Download behandelt.

## Beispiele

Die folgenden Beispiele zeigen, wie die `<Link>`-Komponente in verschiedenen Szenarien verwendet wird.

<AppOnly>

### Verlinkung zu dynamischen Segmenten

Beim Verlinken zu [dynamischen Segmenten](/docs/app/api-reference/file-conventions/dynamic-routes) können Sie [Template-Literale und Interpolation](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals) verwenden, um eine Liste von Links zu generieren. Zum Beispiel, um eine Liste von Blog-Posts zu generieren:

```tsx filename="app/blog/post-list.tsx" switcher
import Link from 'next/link'

interface Post {
  id: number
  title: string
  slug: string
}

export default function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/post-list.js" switcher
import Link from 'next/link'

export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

### Aktive Links überprüfen

Sie können [`usePathname()`](/docs/app/api-reference/functions/use-pathname) verwenden, um festzustellen, ob ein Link aktiv ist. Um beispielsweise eine Klasse zum aktiven Link hinzuzufügen, können Sie prüfen, ob der aktuelle `pathname` mit dem `href` des Links übereinstimmt:

```tsx filename="app/ui/nav-links.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

```jsx filename="app/ui/nav-links.js" switcher
'use client'

import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Links() {
  const pathname = usePathname()

  return (
    <nav>
      <Link className={`link ${pathname === '/' ? 'active' : ''}`} href="/">
        Home
      </Link>

      <Link
        className={`link ${pathname === '/about' ? 'active' : ''}`}
        href="/about"
      >
        About
      </Link>
    </nav>
  )
}
```

### Zu einer `id` scrollen

Wenn Sie zu einer bestimmten `id` navigieren möchten, können Sie Ihre URL mit einem `#`-Hash-Link ergänzen oder einfach einen Hash-Link an die `href`-Prop übergeben. Dies ist möglich, da `<Link>` zu einem `<a>`-Element gerendert wird.

```jsx
<Link href="/dashboard#settings">Settings</Link>

// Ausgabe
<a href="/dashboard#settings">Settings</a>
```

> **Gut zu wissen**:
>
> - Next.js scrollt zur [Page](/docs/app/api-reference/file-conventions/page), wenn diese bei der Navigation nicht im Viewport sichtbar ist.

</AppOnly>

### Verlinkung zu dynamischen Routensegmenten

Für [dynamische Routensegmente](/docs/app/api-reference/file-conventions/dynamic-routes) kann es praktisch sein, Template-Literale zu verwenden, um den Pfad des Links zu erstellen.

<PagesOnly>

Beispielsweise können Sie eine Liste von Links zur dynamischen Route `pages/blog/[slug].js` generieren:

```tsx filename="pages/blog/index.tsx" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="pages/blog/index.js" switcher
import Link from 'next/link'

function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}

export default Posts
```

</PagesOnly>

<AppOnly>

Beispielsweise können Sie eine Liste von Links zur dynamischen Route `app/blog/[slug]/page.js` generieren:

```tsx filename="app/blog/page.tsx" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/blog/page.js" switcher
import Link from 'next/link'

export default function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

</AppOnly>

### Wenn das Kind eine benutzerdefinierte Komponente ist, die ein `<a>`-Tag umschließt

<AppOnly>

Wenn das Kind von `Link` eine benutzerdefinierte Komponente ist, die ein `<a>`-Tag umschließt, müssen Sie `passHref` zu `Link` hinzufügen. Dies ist notwendig, wenn Sie Bibliotheken wie [styled-components](https://styled-components.com/) verwenden. Ohne dies hat das `<a>`-Tag kein `href`-Attribut, was die Barrierefreiheit Ihrer Website beeinträchtigt und sich möglicherweise auf die SEO auswirkt. Wenn Sie [ESLint](/docs/pages/api-reference/config/eslint) verwenden, gibt es eine eingebaute Regel `next/link-passhref`, um die korrekte Verwendung von `passHref` sicherzustellen.

</AppOnly>

<PagesOnly>

Wenn das Kind von `Link` eine benutzerdefinierte Komponente ist, die ein `<a>`-Tag umschließt, müssen Sie `passHref` zu `Link` hinzufügen. Dies ist notwendig, wenn Sie Bibliotheken wie [styled-components](https://styled-components.com/) verwenden. Ohne dies hat das `<a>`-Tag kein `href`-Attribut, was die Barrierefreiheit Ihrer Website beeinträchtigt und sich möglicherweise auf die SEO auswirkt. Wenn Sie [ESLint](/docs/pages/api-reference/config/eslint) verwenden, gibt es eine eingebaute Regel `next/link-passhref`, um die korrekte Verwendung von `passHref` sicherzustellen.

</PagesOnly>

```tsx filename="components/nav-link.tsx" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Dies erstellt eine benutzerdefinierte Komponente, die ein <a>-Tag umschließt
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

```jsx filename="components/nav-link.js" switcher
import Link from 'next/link'
import styled from 'styled-components'

// Dies erstellt eine benutzerdefinierte Komponente, die ein <a>-Tag umschließt
const RedLink = styled.a`
  color: red;
`

function NavLink({ href, name }) {
  return (
    <Link href={href} passHref legacyBehavior>
      <RedLink>{name}</RedLink>
    </Link>
  )
}

export default NavLink
```

- Wenn Sie die JSX-Pragma-Funktion (`@jsx jsx`) von [emotion](https://emotion.sh/) verwenden, müssen Sie `passHref` auch dann verwenden, wenn Sie direkt ein `<a>`-Tag verwenden.
- Die Komponente sollte die `onClick`-Property unterstützen, um die Navigation korrekt auszulösen.

### Verschachtelung einer funktionalen Komponente

Wenn das Kind von `Link` eine funktionale Komponente ist, müssen Sie zusätzlich zu `passHref` und `legacyBehavior` die Komponente in [`React.forwardRef`](https://react.dev/reference/react/forwardRef) wrappen:

<AppOnly>

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Definieren Sie den Props-Typ für MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Verwenden Sie React.ForwardRefRenderFunction, um den weitergeleiteten Ref korrekt zu typisieren
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Verwenden Sie React.forwardRef, um die Komponente zu wrappen
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` und `ref` müssen an das DOM-Element übergeben werden
// für die korrekte Handhabung
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Fügen Sie einen Anzeigenamen für die Komponente hinzu (nützlich für Debugging)
MyButton.displayName = 'MyButton'

export default function Page() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'
import React from 'react'

// Definieren Sie den Props-Typ für MyButton
interface MyButtonProps {
  onClick?: React.MouseEventHandler<HTMLAnchorElement>
  href?: string
}

// Verwenden Sie React.ForwardRefRenderFunction, um den weitergeleiteten Ref korrekt zu typisieren
const MyButton: React.ForwardRefRenderFunction<
  HTMLAnchorElement,
  MyButtonProps
> = ({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
}

// Verwenden Sie React.forwardRef, um die Komponente zu wrappen
const ForwardedMyButton = React.forwardRef(MyButton)

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <ForwardedMyButton />
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'
import React from 'react'

// `onClick`, `href` und `ref` müssen an das DOM-Element übergeben werden
// für die korrekte Handhabung
const MyButton = React.forwardRef(({ onClick, href }, ref) => {
  return (
    <a href={href} onClick={onClick} ref={ref}>
      Click Me
    </a>
  )
})

// Fügen Sie einen Anzeigenamen für die Komponente hinzu (nützlich für Debugging)
MyButton.displayName = 'MyButton'

export default function Home() {
  return (
    <Link href="/about" passHref legacyBehavior>
      <MyButton />
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

### Übergeben eines URL-Objekts

`Link` kann auch ein URL-Objekt empfangen und es automatisch formatieren, um die URL-Zeichenkette zu erstellen:

```tsx filename="pages/index.ts" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

function Home() {
  return (
    <ul>
      <li>
        <Link
          href={{
            pathname: '/about',
            query: { name: 'test' },
          }}
        >
          About us
        </Link>
      </li>
      <li>
        <Link
          href={{
            pathname: '/blog/[slug]',
            query: { slug: 'my-post' },
          }}
        >
          Blog Post
        </Link>
      </li>
    </ul>
  )
}

export default Home
```

Das obige Beispiel enthält einen Link zu:

- Einer vordefinierten Route: `/about?name=test`
- Einer [dynamischen Route](/docs/app/api-reference/file-conventions/dynamic-routes): `/blog/my-post`

Sie können jede Property verwenden, wie in der [Node.js URL-Modul-Dokumentation](https://nodejs.org/api/url.html#url_url_strings_and_url_objects) definiert.

</PagesOnly>

### URL ersetzen statt pushen

Das Standardverhalten der `Link`-Komponente besteht darin, eine neue URL in den `history`-Stack zu `pushen`. Sie können die `replace`-Prop verwenden, um das Hinzufügen eines neuen Eintrags zu verhindern, wie im folgenden Beispiel:

<AppOnly>

```tsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/about" replace>
      About us
    </Link>
  )
}
```

</PagesOnly>

### Scrollen zum Seitenanfang deaktivieren

<AppOnly>

Das Standard-Scrollverhalten von `<Link>` in Next.js **ist die Beibehaltung der Scrollposition**, ähnlich wie Browser bei der Navigation zurück und vorwärts verfahren. Wenn Sie zu einer neuen [Page](/docs/app/api-reference/file-conventions/page) navigieren, bleibt die Scrollposition erhalten, solange die Page im Viewport sichtbar ist.

Wenn die Page jedoch nicht im Viewport sichtbar ist, scrollt Next.js zum oberen Rand des ersten Page-Elements. Wenn Sie dieses Verhalten deaktivieren möchten, können Sie `scroll={false}` an die `<Link>`-Komponente oder `scroll: false` an `router.push()` oder `router.replace()` übergeben.

```jsx filename="app/page.js" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Deaktiviert das Scrollen zum Seitenanfang
    </Link>
  )
}
```

```tsx filename="app/page.tsx" switcher
import Link from 'next/link'

export default function Page() {
  return (
    <Link href="/#hashid" scroll={false}>
      Deaktiviert das Scrollen zum Seitenanfang
    </Link>
  )
}
```

Verwendung von `router.push()` oder `router.replace()`:

```jsx
// useRouter
import { useRouter } from 'next/navigation'

const router = useRouter()

router.push('/dashboard', { scroll: false })
```

</AppOnly>

<PagesOnly>

Das Standardverhalten von `Link` ist das Scrollen zum Seitenanfang. Wenn ein Hash definiert ist, wird zur spezifischen id gescrollt, wie bei einem normalen `<a>`-Tag. Um das Scrollen zum Seitenanfang / Hash zu verhindern, kann `scroll={false}` zu `Link` hinzugefügt werden:

```jsx filename="pages/index.js" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Deaktiviert das Scrollen zum Seitenanfang
    </Link>
  )
}
```

```tsx filename="pages/index.tsx" switcher
import Link from 'next/link'

export default function Home() {
  return (
    <Link href="/#hashid" scroll={false}>
      Deaktiviert das Scrollen zum Seitenanfang
    </Link>
  )
}
```

</PagesOnly>

### Prefetching von Links in Middleware

Es ist üblich, [Middleware](/docs/app/building-your-application/routing/middleware) für Authentifizierung oder andere Zwecke zu verwenden, die eine Umleitung des Benutzers auf eine andere Seite beinhalten. Damit die `<Link />`-Komponente Links mit Rewrites über Middleware korrekt prefetchen kann, müssen Sie Next.js sowohl die anzuzeigende URL als auch die zu prefetchende URL mitteilen. Dies ist notwendig, um unnötige Anfragen an die Middleware zu vermeiden, um die korrekte Route für das Prefetching zu ermitteln.

Beispiel: Wenn Sie eine `/dashboard`-Route bereitstellen möchten, die authentifizierte und Besucher-Ansichten hat, können Sie folgendes in Ihrer Middleware hinzufügen, um den Benutzer auf die richtige Seite umzuleiten:

```ts filename="middleware.ts" switcher
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

```js filename="middleware.js" switcher
import { NextResponse } from 'next/server'

export function middleware(request) {
  const nextUrl = request.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (request.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', request.url))
    }
  }
}
```

In diesem Fall würden Sie folgenden Code in Ihrer `<Link />`-Komponente verwenden:

<AppOnly>

```tsx filename="app/page.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ihr Authentifizierungs-Hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="app/page.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ihr Authentifizierungs-Hook

export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</AppOnly>

<PagesOnly>

```tsx filename="pages/index.tsx" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ihr Authentifizierungs-Hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

```js filename="pages/index.js" switcher
'use client'

import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed' // Ihr Authentifizierungs-Hook

export default function Home() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

</PagesOnly>

<PagesOnly>

> **Gut zu wissen**: Wenn Sie [Dynamische Routen](/docs/app/api-reference/file-conventions/dynamic-routes) verwenden, müssen Sie Ihre `as`- und `href`-Props anpassen. Beispiel: Wenn Sie eine dynamische Route wie `/dashboard/authed/[user]` haben, die Sie über Middleware anders darstellen möchten, würden Sie schreiben: `<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profil</Link>`.

</PagesOnly>

### Blockieren der Navigation

Sie können die `onNavigate`-Prop verwenden, um die Navigation zu blockieren, wenn bestimmte Bedingungen erfüllt sind, z.B. wenn ein Formular ungespeicherte Änderungen enthält. Wenn Sie die Navigation über mehrere Komponenten in Ihrer App hinweg blockieren müssen (z.B. um die Navigation von jedem Link zu verhindern, während ein Formular bearbeitet wird), bietet React Context eine saubere Möglichkeit, diesen Blockierstatus zu teilen. Erstellen Sie zunächst einen Context, um den Blockierstatus der Navigation zu verfolgen:

```tsx filename="app/contexts/navigation-blocker.tsx" switcher
'use client'

import { createContext, useState, useContext } from 'react'

interface NavigationBlockerContextType {
  isBlocked: boolean
  setIsBlocked: (isBlocked: boolean) => void
}

export const NavigationBlockerContext =
  createContext<NavigationBlockerContextType>({
    isBlocked: false,
    setIsBlocked: () => {},
  })

export function NavigationBlockerProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

```jsx filename="app/contexts/navigation-blocker.js" switcher
'use client'

import { createContext, useState, useContext } from 'react'

export const NavigationBlockerContext = createContext({
  isBlocked: false,
  setIsBlocked: () => {},
})

export function NavigationBlockerProvider({ children }) {
  const [isBlocked, setIsBlocked] = useState(false)

  return (
    <NavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}>
      {children}
    </NavigationBlockerContext.Provider>
  )
}

export function useNavigationBlocker() {
  return useContext(NavigationBlockerContext)
}
```

Erstellen Sie eine Formularkomponente, die den Context verwendet:

```tsx filename="app/components/form.tsx" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Speichern</button>
    </form>
  )
}
```

```jsx filename="app/components/form.js" switcher
'use client'

import { useNavigationBlocker } from '../contexts/navigation-blocker'

export default function Form() {
  const { setIsBlocked } = useNavigationBlocker()

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault()
        setIsBlocked(false)
      }}
      onChange={() => setIsBlocked(true)}
    >
      <input type="text" name="name" />
      <button type="submit">Speichern</button>
    </form>
  )
}
```

Erstellen Sie eine benutzerdefinierte Link-Komponente, die die Navigation blockiert:

```tsx filename="app/components/custom-link.tsx" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

interface CustomLinkProps extends React.ComponentProps<typeof Link> {
  children: React.ReactNode
}

export function CustomLink({ children, ...props }: CustomLinkProps) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('Sie haben ungespeicherte Änderungen. Trotzdem verlassen?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

```jsx filename="app/components/custom-link.js" switcher
'use client'

import Link from 'next/link'
import { useNavigationBlocker } from '../contexts/navigation-blocker'

export function CustomLink({ children, ...props }) {
  const { isBlocked } = useNavigationBlocker()

  return (
    <Link
      onNavigate={(e) => {
        if (
          isBlocked &&
          !window.confirm('Sie haben ungespeicherte Änderungen. Trotzdem verlassen?')
        ) {
          e.preventDefault()
        }
      }}
      {...props}
    >
      {children}
    </Link>
  )
}
```

Erstellen Sie eine Navigationskomponente:

```tsx filename="app/components/nav.tsx" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Startseite</Link>
      <Link href="/about">Über uns</Link>
    </nav>
  )
}
```

```jsx filename="app/components/nav.js" switcher
'use client'

import { CustomLink as Link } from './custom-link'

export default function Nav() {
  return (
    <nav>
      <Link href="/">Startseite</Link>
      <Link href="/about">Über uns</Link>
    </nav>
  )
}
```

Schließlich umschließen Sie Ihre App mit dem `NavigationBlockerProvider` im Root-Layout und verwenden die Komponenten in Ihrer Seite:

```tsx filename="app/layout.tsx" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
import { NavigationBlockerProvider } from './contexts/navigation-blocker'

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <NavigationBlockerProvider>{children}</NavigationBlockerProvider>
      </body>
    </html>
  )
}
```

Verwenden Sie dann die `Nav`- und `Form`-Komponenten in Ihrer Seite:

```tsx filename="app/page.tsx" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Willkommen im Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

```jsx filename="app/page.js" switcher
import Nav from './components/nav'
import Form from './components/form'

export default function Page() {
  return (
    <div>
      <Nav />
      <main>
        <h1>Willkommen im Dashboard</h1>
        <Form />
      </main>
    </div>
  )
}
```

Wenn ein Benutzer versucht, mit `CustomLink` wegzunavigieren, während das Formular ungespeicherte Änderungen enthält, wird er aufgefordert, dies zu bestätigen, bevor er die Seite verlässt.

## Versionsverlauf

| Version   | Änderungen                                                                                                                                                                      |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `v15.3.0` | `onNavigate`-API hinzugefügt                                                                                                                                                         |
| `v13.0.0` | Benötigt kein untergeordnetes `<a>`-Tag mehr. Ein [Codemod](/docs/app/guides/upgrading/codemods#remove-a-tags-from-link-components) wird bereitgestellt, um Ihre Codebasis automatisch zu aktualisieren. |
| `v10.0.0` | `href`-Props, die auf eine dynamische Route verweisen, werden automatisch aufgelöst und benötigen keine `as`-Prop mehr.                                                                      |
| `v8.0.0`  | Verbesserte Prefetching-Leistung.                                                                                                                                            |
| `v1.0.0`  | `next/link` eingeführt.                                                                                                                                                      |
