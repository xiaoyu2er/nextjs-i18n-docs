---
source-updated-at: 2025-06-01T01:32:20.000Z
translation-updated-at: 2025-06-02T20:08:19.339Z
title: TypeScript
description: Next.js bietet eine TypeScript-first-Entwicklungsumgebung f√ºr den Aufbau Ihrer React-Anwendung.
---

{/* Der Inhalt dieses Dokuments wird sowohl f√ºr den App- als auch f√ºr den Pages-Router verwendet. Sie k√∂nnen die `<PagesOnly>Content</PagesOnly>`-Komponente verwenden, um Inhalte hinzuzuf√ºgen, die spezifisch f√ºr den Pages-Router sind. Gemeinsam genutzte Inhalte sollten nicht in eine Komponente eingeschlossen werden. */}

Next.js bringt TypeScript mit sich und installiert automatisch die notwendigen Pakete sowie konfiguriert die richtigen Einstellungen, wenn Sie ein neues Projekt mit `create-next-app` erstellen.

Um TypeScript zu einem bestehenden Projekt hinzuzuf√ºgen, benennen Sie eine Datei in `.ts` / `.tsx` um. F√ºhren Sie `next dev` und `next build` aus, um automatisch die notwendigen Abh√§ngigkeiten zu installieren und eine `tsconfig.json`-Datei mit den empfohlenen Konfigurationsoptionen hinzuzuf√ºgen.

> **Gut zu wissen**: Wenn Sie bereits eine `jsconfig.json`-Datei haben, kopieren Sie die `paths`-Compiler-Option aus der alten `jsconfig.json` in die neue `tsconfig.json`-Datei und l√∂schen Sie die alte `jsconfig.json`-Datei.

<AppOnly>

## IDE-Plugin

Next.js enth√§lt ein benutzerdefiniertes TypeScript-Plugin und einen Type-Checker, die von VSCode und anderen Code-Editoren f√ºr erweiterte Type-Checking- und Auto-Vervollst√§ndigungsfunktionen genutzt werden k√∂nnen.

Sie k√∂nnen das Plugin in VS Code aktivieren, indem Sie:

1. Die Befehlspalette √∂ffnen (`Strg/‚åò` + `Umschalt` + `P`)
2. Nach "TypeScript: Select TypeScript Version" suchen
3. "Use Workspace Version" ausw√§hlen

<Image
  alt="TypeScript-Befehlspalette"
  srcLight="/docs/light/typescript-command-palette.png"
  srcDark="/docs/dark/typescript-command-palette.png"
  width="1600"
  height="637"
/>

Nun wird beim Bearbeiten von Dateien das benutzerdefinierte Plugin aktiviert. Beim Ausf√ºhren von `next build` wird der benutzerdefinierte Type-Checker verwendet.

Das TypeScript-Plugin kann bei folgenden Punkten helfen:

- Warnung, wenn ung√ºltige Werte f√ºr [Segment-Konfigurationsoptionen](/docs/app/api-reference/file-conventions/route-segment-config) √ºbergeben werden.
- Anzeige verf√ºgbarer Optionen und Kontextdokumentation.
- Sicherstellung, dass die `'use client'`-Direktive korrekt verwendet wird.
- Sicherstellung, dass Client-Hooks (wie `useState`) nur in Client-Komponenten verwendet werden.

> **üé• Ansehen:** Erfahren Sie mehr √ºber das integrierte TypeScript-Plugin ‚Üí [YouTube (3 Minuten)](https://www.youtube.com/watch?v=pqMqn9fKEf8)

## End-to-End-Type-Sicherheit

Der Next.js App Router bietet **verbesserte Type-Sicherheit**. Dazu geh√∂ren:

1. **Keine Serialisierung von Daten zwischen Fetch-Funktion und Seite**: Sie k√∂nnen `fetch` direkt in Komponenten, Layouts und Seiten auf dem Server verwenden. Diese Daten m√ºssen _nicht_ serialisiert (in einen String umgewandelt) werden, um an die Client-Seite zur Verwendung in React √ºbergeben zu werden. Da `app` standardm√§√üig Server-Komponenten verwendet, k√∂nnen wir Werte wie `Date`, `Map`, `Set` und mehr ohne zus√§tzliche Schritte verwenden. Fr√ºher mussten Sie die Grenze zwischen Server und Client manuell mit Next.js-spezifischen Typen typisieren.
2. **Optimierter Datenfluss zwischen Komponenten**: Mit der Entfernung von `_app` zugunsten von Root-Layouts ist es nun einfacher, den Datenfluss zwischen Komponenten und Seiten zu visualisieren. Fr√ºher waren Datenfl√ºsse zwischen einzelnen `pages` und `_app` schwer zu typisieren und konnten verwirrende Bugs einf√ºhren. Mit [kolokalisiertem Data Fetching](/docs/app/getting-started/fetching-data) im App-Router ist dies kein Problem mehr.

[Data Fetching in Next.js](/docs/app/getting-started/fetching-data) bietet nun eine m√∂glichst nahe End-to-End-Type-Sicherheit, ohne dabei Ihre Auswahl an Datenbank oder Content-Provider vorzuschreiben.

Wir k√∂nnen die Antwortdaten so typisieren, wie Sie es mit normalem TypeScript erwarten w√ºrden. Beispiel:

```tsx filename="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // Der R√ºckgabewert wird *nicht* serialisiert
  // Sie k√∂nnen Date, Map, Set usw. zur√ºckgeben
  return res.json()
}

export default async function Page() {
  const name = await getData()

  return '...'
}
```

F√ºr _vollst√§ndige_ End-to-End-Type-Sicherheit muss auch Ihre Datenbank oder Ihr Content-Provider TypeScript unterst√ºtzen. Dies kann durch die Verwendung eines [ORM](https://de.wikipedia.org/wiki/Objektrelationale_Abbildung) oder eines type-sicheren Query-Builders erfolgen.

</AppOnly>

## Beispiele

### Type-Checking f√ºr `next.config.ts`

Sie k√∂nnen TypeScript und importierte Typen in Ihrer Next.js-Konfiguration verwenden, indem Sie `next.config.ts` nutzen.

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  /* Konfigurationsoptionen hier */
}

export default nextConfig
```

> **Gut zu wissen**: Die Modulaufl√∂sung in `next.config.ts` ist derzeit auf `CommonJS` beschr√§nkt. Dies kann zu Inkompatibilit√§ten mit ESM-only-Paketen f√ºhren, die in `next.config.ts` geladen werden.

Wenn Sie die `next.config.js`-Datei verwenden, k√∂nnen Sie in Ihrer IDE mit JSDoc eine Type-Checking-Funktionalit√§t hinzuf√ºgen:

```js filename="next.config.js"
// @ts-check

/** @type {import('next').NextConfig} */
const nextConfig = {
  /* Konfigurationsoptionen hier */
}

module.exports = nextConfig
```

<AppOnly>

### Statisch typisierte Links

Next.js kann Links statisch typisieren, um Tippfehler und andere Fehler bei der Verwendung von `next/link` zu verhindern und so die Type-Sicherheit bei der Navigation zwischen Seiten zu verbessern.

Um diese Funktion zu nutzen, muss `experimental.typedRoutes` aktiviert werden und das Projekt muss TypeScript verwenden.

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    typedRoutes: true,
  },
}

export default nextConfig
```

Next.js generiert eine Link-Definition in `.next/types`, die Informationen √ºber alle vorhandenen Routen in Ihrer Anwendung enth√§lt. TypeScript kann diese dann nutzen, um in Ihrem Editor Feedback √ºber ung√ºltige Links zu geben.

Derzeit umfasst die experimentelle Unterst√ºtzung alle String-Literale, einschlie√ülich dynamischer Segmente. F√ºr nicht-literale Strings m√ºssen Sie derzeit den `href` manuell mit `as Route` typisieren:

```tsx
import type { Route } from 'next';
import Link from 'next/link'

// Keine TypeScript-Fehler, wenn href eine g√ºltige Route ist
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />

// TypeScript-Fehler, wenn href keine g√ºltige Route ist
<Link href="/aboot" />
```

Um `href` in einer benutzerdefinierten Komponente, die `next/link` umschlie√üt, zu akzeptieren, verwenden Sie ein Generic:

```tsx
import type { Route } from 'next'
import Link from 'next/link'

function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>Meine Karte</div>
    </Link>
  )
}
```

> **Wie funktioniert das?**
>
> Wenn Sie `next dev` oder `next build` ausf√ºhren, generiert Next.js eine versteckte `.d.ts`-Datei in `.next`, die Informationen √ºber alle vorhandenen Routen in Ihrer Anwendung enth√§lt (alle g√ºltigen Routen als `href`-Typ von `Link`). Diese `.d.ts`-Datei wird in `tsconfig.json` eingebunden und der TypeScript-Compiler √ºberpr√ºft diese `.d.ts` und gibt Feedback in Ihrem Editor √ºber ung√ºltige Links.

### Mit Async Server Components

Um eine `async`-Server-Komponente mit TypeScript zu verwenden, stellen Sie sicher, dass Sie TypeScript `5.1.3` oder h√∂her und `@types/react` `18.2.8` oder h√∂her verwenden.

Wenn Sie eine √§ltere Version von TypeScript verwenden, k√∂nnte ein `'Promise<Element>' is not a valid JSX element`-Type-Fehler auftreten. Ein Update auf die neueste Version von TypeScript und `@types/react` sollte dieses Problem beheben.

</AppOnly>

<PagesOnly>

### Statische Generierung und Server-seitiges Rendering

F√ºr [`getStaticProps`](/docs/pages/api-reference/functions/get-static-props), [`getStaticPaths`](/docs/pages/api-reference/functions/get-static-paths) und [`getServerSideProps`](/docs/pages/api-reference/functions/get-server-side-props) k√∂nnen Sie die Typen `GetStaticProps`, `GetStaticPaths` bzw. `GetServerSideProps` verwenden:

```tsx filename="pages/blog/[slug].tsx"
import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'

export const getStaticProps = (async (context) => {
  // ...
}) satisfies GetStaticProps

export const getStaticPaths = (async () => {
  // ...
}) satisfies GetStaticPaths

export const getServerSideProps = (async (context) => {
  // ...
}) satisfies GetServerSideProps
```

> **Gut zu wissen:** `satisfies` wurde in TypeScript [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) hinzugef√ºgt. Wir empfehlen ein Upgrade auf die neueste Version von TypeScript.

### Mit API-Routen

Das folgende Beispiel zeigt, wie Sie die integrierten Typen f√ºr API-Routen verwenden k√∂nnen:

```ts filename="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ name: 'John Doe' })
}
```

Sie k√∂nnen auch die Antwortdaten typisieren:

```ts filename="pages/api/hello.ts"
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}
```

### Mit benutzerdefinierter `App`

Wenn Sie eine [benutzerdefinierte `App`](/docs/pages/building-your-application/routing/custom-app) haben, k√∂nnen Sie den integrierten Typ `AppProps` verwenden und den Dateinamen in `./pages/_app.tsx` √§ndern:

```ts
import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

</PagesOnly>

### Inkrementelles Type-Checking

Seit `v10.2.1` unterst√ºtzt Next.js [inkrementelles Type-Checking](https://www.typescriptlang.org/tsconfig#incremental), wenn es in Ihrer `tsconfig.json` aktiviert ist. Dies kann die Type-Checking-Geschwindigkeit in gr√∂√üeren Anwendungen verbessern.

### Deaktivieren von TypeScript-Fehlern in der Produktion

Next.js bricht Ihren **Produktionsbuild** (`next build`) ab, wenn TypeScript-Fehler in Ihrem Projekt vorhanden sind.

Wenn Sie m√∂chten, dass Next.js gef√§hrlicherweise Produktionscode erzeugt, selbst wenn Ihre Anwendung Fehler enth√§lt, k√∂nnen Sie den integrierten Type-Checking-Schritt deaktivieren.

Wenn Sie dies deaktivieren, stellen Sie sicher, dass Sie Type-Checks als Teil Ihres Build- oder Deploy-Prozesses durchf√ºhren, da dies sonst sehr gef√§hrlich sein kann.

√ñffnen Sie `next.config.ts` und aktivieren Sie die `ignoreBuildErrors`-Option in der `typescript`-Konfiguration:

```ts filename="next.config.ts"
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  typescript: {
    // !! WARNUNG !!
    // Erlaubt gef√§hrlicherweise, dass Produktionsbuilds erfolgreich abgeschlossen werden,
    // selbst wenn Ihr Projekt Type-Fehler enth√§lt.
    // !! WARNUNG !!
    ignoreBuildErrors: true,
  },
}

export default nextConfig
```

> **Gut zu wissen**: Sie k√∂nnen `tsc --noEmit` ausf√ºhren, um selbst nach TypeScript-Fehlern zu suchen, bevor Sie den Build durchf√ºhren. Dies ist n√ºtzlich f√ºr CI/CD-Pipelines, in denen Sie TypeScript-Fehler vor dem Deployment √ºberpr√ºfen m√∂chten.

### Benutzerdefinierte Typdeklarationen

Wenn Sie benutzerdefinierte Typen deklarieren m√ºssen, k√∂nnten Sie versucht sein, `next-env.d.ts` zu √§ndern. Diese Datei wird jedoch automatisch generiert, sodass alle √Ñnderungen, die Sie vornehmen, √ºberschrieben werden. Stattdessen sollten Sie eine neue Datei erstellen, z.B. `new-types.d.ts`, und diese in Ihrer `tsconfig.json` referenzieren:

```json filename="tsconfig.json"
{
  "compilerOptions": {
    "skipLibCheck": true
    //...gek√ºrzt...
  },
  "include": [
    "new-types.d.ts",
    "next-env.d.ts",
    ".next/types/**/*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
```

## Versions√§nderungen

| Version   | √Ñnderungen                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `v15.0.0` | Unterst√ºtzung f√ºr [`next.config.ts`](#type-checking-f√ºr-nextconfigts) f√ºr TypeScript-Projekte hinzugef√ºgt.                                               |
| `v13.2.0` | Statisch typisierte Links sind in der Beta verf√ºgbar.                                                                                        |
| `v12.0.0` | [SWC](/docs/architecture/nextjs-compiler) wird nun standardm√§√üig verwendet, um TypeScript und TSX f√ºr schnellere Builds zu kompilieren.                    |
| `v10.2.1` | Unterst√ºtzung f√ºr [inkrementelles Type-Checking](https://www.typescriptlang.org/tsconfig#incremental) hinzugef√ºgt, wenn es in Ihrer `tsconfig.json` aktiviert ist. |